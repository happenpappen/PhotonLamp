
/home/cs/DevelopmentProjects/PhotonLamp/target/PhotonLamp.elf:     file format elf32-littlearm

Sections:
Idx Name          Size      VMA       LMA       File off  Algn
  0 .module_info  00000018  080a0000  080a0000  00010000  2**2
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  1 .text         00006db8  080a0018  080a0018  00010018  2**3
                  CONTENTS, ALLOC, LOAD, READONLY, CODE
  2 .backup       00000004  40024000  080a6dd0  00024000  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  3 .data         00000080  20000300  080a6dd4  00030300  2**2
                  CONTENTS, ALLOC, LOAD, DATA
  4 .bss          00000b14  20000380  20000380  00040380  2**2
                  ALLOC
  5 .module_info_suffix 00000028  080a6e54  080a6e54  00036e54  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  6 .module_info_crc 00000004  080a6e7c  080a6e7c  00036e7c  2**0
                  CONTENTS, ALLOC, LOAD, READONLY, DATA
  7 .debug_info   001558aa  00000000  00000000  00036e80  2**0
                  CONTENTS, READONLY, DEBUGGING
  8 .debug_abbrev 0001ee69  00000000  00000000  0018c72a  2**0
                  CONTENTS, READONLY, DEBUGGING
  9 .debug_aranges 00002cf8  00000000  00000000  001ab593  2**0
                  CONTENTS, READONLY, DEBUGGING
 10 .debug_macro  0003c3a2  00000000  00000000  001ae28b  2**0
                  CONTENTS, READONLY, DEBUGGING
 11 .debug_line   0004dc06  00000000  00000000  001ea62d  2**0
                  CONTENTS, READONLY, DEBUGGING
 12 .debug_str    000a881f  00000000  00000000  00238233  2**0
                  CONTENTS, READONLY, DEBUGGING
 13 .debug_loc    00028bd3  00000000  00000000  002e0a52  2**0
                  CONTENTS, READONLY, DEBUGGING
 14 .debug_ranges 00006348  00000000  00000000  00309625  2**0
                  CONTENTS, READONLY, DEBUGGING
 15 .debug_frame  0000e0dc  00000000  00000000  0030f970  2**2
                  CONTENTS, READONLY, DEBUGGING

Disassembly of section .text:

080a0018 <user_part_module>:
 80a0018:	7c 64 0a 08                                         |d..

080a001c <module_user_pre_init>:
/**
 * Initializes this user module. Returns the start of the heap.
 */
void* module_user_pre_init() {

    if ( (&link_global_data_start!=&link_global_data_initial_values) && (link_global_data_size != 0))
 80a001c:	4809      	ldr	r0, [pc, #36]	; (80a0044 <module_user_pre_init+0x28>)
 80a001e:	490a      	ldr	r1, [pc, #40]	; (80a0048 <module_user_pre_init+0x2c>)
extern constructor_ptr_t link_constructors_end;

/**
 * Initializes this user module. Returns the start of the heap.
 */
void* module_user_pre_init() {
 80a0020:	b508      	push	{r3, lr}

    if ( (&link_global_data_start!=&link_global_data_initial_values) && (link_global_data_size != 0))
 80a0022:	4288      	cmp	r0, r1
 80a0024:	d005      	beq.n	80a0032 <module_user_pre_init+0x16>
 80a0026:	4a09      	ldr	r2, [pc, #36]	; (80a004c <module_user_pre_init+0x30>)
 80a0028:	4282      	cmp	r2, r0
 80a002a:	d002      	beq.n	80a0032 <module_user_pre_init+0x16>
    {
        memcpy(&link_global_data_start, &link_global_data_initial_values, link_global_data_size);
 80a002c:	1a12      	subs	r2, r2, r0
 80a002e:	f006 f8ad 	bl	80a618c <memcpy>
    }

    memset(&link_bss_location, 0, link_bss_size );
 80a0032:	4807      	ldr	r0, [pc, #28]	; (80a0050 <module_user_pre_init+0x34>)
 80a0034:	4a07      	ldr	r2, [pc, #28]	; (80a0054 <module_user_pre_init+0x38>)
 80a0036:	2100      	movs	r1, #0
 80a0038:	1a12      	subs	r2, r2, r0
 80a003a:	f006 f8b2 	bl	80a61a2 <memset>
    return &link_heap_start;
}
 80a003e:	4806      	ldr	r0, [pc, #24]	; (80a0058 <module_user_pre_init+0x3c>)
 80a0040:	bd08      	pop	{r3, pc}
 80a0042:	bf00      	nop
 80a0044:	20000300 	.word	0x20000300
 80a0048:	080a6dd4 	.word	0x080a6dd4
 80a004c:	20000380 	.word	0x20000380
 80a0050:	20000380 	.word	0x20000380
 80a0054:	20000e94 	.word	0x20000e94
 80a0058:	20000e94 	.word	0x20000e94

080a005c <module_user_init>:
extern constructor_ptr_t link_constructors_location[];
extern constructor_ptr_t link_constructors_end;
#define link_constructors_size   ((unsigned long)&link_constructors_end  -  (unsigned long)&link_constructors_location )

void module_user_init()
{
 80a005c:	b570      	push	{r4, r5, r6, lr}
    module_user_init_hook();
 80a005e:	f004 fa07 	bl	80a4470 <module_user_init_hook>
 80a0062:	4b07      	ldr	r3, [pc, #28]	; (80a0080 <module_user_init+0x24>)
 80a0064:	4c07      	ldr	r4, [pc, #28]	; (80a0084 <module_user_init+0x28>)
 80a0066:	461e      	mov	r6, r3
 80a0068:	1ae4      	subs	r4, r4, r3
 80a006a:	08a4      	lsrs	r4, r4, #2

    // invoke constructors
    int ctor_num;
    for (ctor_num=0; ctor_num < link_constructors_size/sizeof(constructor_ptr_t); ctor_num++ )
 80a006c:	2500      	movs	r5, #0
 80a006e:	42a5      	cmp	r5, r4
 80a0070:	d004      	beq.n	80a007c <module_user_init+0x20>
    {
        link_constructors_location[ctor_num]();
 80a0072:	f856 3025 	ldr.w	r3, [r6, r5, lsl #2]
 80a0076:	4798      	blx	r3
{
    module_user_init_hook();

    // invoke constructors
    int ctor_num;
    for (ctor_num=0; ctor_num < link_constructors_size/sizeof(constructor_ptr_t); ctor_num++ )
 80a0078:	3501      	adds	r5, #1
 80a007a:	e7f8      	b.n	80a006e <module_user_init+0x12>
    {
        link_constructors_location[ctor_num]();
    }
}
 80a007c:	bd70      	pop	{r4, r5, r6, pc}
 80a007e:	bf00      	nop
 80a0080:	080a6d40 	.word	0x080a6d40
 80a0084:	080a6dc4 	.word	0x080a6dc4

080a0088 <module_user_setup>:

/**
 * Export these functions with a fuller name so they don't clash with the setup/loop wrappers in the system module.
 */
void module_user_setup() {
    setup();
 80a0088:	f000 bf7c 	b.w	80a0f84 <setup>

080a008c <module_user_loop>:
}

void module_user_loop() {
 80a008c:	b508      	push	{r3, lr}
    loop();
 80a008e:	f001 f841 	bl	80a1114 <loop>
    _post_loop();
}
 80a0092:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    setup();
}

void module_user_loop() {
    loop();
    _post_loop();
 80a0096:	f004 b9ad 	b.w	80a43f4 <_post_loop>

080a009a <_Znwj>:
 80a009a:	f003 bcf5 	b.w	80a3a88 <malloc>

080a009e <_Znaj>:
	return malloc(size);
}

void *operator new[](size_t size)
{
	return malloc(size);
 80a009e:	f003 bcf3 	b.w	80a3a88 <malloc>

080a00a2 <_ZdlPv>:
 80a00a2:	f003 bcf9 	b.w	80a3a98 <free>

080a00a6 <_ZdaPv>:
	free(p);
}

void operator delete[](void *p)
{
	free(p);
 80a00a6:	f003 bcf7 	b.w	80a3a98 <free>

080a00aa <__cxa_guard_acquire>:

/* Provide default implemenation for __cxa_guard_acquire() and
 * __cxa_guard_release(). Note: these must be revisited if a multitasking
 * OS is ported to this platform. */
__extension__ typedef int __guard __attribute__((mode (__DI__)));
int __cxa_guard_acquire(__guard *g) {return !*(char *)(g);};
 80a00aa:	7800      	ldrb	r0, [r0, #0]
 80a00ac:	fab0 f080 	clz	r0, r0
 80a00b0:	0940      	lsrs	r0, r0, #5
 80a00b2:	4770      	bx	lr

080a00b4 <__cxa_guard_release>:
void __cxa_guard_release (__guard *g) {*(char *)g = 1;};
 80a00b4:	2301      	movs	r3, #1
 80a00b6:	7003      	strb	r3, [r0, #0]
 80a00b8:	4770      	bx	lr
	...

080a00bc <_Z10setupCylonv>:

extern CRGB leds[NUM_LEDS];
extern CRGB fg_color;
extern CRGB bg_color;

void setupCylon() { 
 80a00bc:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    }

    // allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
 80a00c0:	4f0d      	ldr	r7, [pc, #52]	; (80a00f8 <_Z10setupCylonv+0x3c>)
 80a00c2:	4e0e      	ldr	r6, [pc, #56]	; (80a00fc <_Z10setupCylonv+0x40>)
    for (int i = 0; i < kMatrixHeight; i++) {
 80a00c4:	2400      	movs	r4, #0
 80a00c6:	2500      	movs	r5, #0
        for (int j = 0; j < kMatrixWidth; j++) {
            leds[XY(i, j)] = bg_color;
 80a00c8:	fa5f f884 	uxtb.w	r8, r4
 80a00cc:	b2e9      	uxtb	r1, r5
 80a00ce:	4640      	mov	r0, r8
 80a00d0:	f002 f99e 	bl	80a2410 <_Z2XYhh>
 80a00d4:	7832      	ldrb	r2, [r6, #0]
 80a00d6:	eb00 0040 	add.w	r0, r0, r0, lsl #1
 80a00da:	543a      	strb	r2, [r7, r0]
        g = rhs.g;
 80a00dc:	7872      	ldrb	r2, [r6, #1]
    }

    // allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
 80a00de:	183b      	adds	r3, r7, r0
        g = rhs.g;
 80a00e0:	705a      	strb	r2, [r3, #1]
extern CRGB fg_color;
extern CRGB bg_color;

void setupCylon() { 
    for (int i = 0; i < kMatrixHeight; i++) {
        for (int j = 0; j < kMatrixWidth; j++) {
 80a00e2:	3501      	adds	r5, #1
        b = rhs.b;
 80a00e4:	78b2      	ldrb	r2, [r6, #2]
 80a00e6:	2d04      	cmp	r5, #4
 80a00e8:	709a      	strb	r2, [r3, #2]
 80a00ea:	d1ef      	bne.n	80a00cc <_Z10setupCylonv+0x10>
extern CRGB leds[NUM_LEDS];
extern CRGB fg_color;
extern CRGB bg_color;

void setupCylon() { 
    for (int i = 0; i < kMatrixHeight; i++) {
 80a00ec:	3401      	adds	r4, #1
 80a00ee:	2c1b      	cmp	r4, #27
 80a00f0:	d1e9      	bne.n	80a00c6 <_Z10setupCylonv+0xa>
        for (int j = 0; j < kMatrixWidth; j++) {
            leds[XY(i, j)] = bg_color;
        }
    }
}
 80a00f2:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80a00f6:	bf00      	nop
 80a00f8:	200003b4 	.word	0x200003b4
 80a00fc:	200004f8 	.word	0x200004f8

080a0100 <_Z7fadeallv>:

void fadeall() { for(int i = 0; i < NUM_LEDS; i++) { leds[i].nscale8(250); } }
 80a0100:	4b0c      	ldr	r3, [pc, #48]	; (80a0134 <_Z7fadeallv+0x34>)
//         THIS FUNCTION ALWAYS MODIFIES ITS ARGUMENTS IN PLACE

LIB8STATIC void nscale8x3( uint8_t& r, uint8_t& g, uint8_t& b, fract8 scale)
{
#if SCALE8_C == 1
    r = ((int)r * (int)(scale) ) >> 8;
 80a0102:	21fa      	movs	r1, #250	; 0xfa
 80a0104:	f503 70a2 	add.w	r0, r3, #324	; 0x144
 80a0108:	f813 2c01 	ldrb.w	r2, [r3, #-1]
 80a010c:	3303      	adds	r3, #3
 80a010e:	434a      	muls	r2, r1
 80a0110:	1212      	asrs	r2, r2, #8
 80a0112:	f803 2c04 	strb.w	r2, [r3, #-4]
    g = ((int)g * (int)(scale) ) >> 8;
 80a0116:	f813 2c03 	ldrb.w	r2, [r3, #-3]
 80a011a:	434a      	muls	r2, r1
 80a011c:	1212      	asrs	r2, r2, #8
 80a011e:	f803 2c03 	strb.w	r2, [r3, #-3]
    b = ((int)b * (int)(scale) ) >> 8;
 80a0122:	f813 2c02 	ldrb.w	r2, [r3, #-2]
 80a0126:	434a      	muls	r2, r1
 80a0128:	1212      	asrs	r2, r2, #8
 80a012a:	f803 2c02 	strb.w	r2, [r3, #-2]
 80a012e:	4283      	cmp	r3, r0
 80a0130:	d1ea      	bne.n	80a0108 <_Z7fadeallv+0x8>
 80a0132:	4770      	bx	lr
 80a0134:	200003b5 	.word	0x200003b5

080a0138 <_Z9loopCylonv>:

void loopCylon() { 
 80a0138:	e92d 47f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, r9, sl, lr}
	static uint8_t hue = 0;

	for(int i = 0; i < kMatrixHeight; i++) {
		// Set the i'th led to red 
		leds[i] = CHSV(hue++, 255, 255);
 80a013c:	f8df 8130 	ldr.w	r8, [pc, #304]	; 80a0270 <_Z9loopCylonv+0x138>
    }

    // allow assignment from HSV color
	inline CRGB& operator= (const CHSV& rhs) __attribute__((always_inline))
    {
        hsv2rgb_rainbow( rhs, *this);
 80a0140:	f8df a130 	ldr.w	sl, [pc, #304]	; 80a0274 <_Z9loopCylonv+0x13c>
    }
}

void fadeall() { for(int i = 0; i < NUM_LEDS; i++) { leds[i].nscale8(250); } }

void loopCylon() { 
 80a0144:	2500      	movs	r5, #0
	static uint8_t hue = 0;

	for(int i = 0; i < kMatrixHeight; i++) {
		// Set the i'th led to red 
		leds[i] = CHSV(hue++, 255, 255);
 80a0146:	f898 3000 	ldrb.w	r3, [r8]
    {
    }

    // allow construction from H, S, V
    inline CHSV( uint8_t ih, uint8_t is, uint8_t iv) __attribute__((always_inline))
        : h(ih), s(is), v(iv)
 80a014a:	24ff      	movs	r4, #255	; 0xff
 80a014c:	1c5a      	adds	r2, r3, #1
    }

    // allow assignment from HSV color
	inline CRGB& operator= (const CHSV& rhs) __attribute__((always_inline))
    {
        hsv2rgb_rainbow( rhs, *this);
 80a014e:	eb0a 0105 	add.w	r1, sl, r5
 80a0152:	a801      	add	r0, sp, #4
 80a0154:	f888 2000 	strb.w	r2, [r8]
    {
    }

    // allow construction from H, S, V
    inline CHSV( uint8_t ih, uint8_t is, uint8_t iv) __attribute__((always_inline))
        : h(ih), s(is), v(iv)
 80a0158:	f88d 3004 	strb.w	r3, [sp, #4]
 80a015c:	f88d 4005 	strb.w	r4, [sp, #5]
 80a0160:	f88d 4006 	strb.w	r4, [sp, #6]
    }

    // allow assignment from HSV color
	inline CRGB& operator= (const CHSV& rhs) __attribute__((always_inline))
    {
        hsv2rgb_rainbow( rhs, *this);
 80a0164:	f002 fa44 	bl	80a25f0 <_ZN9NSFastLED15hsv2rgb_rainbowERKNS_4CHSVERNS_4CRGBE>
    {
    }

    // allow construction from H, S, V
    inline CHSV( uint8_t ih, uint8_t is, uint8_t iv) __attribute__((always_inline))
        : h(ih), s(is), v(iv)
 80a0168:	f898 3000 	ldrb.w	r3, [r8]
    }

    // allow assignment from HSV color
	inline CRGB& operator= (const CHSV& rhs) __attribute__((always_inline))
    {
        hsv2rgb_rainbow( rhs, *this);
 80a016c:	f1c5 01a2 	rsb	r1, r5, #162	; 0xa2
 80a0170:	4451      	add	r1, sl
 80a0172:	a801      	add	r0, sp, #4
    {
    }

    // allow construction from H, S, V
    inline CHSV( uint8_t ih, uint8_t is, uint8_t iv) __attribute__((always_inline))
        : h(ih), s(is), v(iv)
 80a0174:	f88d 3004 	strb.w	r3, [sp, #4]
 80a0178:	f88d 4005 	strb.w	r4, [sp, #5]
 80a017c:	f88d 4006 	strb.w	r4, [sp, #6]
    }

    // allow assignment from HSV color
	inline CRGB& operator= (const CHSV& rhs) __attribute__((always_inline))
    {
        hsv2rgb_rainbow( rhs, *this);
 80a0180:	f002 fa36 	bl	80a25f0 <_ZN9NSFastLED15hsv2rgb_rainbowERKNS_4CHSVERNS_4CRGBE>
    {
    }

    // allow construction from H, S, V
    inline CHSV( uint8_t ih, uint8_t is, uint8_t iv) __attribute__((always_inline))
        : h(ih), s(is), v(iv)
 80a0184:	f898 3000 	ldrb.w	r3, [r8]
    }

    // allow assignment from HSV color
	inline CRGB& operator= (const CHSV& rhs) __attribute__((always_inline))
    {
        hsv2rgb_rainbow( rhs, *this);
 80a0188:	f105 01a2 	add.w	r1, r5, #162	; 0xa2
 80a018c:	4451      	add	r1, sl
 80a018e:	a801      	add	r0, sp, #4
    {
    }

    // allow construction from H, S, V
    inline CHSV( uint8_t ih, uint8_t is, uint8_t iv) __attribute__((always_inline))
        : h(ih), s(is), v(iv)
 80a0190:	f88d 3004 	strb.w	r3, [sp, #4]
	/// Update all our controllers with the current led colors, using the passed in brightness
	/// @param scale temporarily override the scale
	void show(uint8_t scale);

	/// Update all our controllers with the current led colors
	void show() { show(m_Scale); }
 80a0194:	4e35      	ldr	r6, [pc, #212]	; (80a026c <_Z9loopCylonv+0x134>)
 80a0196:	f88d 4005 	strb.w	r4, [sp, #5]
 80a019a:	f88d 4006 	strb.w	r4, [sp, #6]
    }

    // allow assignment from HSV color
	inline CRGB& operator= (const CHSV& rhs) __attribute__((always_inline))
    {
        hsv2rgb_rainbow( rhs, *this);
 80a019e:	f002 fa27 	bl	80a25f0 <_ZN9NSFastLED15hsv2rgb_rainbowERKNS_4CHSVERNS_4CRGBE>
    {
    }

    // allow construction from H, S, V
    inline CHSV( uint8_t ih, uint8_t is, uint8_t iv) __attribute__((always_inline))
        : h(ih), s(is), v(iv)
 80a01a2:	f898 3000 	ldrb.w	r3, [r8]
    }

    // allow assignment from HSV color
	inline CRGB& operator= (const CHSV& rhs) __attribute__((always_inline))
    {
        hsv2rgb_rainbow( rhs, *this);
 80a01a6:	f5c5 71a2 	rsb	r1, r5, #324	; 0x144
 80a01aa:	4451      	add	r1, sl
 80a01ac:	a801      	add	r0, sp, #4
    {
    }

    // allow construction from H, S, V
    inline CHSV( uint8_t ih, uint8_t is, uint8_t iv) __attribute__((always_inline))
        : h(ih), s(is), v(iv)
 80a01ae:	f88d 3004 	strb.w	r3, [sp, #4]
 80a01b2:	f88d 4005 	strb.w	r4, [sp, #5]
 80a01b6:	f88d 4006 	strb.w	r4, [sp, #6]
    }

    // allow assignment from HSV color
	inline CRGB& operator= (const CHSV& rhs) __attribute__((always_inline))
    {
        hsv2rgb_rainbow( rhs, *this);
 80a01ba:	f002 fa19 	bl	80a25f0 <_ZN9NSFastLED15hsv2rgb_rainbowERKNS_4CHSVERNS_4CRGBE>
 80a01be:	7831      	ldrb	r1, [r6, #0]
 80a01c0:	4630      	mov	r0, r6
 80a01c2:	f002 fd93 	bl	80a2cec <_ZN9NSFastLED8CFastLED4showEh>
 80a01c6:	3503      	adds	r5, #3
                leds[4*kMatrixHeight-i] = CHSV(hue, 255, 255);
		// Show the leds
		FastLED.show(); 
		// now that we've shown the leds, reset the i'th led to black
		// leds[i] = CRGB::Black;
		fadeall();
 80a01c8:	f7ff ff9a 	bl	80a0100 <_Z7fadeallv>
		// Wait a little bit before we loop around and do it again
		delay(100);
 80a01cc:	2064      	movs	r0, #100	; 0x64
 80a01ce:	f004 f8db 	bl	80a4388 <delay>
void fadeall() { for(int i = 0; i < NUM_LEDS; i++) { leds[i].nscale8(250); } }

void loopCylon() { 
	static uint8_t hue = 0;

	for(int i = 0; i < kMatrixHeight; i++) {
 80a01d2:	2d51      	cmp	r5, #81	; 0x51
 80a01d4:	4f26      	ldr	r7, [pc, #152]	; (80a0270 <_Z9loopCylonv+0x138>)
 80a01d6:	f8df 909c 	ldr.w	r9, [pc, #156]	; 80a0274 <_Z9loopCylonv+0x13c>
 80a01da:	d1b4      	bne.n	80a0146 <_Z9loopCylonv+0xe>
 80a01dc:	2500      	movs	r5, #0
	}

	// Now go in the other direction.  
	for(int i = (kMatrixHeight)-1; i >= 0; i--) {
		// Set the i'th led to red 
		leds[i] = CHSV(hue++, 255, 255);
 80a01de:	783b      	ldrb	r3, [r7, #0]
 80a01e0:	f105 014e 	add.w	r1, r5, #78	; 0x4e
 80a01e4:	1c5a      	adds	r2, r3, #1
 80a01e6:	4449      	add	r1, r9
 80a01e8:	a801      	add	r0, sp, #4
 80a01ea:	703a      	strb	r2, [r7, #0]
    {
    }

    // allow construction from H, S, V
    inline CHSV( uint8_t ih, uint8_t is, uint8_t iv) __attribute__((always_inline))
        : h(ih), s(is), v(iv)
 80a01ec:	f88d 3004 	strb.w	r3, [sp, #4]
 80a01f0:	f88d 4005 	strb.w	r4, [sp, #5]
 80a01f4:	f88d 4006 	strb.w	r4, [sp, #6]
    }

    // allow assignment from HSV color
	inline CRGB& operator= (const CHSV& rhs) __attribute__((always_inline))
    {
        hsv2rgb_rainbow( rhs, *this);
 80a01f8:	f002 f9fa 	bl	80a25f0 <_ZN9NSFastLED15hsv2rgb_rainbowERKNS_4CHSVERNS_4CRGBE>
    {
    }

    // allow construction from H, S, V
    inline CHSV( uint8_t ih, uint8_t is, uint8_t iv) __attribute__((always_inline))
        : h(ih), s(is), v(iv)
 80a01fc:	783b      	ldrb	r3, [r7, #0]
    }

    // allow assignment from HSV color
	inline CRGB& operator= (const CHSV& rhs) __attribute__((always_inline))
    {
        hsv2rgb_rainbow( rhs, *this);
 80a01fe:	f1c5 0154 	rsb	r1, r5, #84	; 0x54
 80a0202:	4449      	add	r1, r9
 80a0204:	a801      	add	r0, sp, #4
    {
    }

    // allow construction from H, S, V
    inline CHSV( uint8_t ih, uint8_t is, uint8_t iv) __attribute__((always_inline))
        : h(ih), s(is), v(iv)
 80a0206:	f88d 3004 	strb.w	r3, [sp, #4]
 80a020a:	f88d 4005 	strb.w	r4, [sp, #5]
 80a020e:	f88d 4006 	strb.w	r4, [sp, #6]
    }

    // allow assignment from HSV color
	inline CRGB& operator= (const CHSV& rhs) __attribute__((always_inline))
    {
        hsv2rgb_rainbow( rhs, *this);
 80a0212:	f002 f9ed 	bl	80a25f0 <_ZN9NSFastLED15hsv2rgb_rainbowERKNS_4CHSVERNS_4CRGBE>
    {
    }

    // allow construction from H, S, V
    inline CHSV( uint8_t ih, uint8_t is, uint8_t iv) __attribute__((always_inline))
        : h(ih), s(is), v(iv)
 80a0216:	783b      	ldrb	r3, [r7, #0]
    }

    // allow assignment from HSV color
	inline CRGB& operator= (const CHSV& rhs) __attribute__((always_inline))
    {
        hsv2rgb_rainbow( rhs, *this);
 80a0218:	f105 01f0 	add.w	r1, r5, #240	; 0xf0
 80a021c:	4449      	add	r1, r9
 80a021e:	a801      	add	r0, sp, #4
    {
    }

    // allow construction from H, S, V
    inline CHSV( uint8_t ih, uint8_t is, uint8_t iv) __attribute__((always_inline))
        : h(ih), s(is), v(iv)
 80a0220:	f88d 3004 	strb.w	r3, [sp, #4]
 80a0224:	f88d 4005 	strb.w	r4, [sp, #5]
 80a0228:	f88d 4006 	strb.w	r4, [sp, #6]
    }

    // allow assignment from HSV color
	inline CRGB& operator= (const CHSV& rhs) __attribute__((always_inline))
    {
        hsv2rgb_rainbow( rhs, *this);
 80a022c:	f002 f9e0 	bl	80a25f0 <_ZN9NSFastLED15hsv2rgb_rainbowERKNS_4CHSVERNS_4CRGBE>
    {
    }

    // allow construction from H, S, V
    inline CHSV( uint8_t ih, uint8_t is, uint8_t iv) __attribute__((always_inline))
        : h(ih), s(is), v(iv)
 80a0230:	783b      	ldrb	r3, [r7, #0]
    }

    // allow assignment from HSV color
	inline CRGB& operator= (const CHSV& rhs) __attribute__((always_inline))
    {
        hsv2rgb_rainbow( rhs, *this);
 80a0232:	f1c5 01f6 	rsb	r1, r5, #246	; 0xf6
 80a0236:	4449      	add	r1, r9
 80a0238:	a801      	add	r0, sp, #4
    {
    }

    // allow construction from H, S, V
    inline CHSV( uint8_t ih, uint8_t is, uint8_t iv) __attribute__((always_inline))
        : h(ih), s(is), v(iv)
 80a023a:	f88d 3004 	strb.w	r3, [sp, #4]
 80a023e:	f88d 4005 	strb.w	r4, [sp, #5]
 80a0242:	f88d 4006 	strb.w	r4, [sp, #6]
    }

    // allow assignment from HSV color
	inline CRGB& operator= (const CHSV& rhs) __attribute__((always_inline))
    {
        hsv2rgb_rainbow( rhs, *this);
 80a0246:	f002 f9d3 	bl	80a25f0 <_ZN9NSFastLED15hsv2rgb_rainbowERKNS_4CHSVERNS_4CRGBE>
 80a024a:	7831      	ldrb	r1, [r6, #0]
 80a024c:	4807      	ldr	r0, [pc, #28]	; (80a026c <_Z9loopCylonv+0x134>)
 80a024e:	f002 fd4d 	bl	80a2cec <_ZN9NSFastLED8CFastLED4showEh>
 80a0252:	3d03      	subs	r5, #3
                leds[4*kMatrixHeight-i] = CHSV(hue, 255, 255);
		// Show the leds
		FastLED.show();
		// now that we've shown the leds, reset the i'th led to black
		// leds[i] = CRGB::Black;
		fadeall();
 80a0254:	f7ff ff54 	bl	80a0100 <_Z7fadeallv>
		// Wait a little bit before we loop around and do it again
		delay(100);
 80a0258:	2064      	movs	r0, #100	; 0x64
 80a025a:	f004 f895 	bl	80a4388 <delay>
		// Wait a little bit before we loop around and do it again
		delay(100);
	}

	// Now go in the other direction.  
	for(int i = (kMatrixHeight)-1; i >= 0; i--) {
 80a025e:	f115 0f51 	cmn.w	r5, #81	; 0x51
 80a0262:	d1bc      	bne.n	80a01de <_Z9loopCylonv+0xa6>
		// leds[i] = CRGB::Black;
		fadeall();
		// Wait a little bit before we loop around and do it again
		delay(100);
	}
}
 80a0264:	b002      	add	sp, #8
 80a0266:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80a026a:	bf00      	nop
 80a026c:	200008ec 	.word	0x200008ec
 80a0270:	20000384 	.word	0x20000384
 80a0274:	200003b4 	.word	0x200003b4

080a0278 <_GLOBAL__sub_I__Z10setupCylonv>:
inline int32_t pinReadFast(pin_t _pin)
{
	return ((PIN_MAP[_pin].gpio_peripheral->IDR & PIN_MAP[_pin].gpio_pin) == 0 ? LOW : HIGH);
}
#elif defined(STM32F2XX)
static STM32_Pin_Info* PIN_MAP = HAL_Pin_Map();
 80a0278:	f003 bb72 	b.w	80a3960 <HAL_Pin_Map>

080a027c <_Z19loopHorizontalSplitv>:
        }
    }
}

void loopHorizontalSplit()
{
 80a027c:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    }

    // allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
 80a0280:	f8df 806c 	ldr.w	r8, [pc, #108]	; 80a02f0 <_Z19loopHorizontalSplitv+0x74>
 80a0284:	4e19      	ldr	r6, [pc, #100]	; (80a02ec <_Z19loopHorizontalSplitv+0x70>)
    uint16_t i = 0;
    uint16_t j = 0;

    for (i = 0; i < round(2*kMatrixHeight/3); i++) {
 80a0286:	2400      	movs	r4, #0
 80a0288:	2500      	movs	r5, #0
        for (j = 0; j < kMatrixWidth; j++) {
            leds[XY(i, j)] = bg_color;
 80a028a:	b2e9      	uxtb	r1, r5
 80a028c:	b2e0      	uxtb	r0, r4
 80a028e:	f002 f8bf 	bl	80a2410 <_Z2XYhh>
 80a0292:	7832      	ldrb	r2, [r6, #0]
 80a0294:	eb00 0040 	add.w	r0, r0, r0, lsl #1
 80a0298:	f808 2000 	strb.w	r2, [r8, r0]
        g = rhs.g;
 80a029c:	7872      	ldrb	r2, [r6, #1]
    }

    // allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
 80a029e:	eb08 0300 	add.w	r3, r8, r0
        g = rhs.g;
 80a02a2:	705a      	strb	r2, [r3, #1]
 80a02a4:	3501      	adds	r5, #1
        b = rhs.b;
 80a02a6:	78b2      	ldrb	r2, [r6, #2]
{
    uint16_t i = 0;
    uint16_t j = 0;

    for (i = 0; i < round(2*kMatrixHeight/3); i++) {
        for (j = 0; j < kMatrixWidth; j++) {
 80a02a8:	2d04      	cmp	r5, #4
 80a02aa:	709a      	strb	r2, [r3, #2]
 80a02ac:	4f10      	ldr	r7, [pc, #64]	; (80a02f0 <_Z19loopHorizontalSplitv+0x74>)
 80a02ae:	d1ec      	bne.n	80a028a <_Z19loopHorizontalSplitv+0xe>
void loopHorizontalSplit()
{
    uint16_t i = 0;
    uint16_t j = 0;

    for (i = 0; i < round(2*kMatrixHeight/3); i++) {
 80a02b0:	3401      	adds	r4, #1
 80a02b2:	b2a4      	uxth	r4, r4
 80a02b4:	2c12      	cmp	r4, #18
 80a02b6:	d1e7      	bne.n	80a0288 <_Z19loopHorizontalSplitv+0xc>
    }

    // allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
 80a02b8:	4e0e      	ldr	r6, [pc, #56]	; (80a02f4 <_Z19loopHorizontalSplitv+0x78>)
 80a02ba:	2500      	movs	r5, #0
            leds[XY(i, j)] = bg_color;
        }
    }
    for (i = round(2*kMatrixHeight/3); i < kMatrixHeight; i++) {
        for (j = 0; j < kMatrixWidth; j++) {
            leds[XY(i, j)] = fg_color;
 80a02bc:	fa5f f884 	uxtb.w	r8, r4
 80a02c0:	b2e9      	uxtb	r1, r5
 80a02c2:	4640      	mov	r0, r8
 80a02c4:	f002 f8a4 	bl	80a2410 <_Z2XYhh>
 80a02c8:	7832      	ldrb	r2, [r6, #0]
 80a02ca:	eb00 0040 	add.w	r0, r0, r0, lsl #1
 80a02ce:	543a      	strb	r2, [r7, r0]
        g = rhs.g;
 80a02d0:	7872      	ldrb	r2, [r6, #1]
    }

    // allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
 80a02d2:	183b      	adds	r3, r7, r0
        g = rhs.g;
 80a02d4:	705a      	strb	r2, [r3, #1]
 80a02d6:	3501      	adds	r5, #1
        b = rhs.b;
 80a02d8:	78b2      	ldrb	r2, [r6, #2]
        for (j = 0; j < kMatrixWidth; j++) {
            leds[XY(i, j)] = bg_color;
        }
    }
    for (i = round(2*kMatrixHeight/3); i < kMatrixHeight; i++) {
        for (j = 0; j < kMatrixWidth; j++) {
 80a02da:	2d04      	cmp	r5, #4
 80a02dc:	709a      	strb	r2, [r3, #2]
 80a02de:	d1ef      	bne.n	80a02c0 <_Z19loopHorizontalSplitv+0x44>
    for (i = 0; i < round(2*kMatrixHeight/3); i++) {
        for (j = 0; j < kMatrixWidth; j++) {
            leds[XY(i, j)] = bg_color;
        }
    }
    for (i = round(2*kMatrixHeight/3); i < kMatrixHeight; i++) {
 80a02e0:	3401      	adds	r4, #1
 80a02e2:	b2a4      	uxth	r4, r4
 80a02e4:	2c1b      	cmp	r4, #27
 80a02e6:	d1e8      	bne.n	80a02ba <_Z19loopHorizontalSplitv+0x3e>
        for (j = 0; j < kMatrixWidth; j++) {
            leds[XY(i, j)] = fg_color;
        }
    }
}
 80a02e8:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80a02ec:	200004f8 	.word	0x200004f8
 80a02f0:	200003b4 	.word	0x200003b4
 80a02f4:	20000590 	.word	0x20000590

080a02f8 <_Z20setupHorizontalSplitv>:
 80a02f8:	f7ff bfc0 	b.w	80a027c <_Z19loopHorizontalSplitv>

080a02fc <_GLOBAL__sub_I__Z20setupHorizontalSplitv>:
 80a02fc:	f003 bb30 	b.w	80a3960 <HAL_Pin_Map>

080a0300 <_Z17setupRainbowCyclev>:
extern CRGB bg_color;

uint16_t j = 0;

void setupRainbowCycle()
{
 80a0300:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    }

    // allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
 80a0304:	4f0d      	ldr	r7, [pc, #52]	; (80a033c <_Z17setupRainbowCyclev+0x3c>)
 80a0306:	4e0e      	ldr	r6, [pc, #56]	; (80a0340 <_Z17setupRainbowCyclev+0x40>)
    for (int i = 0; i < kMatrixHeight; i++) {
 80a0308:	2400      	movs	r4, #0
 80a030a:	2500      	movs	r5, #0
        for (int j = 0; j < kMatrixWidth; j++) {
            leds[XY(i, j)] = bg_color;
 80a030c:	fa5f f884 	uxtb.w	r8, r4
 80a0310:	b2e9      	uxtb	r1, r5
 80a0312:	4640      	mov	r0, r8
 80a0314:	f002 f87c 	bl	80a2410 <_Z2XYhh>
 80a0318:	7832      	ldrb	r2, [r6, #0]
 80a031a:	eb00 0040 	add.w	r0, r0, r0, lsl #1
 80a031e:	543a      	strb	r2, [r7, r0]
        g = rhs.g;
 80a0320:	7872      	ldrb	r2, [r6, #1]
    }

    // allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
 80a0322:	183b      	adds	r3, r7, r0
        g = rhs.g;
 80a0324:	705a      	strb	r2, [r3, #1]
uint16_t j = 0;

void setupRainbowCycle()
{
    for (int i = 0; i < kMatrixHeight; i++) {
        for (int j = 0; j < kMatrixWidth; j++) {
 80a0326:	3501      	adds	r5, #1
        b = rhs.b;
 80a0328:	78b2      	ldrb	r2, [r6, #2]
 80a032a:	2d04      	cmp	r5, #4
 80a032c:	709a      	strb	r2, [r3, #2]
 80a032e:	d1ef      	bne.n	80a0310 <_Z17setupRainbowCyclev+0x10>

uint16_t j = 0;

void setupRainbowCycle()
{
    for (int i = 0; i < kMatrixHeight; i++) {
 80a0330:	3401      	adds	r4, #1
 80a0332:	2c1b      	cmp	r4, #27
 80a0334:	d1e9      	bne.n	80a030a <_Z17setupRainbowCyclev+0xa>
        for (int j = 0; j < kMatrixWidth; j++) {
            leds[XY(i, j)] = bg_color;
        }
    }
}
 80a0336:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80a033a:	bf00      	nop
 80a033c:	200003b4 	.word	0x200003b4
 80a0340:	200004f8 	.word	0x200004f8

080a0344 <_Z5Wheelh>:

// Input a value 0 to 255 to get a color value.
// The colours are a transition r - g - b - back to r.
uint32_t Wheel(byte WheelPos)
{
    WheelPos = 255 - WheelPos;
 80a0344:	43c0      	mvns	r0, r0
 80a0346:	b2c3      	uxtb	r3, r0
    if (WheelPos < 85) {
 80a0348:	2b54      	cmp	r3, #84	; 0x54
 80a034a:	d807      	bhi.n	80a035c <_Z5Wheelh+0x18>
        return ((uint32_t)(255 - WheelPos * 3) << 16) | ((uint32_t)0 <<  8) | (WheelPos * 3);
 80a034c:	eba3 0083 	sub.w	r0, r3, r3, lsl #2
 80a0350:	30ff      	adds	r0, #255	; 0xff
 80a0352:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 80a0356:	ea43 4000 	orr.w	r0, r3, r0, lsl #16
 80a035a:	4770      	bx	lr
    }
    if (WheelPos < 170) {
 80a035c:	2ba9      	cmp	r3, #169	; 0xa9
 80a035e:	d807      	bhi.n	80a0370 <_Z5Wheelh+0x2c>
        WheelPos -= 85;
        return ((uint32_t)0 << 16) | ((uint32_t)(WheelPos * 3) <<  8) | (255 - WheelPos * 3);
 80a0360:	3b55      	subs	r3, #85	; 0x55
 80a0362:	b2db      	uxtb	r3, r3
 80a0364:	eb03 0043 	add.w	r0, r3, r3, lsl #1
 80a0368:	eba3 0383 	sub.w	r3, r3, r3, lsl #2
 80a036c:	33ff      	adds	r3, #255	; 0xff
 80a036e:	e007      	b.n	80a0380 <_Z5Wheelh+0x3c>
    }
    WheelPos -= 170;
    return ((uint32_t)(WheelPos * 3) << 16) | ((uint32_t)(255 - WheelPos * 3) <<  8) | 0;
 80a0370:	3356      	adds	r3, #86	; 0x56
 80a0372:	b2db      	uxtb	r3, r3
 80a0374:	eba3 0083 	sub.w	r0, r3, r3, lsl #2
 80a0378:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 80a037c:	30ff      	adds	r0, #255	; 0xff
 80a037e:	041b      	lsls	r3, r3, #16
 80a0380:	ea43 2000 	orr.w	r0, r3, r0, lsl #8
}
 80a0384:	4770      	bx	lr
	...

080a0388 <_Z16loopRainbowCyclev>:

void loopRainbowCycle()
{
 80a0388:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    uint16_t i = 0;
    uint32_t t = 0;
    
    j = j + 1 % 768;
 80a038a:	4b1c      	ldr	r3, [pc, #112]	; (80a03fc <_Z16loopRainbowCyclev+0x74>)
 80a038c:	4a1c      	ldr	r2, [pc, #112]	; (80a0400 <_Z16loopRainbowCyclev+0x78>)
 80a038e:	881c      	ldrh	r4, [r3, #0]
 80a0390:	1e51      	subs	r1, r2, #1
 80a0392:	3401      	adds	r4, #1
 80a0394:	b2a4      	uxth	r4, r4
 80a0396:	801c      	strh	r4, [r3, #0]
 80a0398:	2500      	movs	r5, #0

    for (i = 0; i < kMatrixHeight; i++) {
        t = Wheel(((i * 256 / kMatrixHeight) + j) & 255);
 80a039a:	271b      	movs	r7, #27
 80a039c:	fb95 f0f7 	sdiv	r0, r5, r7
 80a03a0:	4420      	add	r0, r4
 80a03a2:	b2c0      	uxtb	r0, r0
 80a03a4:	f7ff ffce 	bl	80a0344 <_Z5Wheelh>
 80a03a8:	f505 7580 	add.w	r5, r5, #256	; 0x100
    }

    // allow assignment from 32-bit (really 24-bit) 0xRRGGBB color code
	inline CRGB& operator= (const uint32_t colorcode) __attribute__((always_inline))
    {
        r = (colorcode >> 16) & 0xFF;
 80a03ac:	f3c0 4607 	ubfx	r6, r0, #16, #8
        g = (colorcode >>  8) & 0xFF;
 80a03b0:	f3c0 2307 	ubfx	r3, r0, #8, #8
    uint16_t i = 0;
    uint32_t t = 0;
    
    j = j + 1 % 768;

    for (i = 0; i < kMatrixHeight; i++) {
 80a03b4:	f5b5 5fd8 	cmp.w	r5, #6912	; 0x1b00
        b = (colorcode >>  0) & 0xFF;
 80a03b8:	b2c0      	uxtb	r0, r0
    }

    // allow assignment from 32-bit (really 24-bit) 0xRRGGBB color code
	inline CRGB& operator= (const uint32_t colorcode) __attribute__((always_inline))
    {
        r = (colorcode >> 16) & 0xFF;
 80a03ba:	f802 6c01 	strb.w	r6, [r2, #-1]
        g = (colorcode >>  8) & 0xFF;
 80a03be:	7013      	strb	r3, [r2, #0]
        b = (colorcode >>  0) & 0xFF;
 80a03c0:	7050      	strb	r0, [r2, #1]
 80a03c2:	f1a1 0103 	sub.w	r1, r1, #3
    }

    // allow assignment from 32-bit (really 24-bit) 0xRRGGBB color code
	inline CRGB& operator= (const uint32_t colorcode) __attribute__((always_inline))
    {
        r = (colorcode >> 16) & 0xFF;
 80a03c6:	f881 60a5 	strb.w	r6, [r1, #165]	; 0xa5
        g = (colorcode >>  8) & 0xFF;
 80a03ca:	f881 30a6 	strb.w	r3, [r1, #166]	; 0xa6
        b = (colorcode >>  0) & 0xFF;
 80a03ce:	f881 00a7 	strb.w	r0, [r1, #167]	; 0xa7
 80a03d2:	f102 0203 	add.w	r2, r2, #3
    }

    // allow assignment from 32-bit (really 24-bit) 0xRRGGBB color code
	inline CRGB& operator= (const uint32_t colorcode) __attribute__((always_inline))
    {
        r = (colorcode >> 16) & 0xFF;
 80a03d6:	f882 609e 	strb.w	r6, [r2, #158]	; 0x9e
        g = (colorcode >>  8) & 0xFF;
 80a03da:	f882 309f 	strb.w	r3, [r2, #159]	; 0x9f
        b = (colorcode >>  0) & 0xFF;
 80a03de:	f882 00a0 	strb.w	r0, [r2, #160]	; 0xa0
    }

    // allow assignment from 32-bit (really 24-bit) 0xRRGGBB color code
	inline CRGB& operator= (const uint32_t colorcode) __attribute__((always_inline))
    {
        r = (colorcode >> 16) & 0xFF;
 80a03e2:	f881 6147 	strb.w	r6, [r1, #327]	; 0x147
        g = (colorcode >>  8) & 0xFF;
 80a03e6:	f881 3148 	strb.w	r3, [r1, #328]	; 0x148
        b = (colorcode >>  0) & 0xFF;
 80a03ea:	f881 0149 	strb.w	r0, [r1, #329]	; 0x149
 80a03ee:	d1d5      	bne.n	80a039c <_Z16loopRainbowCyclev+0x14>
        leds[2*kMatrixHeight-i] = t;
        leds[i+2*kMatrixHeight] = t;
        leds[4*kMatrixHeight-i] = t;
    }

    delay(20);
 80a03f0:	2014      	movs	r0, #20
 80a03f2:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
        leds[2*kMatrixHeight-i] = t;
        leds[i+2*kMatrixHeight] = t;
        leds[4*kMatrixHeight-i] = t;
    }

    delay(20);
 80a03f6:	f003 bfc7 	b.w	80a4388 <delay>
 80a03fa:	bf00      	nop
 80a03fc:	20000386 	.word	0x20000386
 80a0400:	200003b5 	.word	0x200003b5

080a0404 <_GLOBAL__sub_I_j>:
 80a0404:	f003 baac 	b.w	80a3960 <HAL_Pin_Map>

080a0408 <_ZNSt17_Function_handlerIFvvEPS0_E9_M_invokeERKSt9_Any_data>:

     public:
      static void
      _M_invoke(const _Any_data& __functor, _ArgTypes&&... __args)
      {
	(*_Base::_M_get_pointer(__functor))(
 80a0408:	6803      	ldr	r3, [r0, #0]
 80a040a:	4718      	bx	r3

080a040c <_ZNSt14_Function_base13_Base_managerIPFvvEE10_M_managerERSt9_Any_dataRKS4_St18_Manager_operation>:
      public:
	static bool
	_M_manager(_Any_data& __dest, const _Any_data& __source,
		   _Manager_operation __op)
	{
	  switch (__op)
 80a040c:	2a01      	cmp	r2, #1
 80a040e:	d002      	beq.n	80a0416 <_ZNSt14_Function_base13_Base_managerIPFvvEE10_M_managerERSt9_Any_dataRKS4_St18_Manager_operation+0xa>
 80a0410:	2a02      	cmp	r2, #2
 80a0412:	d002      	beq.n	80a041a <_ZNSt14_Function_base13_Base_managerIPFvvEE10_M_managerERSt9_Any_dataRKS4_St18_Manager_operation+0xe>
 80a0414:	e004      	b.n	80a0420 <_ZNSt14_Function_base13_Base_managerIPFvvEE10_M_managerERSt9_Any_dataRKS4_St18_Manager_operation+0x14>
	    case __get_type_info:
	      __dest._M_access<const type_info*>() = &typeid(_Functor);
	      break;
#endif
	    case __get_functor_ptr:
	      __dest._M_access<_Functor*>() = _M_get_pointer(__source);
 80a0416:	6001      	str	r1, [r0, #0]
	      break;
 80a0418:	e002      	b.n	80a0420 <_ZNSt14_Function_base13_Base_managerIPFvvEE10_M_managerERSt9_Any_dataRKS4_St18_Manager_operation+0x14>
	// Clone a location-invariant function object that fits within
	// an _Any_data structure.
	static void
	_M_clone(_Any_data& __dest, const _Any_data& __source, true_type)
	{
	  new (__dest._M_access()) _Functor(__source._M_access<_Functor>());
 80a041a:	680b      	ldr	r3, [r1, #0]
 80a041c:	b100      	cbz	r0, 80a0420 <_ZNSt14_Function_base13_Base_managerIPFvvEE10_M_managerERSt9_Any_dataRKS4_St18_Manager_operation+0x14>
 80a041e:	6003      	str	r3, [r0, #0]
	    case __destroy_functor:
	      _M_destroy(__dest, _Local_storage());
	      break;
	    }
	  return false;
	}
 80a0420:	2000      	movs	r0, #0
 80a0422:	4770      	bx	lr

080a0424 <_ZN9NSFastLED19ClocklessControllerILi4ELi30ELi75ELi45ELNS_6EOrderE66ELi0ELb0ELi50EE9clearLedsEi>:
    FastPin<DATA_PIN>::setOutput();
    mPinMask = FastPin<DATA_PIN>::mask();
    mPort = FastPin<DATA_PIN>::port();
  }

  virtual void clearLeds(int nLeds) {
 80a0424:	b513      	push	{r0, r1, r4, lr}
    showColor(CRGB(0, 0, 0), nLeds, 0);
 80a0426:	6803      	ldr	r3, [r0, #0]
 80a0428:	460a      	mov	r2, r1
 80a042a:	681c      	ldr	r4, [r3, #0]
    {
    }

    // allow construction from R, G, B
    inline CRGB( uint8_t ir, uint8_t ig, uint8_t ib)  __attribute__((always_inline))
        : r(ir), g(ig), b(ib)
 80a042c:	2300      	movs	r3, #0
 80a042e:	f88d 3000 	strb.w	r3, [sp]
 80a0432:	f88d 3001 	strb.w	r3, [sp, #1]
 80a0436:	f88d 3002 	strb.w	r3, [sp, #2]
    {
    }

    // allow construction from 32-bit (really 24-bit) bit 0xRRGGBB color code
    inline CRGB( uint32_t colorcode)  __attribute__((always_inline))
    : r((colorcode >> 16) & 0xFF), g((colorcode >> 8) & 0xFF), b((colorcode >> 0) & 0xFF)
 80a043a:	f88d 3004 	strb.w	r3, [sp, #4]
 80a043e:	f88d 3005 	strb.w	r3, [sp, #5]
 80a0442:	f88d 3006 	strb.w	r3, [sp, #6]
 80a0446:	4669      	mov	r1, sp
 80a0448:	ab01      	add	r3, sp, #4
 80a044a:	47a0      	blx	r4
  }
 80a044c:	b002      	add	sp, #8
 80a044e:	bd10      	pop	{r4, pc}

080a0450 <_ZN9NSFastLED19ClocklessControllerILi4ELi30ELi75ELi45ELNS_6EOrderE66ELi0ELb0ELi50EE4initEv>:

  data_t mPinMask;
  data_ptr_t mPort;
  CMinWait<WAIT_TIME> mWait;
public:
  virtual void init() {
 80a0450:	b510      	push	{r4, lr}
 80a0452:	4604      	mov	r4, r0
    }
  }
  inline static void setInput() { /* TODO */ } // TODO: preform MUX config { _PDDR::r() &= ~_MASK; }
  #endif

  inline static void setOutput() { pinMode(PIN, OUTPUT); } // TODO: perform MUX config { _PDDR::r() |= _MASK; }
 80a0454:	2101      	movs	r1, #1
 80a0456:	2004      	movs	r0, #4
 80a0458:	f004 fe6e 	bl	80a5138 <pinMode>
    FastPin<DATA_PIN>::setOutput();
    mPinMask = FastPin<DATA_PIN>::mask();
 80a045c:	2308      	movs	r3, #8
 80a045e:	61a3      	str	r3, [r4, #24]
    mPort = FastPin<DATA_PIN>::port();
 80a0460:	4b01      	ldr	r3, [pc, #4]	; (80a0468 <_ZN9NSFastLED19ClocklessControllerILi4ELi30ELi75ELi45ELNS_6EOrderE66ELi0ELb0ELi50EE4initEv+0x18>)
 80a0462:	61e3      	str	r3, [r4, #28]
 80a0464:	bd10      	pop	{r4, pc}
 80a0466:	bf00      	nop
 80a0468:	40020414 	.word	0x40020414

080a046c <_ZN5Timer12invoke_timerEPv>:
private:
	volatile bool running;
    os_timer_t handle;
    timer_callback_fn callback;

    static void invoke_timer(os_timer_t timer)
 80a046c:	b507      	push	{r0, r1, r2, lr}
    {
        void* timer_id = NULL;
 80a046e:	2300      	movs	r3, #0
 80a0470:	a902      	add	r1, sp, #8
 80a0472:	f841 3d04 	str.w	r3, [r1, #-4]!
        if (!os_timer_get_id(timer, &timer_id)) {
 80a0476:	f003 f9e3 	bl	80a3840 <os_timer_get_id>
 80a047a:	b920      	cbnz	r0, 80a0486 <_ZN5Timer12invoke_timerEPv+0x1a>
            if (timer_id)
 80a047c:	9801      	ldr	r0, [sp, #4]
 80a047e:	b110      	cbz	r0, 80a0486 <_ZN5Timer12invoke_timerEPv+0x1a>
                ((Timer*)timer_id)->timeout();
 80a0480:	6803      	ldr	r3, [r0, #0]
 80a0482:	689b      	ldr	r3, [r3, #8]
 80a0484:	4798      	blx	r3
        }
    }
 80a0486:	b003      	add	sp, #12
 80a0488:	f85d fb04 	ldr.w	pc, [sp], #4

080a048c <_ZN11EEPROMClass4readEi.isra.8>:

    EERef( const int index )
        : index( index )                 {}

    //Access/read members.
    uint8_t operator*() const            { return HAL_EEPROM_Read(index); }
 80a048c:	f003 ba38 	b.w	80a3900 <HAL_EEPROM_Read>

080a0490 <_ZN11EEPROMClass5writeEih.isra.9>:
    operator const uint8_t() const       { return **this; }

    //Assignment/write members.
    EERef &operator=( const EERef &ref ) { return *this = *ref; }
    EERef &operator=( uint8_t in )       { return HAL_EEPROM_Write(index, in), *this;  }
 80a0490:	f003 ba3e 	b.w	80a3910 <HAL_EEPROM_Write>

080a0494 <_ZNSt14_Function_baseD1Ev>:
	}
      };

    _Function_base() : _M_manager(nullptr) { }

    ~_Function_base()
 80a0494:	b510      	push	{r4, lr}
    {
      if (_M_manager)
 80a0496:	6883      	ldr	r3, [r0, #8]
	}
      };

    _Function_base() : _M_manager(nullptr) { }

    ~_Function_base()
 80a0498:	4604      	mov	r4, r0
    {
      if (_M_manager)
 80a049a:	b113      	cbz	r3, 80a04a2 <_ZNSt14_Function_baseD1Ev+0xe>
	_M_manager(_M_functor, _M_functor, __destroy_functor);
 80a049c:	2203      	movs	r2, #3
 80a049e:	4601      	mov	r1, r0
 80a04a0:	4798      	blx	r3
    }
 80a04a2:	4620      	mov	r0, r4
 80a04a4:	bd10      	pop	{r4, pc}

080a04a6 <_ZNKSt14default_deleteIN6Thread4DataEEclEPS1_.isra.13>:
	       enable_if<is_convertible<_Up*, _Tp*>::value>::type>
        default_delete(const default_delete<_Up>&) noexcept { }

      /// Calls @c delete @p __ptr
      void
      operator()(_Tp* __ptr) const
 80a04a6:	b538      	push	{r3, r4, r5, lr}
      {
	static_assert(!is_void<_Tp>::value,
		      "can't delete pointer to incomplete type");
	static_assert(sizeof(_Tp)>0,
		      "can't delete pointer to incomplete type");
	delete __ptr;
 80a04a8:	4604      	mov	r4, r0
 80a04aa:	b160      	cbz	r0, 80a04c6 <_ZNKSt14default_deleteIN6Thread4DataEEclEPS1_.isra.13+0x20>

      /// Destructor, invokes the deleter if the stored pointer is not null.
      ~unique_ptr() noexcept
      {
	auto& __ptr = std::get<0>(_M_t);
	if (__ptr != nullptr)
 80a04ac:	6805      	ldr	r5, [r0, #0]
 80a04ae:	b12d      	cbz	r5, 80a04bc <_ZNKSt14default_deleteIN6Thread4DataEEclEPS1_.isra.13+0x16>
   *  @ingroup functors
   *
   *  Polymorphic function wrapper.
   */
  template<typename _Res, typename... _ArgTypes>
    class function<_Res(_ArgTypes...)>
 80a04b0:	4628      	mov	r0, r5
 80a04b2:	f7ff ffef 	bl	80a0494 <_ZNSt14_Function_baseD1Ev>
      {
	static_assert(!is_void<_Tp>::value,
		      "can't delete pointer to incomplete type");
	static_assert(sizeof(_Tp)>0,
		      "can't delete pointer to incomplete type");
	delete __ptr;
 80a04b6:	4628      	mov	r0, r5
 80a04b8:	f7ff fdf3 	bl	80a00a2 <_ZdlPv>
 80a04bc:	4620      	mov	r0, r4
      }
 80a04be:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
      {
	static_assert(!is_void<_Tp>::value,
		      "can't delete pointer to incomplete type");
	static_assert(sizeof(_Tp)>0,
		      "can't delete pointer to incomplete type");
	delete __ptr;
 80a04c2:	f7ff bdee 	b.w	80a00a2 <_ZdlPv>
 80a04c6:	bd38      	pop	{r3, r4, r5, pc}

080a04c8 <_ZN19ApplicationWatchdogD1Ev>:
#include "timer_hal.h"

#if PLATFORM_THREADING


class ApplicationWatchdog
 80a04c8:	b510      	push	{r4, lr}
      }

      /// Return the stored pointer.
      pointer
      get() const noexcept
      { return std::get<0>(_M_t); }
 80a04ca:	6943      	ldr	r3, [r0, #20]
 80a04cc:	4604      	mov	r4, r0
        dispose();
    }

    void dispose()
    {
        if (!isValid())
 80a04ce:	b1bb      	cbz	r3, 80a0500 <_ZN19ApplicationWatchdogD1Ev+0x38>
        return isCurrent();
    }

    bool isCurrent() const
    {
        return isValid() && os_thread_is_current(d_->handle);
 80a04d0:	6858      	ldr	r0, [r3, #4]
 80a04d2:	f003 f985 	bl	80a37e0 <os_thread_is_current>
 80a04d6:	b978      	cbnz	r0, 80a04f8 <_ZN19ApplicationWatchdogD1Ev+0x30>
 80a04d8:	6963      	ldr	r3, [r4, #20]

        // We shouldn't dispose of current thread
        if (isCurrent())
            return;

        if (!d_->exited) {
 80a04da:	7c5a      	ldrb	r2, [r3, #17]
 80a04dc:	b912      	cbnz	r2, 80a04e4 <_ZN19ApplicationWatchdogD1Ev+0x1c>
        d_.reset();
    }

    bool join()
    {
        return isValid() && os_thread_join(d_->handle)==0;
 80a04de:	6858      	ldr	r0, [r3, #4]
 80a04e0:	f003 f98e 	bl	80a3800 <os_thread_join>

        if (!d_->exited) {
            join();
        }

        os_thread_cleanup(d_->handle);
 80a04e4:	6963      	ldr	r3, [r4, #20]
 80a04e6:	6858      	ldr	r0, [r3, #4]
 80a04e8:	f003 f992 	bl	80a3810 <os_thread_cleanup>
#endif
    {
      // concept requirements
      __glibcxx_function_requires(_SGIAssignableConcept<_Tp>)

      _Tp __tmp = _GLIBCXX_MOVE(__a);
 80a04ec:	6960      	ldr	r0, [r4, #20]
      __a = _GLIBCXX_MOVE(__b);
 80a04ee:	2300      	movs	r3, #0
 80a04f0:	6163      	str	r3, [r4, #20]
      void
      reset(pointer __p = pointer()) noexcept
      {
	using std::swap;
	swap(std::get<0>(_M_t), __p);
	if (__p != pointer())
 80a04f2:	b128      	cbz	r0, 80a0500 <_ZN19ApplicationWatchdogD1Ev+0x38>
	  get_deleter()(__p);
 80a04f4:	f7ff ffd7 	bl	80a04a6 <_ZNKSt14default_deleteIN6Thread4DataEEclEPS1_.isra.13>

      /// Destructor, invokes the deleter if the stored pointer is not null.
      ~unique_ptr() noexcept
      {
	auto& __ptr = std::get<0>(_M_t);
	if (__ptr != nullptr)
 80a04f8:	6960      	ldr	r0, [r4, #20]
 80a04fa:	b108      	cbz	r0, 80a0500 <_ZN19ApplicationWatchdogD1Ev+0x38>
	  get_deleter()(__ptr);
 80a04fc:	f7ff ffd3 	bl	80a04a6 <_ZNKSt14default_deleteIN6Thread4DataEEclEPS1_.isra.13>
 80a0500:	1d20      	adds	r0, r4, #4
 80a0502:	f7ff ffc7 	bl	80a0494 <_ZNSt14_Function_baseD1Ev>
 80a0506:	4620      	mov	r0, r4
 80a0508:	bd10      	pop	{r4, pc}
	...

080a050c <_ZN19ApplicationWatchdogC1EjPFvvEj>:
		checkin();
	}

    // This constuctor helps to resolve overloaded function types, such as System.reset(), which is not always
    // possible in case of std::function
    ApplicationWatchdog(unsigned timeout_ms, void (*fn)(), unsigned stack_size=DEFAULT_STACK_SIZE) :
 80a050c:	b530      	push	{r4, r5, lr}
 80a050e:	461d      	mov	r5, r3
 80a0510:	b087      	sub	sp, #28
	{
	  _Base::_M_init_functor(__functor, std::__addressof(__f.get()));
	}
      };

    _Function_base() : _M_manager(nullptr) { }
 80a0512:	2300      	movs	r3, #0
 80a0514:	4604      	mov	r4, r0
 80a0516:	9304      	str	r3, [sp, #16]
      function(_Functor __f)
      : _Function_base()
      {
	typedef _Function_handler<_Signature_type, _Functor> _My_handler;

	if (_My_handler::_M_not_empty_function(__f))
 80a0518:	b122      	cbz	r2, 80a0524 <_ZN19ApplicationWatchdogC1EjPFvvEj+0x18>
	  {
	    _My_handler::_M_init_functor(_M_functor, std::move(__f));
	    _M_invoker = &_My_handler::_M_invoke;
 80a051a:	4b22      	ldr	r3, [pc, #136]	; (80a05a4 <_ZN19ApplicationWatchdogC1EjPFvvEj+0x98>)
	  { return true; }

      private:
	static void
	_M_init_functor(_Any_data& __functor, _Functor&& __f, true_type)
	{ new (__functor._M_access()) _Functor(std::move(__f)); }
 80a051c:	9202      	str	r2, [sp, #8]
	typedef _Function_handler<_Signature_type, _Functor> _My_handler;

	if (_My_handler::_M_not_empty_function(__f))
	  {
	    _My_handler::_M_init_functor(_M_functor, std::move(__f));
	    _M_invoker = &_My_handler::_M_invoke;
 80a051e:	9305      	str	r3, [sp, #20]
	    _M_manager = &_My_handler::_M_manager;
 80a0520:	4b21      	ldr	r3, [pc, #132]	; (80a05a8 <_ZN19ApplicationWatchdogC1EjPFvvEj+0x9c>)
 80a0522:	9304      	str	r3, [sp, #16]
	{
	  _Base::_M_init_functor(__functor, std::__addressof(__f.get()));
	}
      };

    _Function_base() : _M_manager(nullptr) { }
 80a0524:	2300      	movs	r3, #0
 80a0526:	60e3      	str	r3, [r4, #12]
 80a0528:	9b04      	ldr	r3, [sp, #16]
    static const unsigned DEFAULT_STACK_SIZE = 512;

	ApplicationWatchdog(unsigned timeout_ms, std::function<void(void)> fn, unsigned stack_size=DEFAULT_STACK_SIZE) :
		timeout(timeout_ms),
		timeout_fn(fn),
		thread("appwdt", start, this, OS_THREAD_PRIORITY_CRITICAL, stack_size)
 80a052a:	6021      	str	r1, [r4, #0]
  template<typename _Res, typename... _ArgTypes>
    function<_Res(_ArgTypes...)>::
    function(const function& __x)
    : _Function_base()
    {
      if (static_cast<bool>(__x))
 80a052c:	b13b      	cbz	r3, 80a053e <_ZN19ApplicationWatchdogC1EjPFvvEj+0x32>
	{
	  __x._M_manager(_M_functor, __x._M_functor, __clone_functor);
 80a052e:	2202      	movs	r2, #2
 80a0530:	a902      	add	r1, sp, #8
 80a0532:	1d20      	adds	r0, r4, #4
 80a0534:	4798      	blx	r3
	  _M_invoker = __x._M_invoker;
 80a0536:	9b05      	ldr	r3, [sp, #20]
 80a0538:	6123      	str	r3, [r4, #16]
	  _M_manager = __x._M_manager;
 80a053a:	9b04      	ldr	r3, [sp, #16]
 80a053c:	60e3      	str	r3, [r4, #12]
    {
    }

    Thread(const char* name, os_thread_fn_t function, void* function_param=NULL,
            os_thread_prio_t priority=OS_THREAD_PRIORITY_DEFAULT, size_t stack_size=OS_THREAD_STACK_SIZE_DEFAULT)
        : d_(new(std::nothrow) Data)
 80a053e:	491b      	ldr	r1, [pc, #108]	; (80a05ac <_ZN19ApplicationWatchdogC1EjPFvvEj+0xa0>)
 80a0540:	2014      	movs	r0, #20
 80a0542:	f004 fe31 	bl	80a51a8 <_ZnwjRKSt9nothrow_t>
 80a0546:	b130      	cbz	r0, 80a0556 <_ZN19ApplicationWatchdogC1EjPFvvEj+0x4a>

  template<std::size_t _Idx, typename _Head>
    struct _Head_base<_Idx, _Head, false>
    {
      constexpr _Head_base()
      : _M_head_impl() { }
 80a0548:	2300      	movs	r3, #0
        Data() :
            handle(OS_THREAD_INVALID_HANDLE),
            func(nullptr),
            func_param(nullptr),
            started(false),
            exited(false) {
 80a054a:	7403      	strb	r3, [r0, #16]
 80a054c:	6003      	str	r3, [r0, #0]
 80a054e:	6043      	str	r3, [r0, #4]
 80a0550:	6083      	str	r3, [r0, #8]
 80a0552:	60c3      	str	r3, [r0, #12]
 80a0554:	7443      	strb	r3, [r0, #17]
      constexpr _Head_base(const _Head_base&) = default;
      constexpr _Head_base(_Head_base&&) = default;

      template<typename _UHead>
        constexpr _Head_base(_UHead&& __h)
	: _M_head_impl(std::forward<_UHead>(__h)) { }
 80a0556:	6160      	str	r0, [r4, #20]

    Thread(const char* name, os_thread_fn_t function, void* function_param=NULL,
            os_thread_prio_t priority=OS_THREAD_PRIORITY_DEFAULT, size_t stack_size=OS_THREAD_STACK_SIZE_DEFAULT)
        : d_(new(std::nothrow) Data)
    {
        if (!d_) {
 80a0558:	b198      	cbz	r0, 80a0582 <_ZN19ApplicationWatchdogC1EjPFvvEj+0x76>
            goto error;
        }
        d_->func = function;
 80a055a:	4b15      	ldr	r3, [pc, #84]	; (80a05b0 <_ZN19ApplicationWatchdogC1EjPFvvEj+0xa4>)
        d_->func_param = function_param;
        if (os_thread_create(&d_->handle, name, priority, &Thread::run, d_.get(), stack_size) != 0) {
 80a055c:	2209      	movs	r2, #9
        : d_(new(std::nothrow) Data)
    {
        if (!d_) {
            goto error;
        }
        d_->func = function;
 80a055e:	6083      	str	r3, [r0, #8]
      }

      /// Return the stored pointer.
      pointer
      get() const noexcept
      { return std::get<0>(_M_t); }
 80a0560:	6963      	ldr	r3, [r4, #20]
        d_->func_param = function_param;
        if (os_thread_create(&d_->handle, name, priority, &Thread::run, d_.get(), stack_size) != 0) {
 80a0562:	4914      	ldr	r1, [pc, #80]	; (80a05b4 <_ZN19ApplicationWatchdogC1EjPFvvEj+0xa8>)
    {
        if (!d_) {
            goto error;
        }
        d_->func = function;
        d_->func_param = function_param;
 80a0564:	60dc      	str	r4, [r3, #12]
 80a0566:	6960      	ldr	r0, [r4, #20]
        if (os_thread_create(&d_->handle, name, priority, &Thread::run, d_.get(), stack_size) != 0) {
 80a0568:	4b13      	ldr	r3, [pc, #76]	; (80a05b8 <_ZN19ApplicationWatchdogC1EjPFvvEj+0xac>)
 80a056a:	e88d 0021 	stmia.w	sp, {r0, r5}
 80a056e:	3004      	adds	r0, #4
 80a0570:	f003 f92e 	bl	80a37d0 <os_thread_create>
 80a0574:	b928      	cbnz	r0, 80a0582 <_ZN19ApplicationWatchdogC1EjPFvvEj+0x76>
 80a0576:	6963      	ldr	r3, [r4, #20]
            goto error;
        }
        while (!d_->started) {
 80a0578:	7c1b      	ldrb	r3, [r3, #16]
 80a057a:	b943      	cbnz	r3, 80a058e <_ZN19ApplicationWatchdogC1EjPFvvEj+0x82>
            os_thread_yield();
 80a057c:	f003 f938 	bl	80a37f0 <os_thread_yield>
 80a0580:	e7f9      	b.n	80a0576 <_ZN19ApplicationWatchdogC1EjPFvvEj+0x6a>
#endif
    {
      // concept requirements
      __glibcxx_function_requires(_SGIAssignableConcept<_Tp>)

      _Tp __tmp = _GLIBCXX_MOVE(__a);
 80a0582:	6960      	ldr	r0, [r4, #20]
      __a = _GLIBCXX_MOVE(__b);
 80a0584:	2300      	movs	r3, #0
 80a0586:	6163      	str	r3, [r4, #20]
      void
      reset(pointer __p = pointer()) noexcept
      {
	using std::swap;
	swap(std::get<0>(_M_t), __p);
	if (__p != pointer())
 80a0588:	b108      	cbz	r0, 80a058e <_ZN19ApplicationWatchdogC1EjPFvvEj+0x82>
	  get_deleter()(__p);
 80a058a:	f7ff ff8c 	bl	80a04a6 <_ZNKSt14default_deleteIN6Thread4DataEEclEPS1_.isra.13>
		return !timeout_fn;
	}

	static inline system_tick_t current_time()
	{
		return HAL_Timer_Get_Milli_Seconds();
 80a058e:	f003 f9a7 	bl	80a38e0 <HAL_Timer_Get_Milli_Seconds>
	/**
	 * Lifesign that the application is still working normally.
	 */
	static void checkin()
	{
		last_checkin = current_time();
 80a0592:	4b0a      	ldr	r3, [pc, #40]	; (80a05bc <_ZN19ApplicationWatchdogC1EjPFvvEj+0xb0>)
 80a0594:	6018      	str	r0, [r3, #0]
   *  @ingroup functors
   *
   *  Polymorphic function wrapper.
   */
  template<typename _Res, typename... _ArgTypes>
    class function<_Res(_ArgTypes...)>
 80a0596:	a802      	add	r0, sp, #8
 80a0598:	f7ff ff7c 	bl	80a0494 <_ZNSt14_Function_baseD1Ev>
    // This constuctor helps to resolve overloaded function types, such as System.reset(), which is not always
    // possible in case of std::function
    ApplicationWatchdog(unsigned timeout_ms, void (*fn)(), unsigned stack_size=DEFAULT_STACK_SIZE) :
        ApplicationWatchdog(timeout_ms, std::function<void()>(fn), stack_size)
    {
    }
 80a059c:	4620      	mov	r0, r4
 80a059e:	b007      	add	sp, #28
 80a05a0:	bd30      	pop	{r4, r5, pc}
 80a05a2:	bf00      	nop
 80a05a4:	080a0409 	.word	0x080a0409
 80a05a8:	080a040d 	.word	0x080a040d
 80a05ac:	080a6bd8 	.word	0x080a6bd8
 80a05b0:	080a509d 	.word	0x080a509d
 80a05b4:	080a64bc 	.word	0x080a64bc
 80a05b8:	080a122b 	.word	0x080a122b
 80a05bc:	20000dcc 	.word	0x20000dcc

080a05c0 <_ZN5TimerC1EjSt8functionIFvvEEb>:
{
public:

    typedef std::function<void(void)> timer_callback_fn;

    Timer(unsigned period, timer_callback_fn callback_, bool one_shot=false) : running(false), handle(nullptr), callback(std::move(callback_)) {
 80a05c0:	b5f0      	push	{r4, r5, r6, r7, lr}
 80a05c2:	4604      	mov	r4, r0
 80a05c4:	468e      	mov	lr, r1
 80a05c6:	4915      	ldr	r1, [pc, #84]	; (80a061c <_ZN5TimerC1EjSt8functionIFvvEEb+0x5c>)
 80a05c8:	2500      	movs	r5, #0
 80a05ca:	b085      	sub	sp, #20
 80a05cc:	7105      	strb	r5, [r0, #4]
 80a05ce:	6085      	str	r5, [r0, #8]
	{
	  _Base::_M_init_functor(__functor, std::__addressof(__f.get()));
	}
      };

    _Function_base() : _M_manager(nullptr) { }
 80a05d0:	6145      	str	r5, [r0, #20]
 80a05d2:	6001      	str	r1, [r0, #0]
#endif
    {
      // concept requirements
      __glibcxx_function_requires(_SGIAssignableConcept<_Tp>)

      _Tp __tmp = _GLIBCXX_MOVE(__a);
 80a05d4:	af02      	add	r7, sp, #8
 80a05d6:	e892 0003 	ldmia.w	r2, {r0, r1}
 80a05da:	e887 0003 	stmia.w	r7, {r0, r1}
      __a = _GLIBCXX_MOVE(__b);
 80a05de:	f104 060c 	add.w	r6, r4, #12
 80a05e2:	e896 0003 	ldmia.w	r6, {r0, r1}
 80a05e6:	e882 0003 	stmia.w	r2, {r0, r1}
      __b = _GLIBCXX_MOVE(__tmp);
 80a05ea:	e897 0003 	ldmia.w	r7, {r0, r1}
 80a05ee:	e886 0003 	stmia.w	r6, {r0, r1}
#endif
    {
      // concept requirements
      __glibcxx_function_requires(_SGIAssignableConcept<_Tp>)

      _Tp __tmp = _GLIBCXX_MOVE(__a);
 80a05f2:	6891      	ldr	r1, [r2, #8]
      __a = _GLIBCXX_MOVE(__b);
 80a05f4:	6960      	ldr	r0, [r4, #20]
 80a05f6:	6090      	str	r0, [r2, #8]
      __b = _GLIBCXX_MOVE(__tmp);
 80a05f8:	6161      	str	r1, [r4, #20]
#endif
    {
      // concept requirements
      __glibcxx_function_requires(_SGIAssignableConcept<_Tp>)

      _Tp __tmp = _GLIBCXX_MOVE(__a);
 80a05fa:	68d1      	ldr	r1, [r2, #12]
      __a = _GLIBCXX_MOVE(__b);
 80a05fc:	69a0      	ldr	r0, [r4, #24]
 80a05fe:	60d0      	str	r0, [r2, #12]
      __b = _GLIBCXX_MOVE(__tmp);
 80a0600:	61a1      	str	r1, [r4, #24]
        os_timer_create(&handle, period, invoke_timer, this, one_shot, nullptr);
 80a0602:	e88d 0028 	stmia.w	sp, {r3, r5}
 80a0606:	4a06      	ldr	r2, [pc, #24]	; (80a0620 <_ZN5TimerC1EjSt8functionIFvvEEb+0x60>)
 80a0608:	4623      	mov	r3, r4
 80a060a:	4671      	mov	r1, lr
 80a060c:	f104 0008 	add.w	r0, r4, #8
 80a0610:	f003 f906 	bl	80a3820 <os_timer_create>
    }
 80a0614:	4620      	mov	r0, r4
 80a0616:	b005      	add	sp, #20
 80a0618:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80a061a:	bf00      	nop
 80a061c:	080a6498 	.word	0x080a6498
 80a0620:	080a046d 	.word	0x080a046d

080a0624 <_ZN5Timer5_stopEjb>:
    {
        stop(fromISR);
        return handle ? !os_timer_change(handle, OS_TIMER_CHANGE_START, fromISR, 0, block, nullptr) : false;
    }

    bool _stop(unsigned block, bool fromISR=false)
 80a0624:	b507      	push	{r0, r1, r2, lr}
    {
        return handle ? !os_timer_change(handle, OS_TIMER_CHANGE_STOP, fromISR, 0, block, nullptr) : false;
 80a0626:	6880      	ldr	r0, [r0, #8]
 80a0628:	2300      	movs	r3, #0
 80a062a:	b138      	cbz	r0, 80a063c <_ZN5Timer5_stopEjb+0x18>
 80a062c:	e88d 000a 	stmia.w	sp, {r1, r3}
 80a0630:	2102      	movs	r1, #2
 80a0632:	f003 f90d 	bl	80a3850 <os_timer_change>
 80a0636:	fab0 f080 	clz	r0, r0
 80a063a:	0940      	lsrs	r0, r0, #5
    }
 80a063c:	b003      	add	sp, #12
 80a063e:	f85d fb04 	ldr.w	pc, [sp], #4

080a0642 <_ZN5Timer5startEj>:
    bool resetFromISR() { return _reset(0, true); }
    bool changePeriodFromISR(unsigned period) { return _changePeriod(period, 0, true); }

    static const unsigned default_wait = 0x7FFFFFFF;

    bool start(unsigned block=default_wait) { return _start(block, false); }
 80a0642:	b537      	push	{r0, r1, r2, r4, r5, lr}
 80a0644:	4605      	mov	r5, r0
    bool stop(unsigned block=default_wait) { return _stop(block, false); }
 80a0646:	2200      	movs	r2, #0
    bool resetFromISR() { return _reset(0, true); }
    bool changePeriodFromISR(unsigned period) { return _changePeriod(period, 0, true); }

    static const unsigned default_wait = 0x7FFFFFFF;

    bool start(unsigned block=default_wait) { return _start(block, false); }
 80a0648:	460c      	mov	r4, r1
    bool stop(unsigned block=default_wait) { return _stop(block, false); }
 80a064a:	4611      	mov	r1, r2
 80a064c:	f7ff ffea 	bl	80a0624 <_ZN5Timer5_stopEjb>
    bool isActive() const { return isValid() && os_timer_is_active(handle, nullptr); }

    bool _start(unsigned block, bool fromISR=false)
    {
        stop(fromISR);
        return handle ? !os_timer_change(handle, OS_TIMER_CHANGE_START, fromISR, 0, block, nullptr) : false;
 80a0650:	68a8      	ldr	r0, [r5, #8]
 80a0652:	2300      	movs	r3, #0
 80a0654:	b140      	cbz	r0, 80a0668 <_ZN5Timer5startEj+0x26>
 80a0656:	9301      	str	r3, [sp, #4]
 80a0658:	9400      	str	r4, [sp, #0]
 80a065a:	461a      	mov	r2, r3
 80a065c:	4619      	mov	r1, r3
 80a065e:	f003 f8f7 	bl	80a3850 <os_timer_change>
 80a0662:	fab0 f080 	clz	r0, r0
 80a0666:	0940      	lsrs	r0, r0, #5
    bool resetFromISR() { return _reset(0, true); }
    bool changePeriodFromISR(unsigned period) { return _changePeriod(period, 0, true); }

    static const unsigned default_wait = 0x7FFFFFFF;

    bool start(unsigned block=default_wait) { return _start(block, false); }
 80a0668:	b003      	add	sp, #12
 80a066a:	bd30      	pop	{r4, r5, pc}

080a066c <_ZN5TimerD1Ev>:
    template <typename T>
    Timer(unsigned period, void (T::*handler)(), T& instance, bool one_shot=false) : Timer(period, std::bind(handler, &instance), one_shot)
    {
    }

    virtual ~Timer() {
 80a066c:	b538      	push	{r3, r4, r5, lr}
 80a066e:	4b0e      	ldr	r3, [pc, #56]	; (80a06a8 <_ZN5TimerD1Ev+0x3c>)
 80a0670:	4604      	mov	r4, r0
 80a0672:	6003      	str	r3, [r0, #0]
         return handle ? !os_timer_change(handle, OS_TIMER_CHANGE_PERIOD, fromISR, period, block, nullptr) : false;
    }

    void dispose()
    {
        if (handle)
 80a0674:	6883      	ldr	r3, [r0, #8]
 80a0676:	b18b      	cbz	r3, 80a069c <_ZN5TimerD1Ev+0x30>
    bool changePeriodFromISR(unsigned period) { return _changePeriod(period, 0, true); }

    static const unsigned default_wait = 0x7FFFFFFF;

    bool start(unsigned block=default_wait) { return _start(block, false); }
    bool stop(unsigned block=default_wait) { return _stop(block, false); }
 80a0678:	2200      	movs	r2, #0
 80a067a:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
 80a067e:	f7ff ffd1 	bl	80a0624 <_ZN5Timer5_stopEjb>
    void dispose()
    {
        if (handle)
        	{
        		stop();
        		while (running) {
 80a0682:	7923      	ldrb	r3, [r4, #4]
 80a0684:	f003 05ff 	and.w	r5, r3, #255	; 0xff
 80a0688:	b11b      	cbz	r3, 80a0692 <_ZN5TimerD1Ev+0x26>
				delay(1);
 80a068a:	2001      	movs	r0, #1
 80a068c:	f003 fe7c 	bl	80a4388 <delay>
 80a0690:	e7f7      	b.n	80a0682 <_ZN5TimerD1Ev+0x16>
			}
        		os_timer_destroy(handle, nullptr);
 80a0692:	4629      	mov	r1, r5
 80a0694:	68a0      	ldr	r0, [r4, #8]
 80a0696:	f003 f8cb 	bl	80a3830 <os_timer_destroy>
            handle = nullptr;
 80a069a:	60a5      	str	r5, [r4, #8]
   *  @ingroup functors
   *
   *  Polymorphic function wrapper.
   */
  template<typename _Res, typename... _ArgTypes>
    class function<_Res(_ArgTypes...)>
 80a069c:	f104 000c 	add.w	r0, r4, #12
 80a06a0:	f7ff fef8 	bl	80a0494 <_ZNSt14_Function_baseD1Ev>

    virtual ~Timer() {
    		// when the timer is calling the std::function, we cannot dispose of it until the function completes.
		// the call has exited.
		dispose();
    }
 80a06a4:	4620      	mov	r0, r4
 80a06a6:	bd38      	pop	{r3, r4, r5, pc}
 80a06a8:	080a6498 	.word	0x080a6498

080a06ac <_ZN5TimerD0Ev>:
    template <typename T>
    Timer(unsigned period, void (T::*handler)(), T& instance, bool one_shot=false) : Timer(period, std::bind(handler, &instance), one_shot)
    {
    }

    virtual ~Timer() {
 80a06ac:	b510      	push	{r4, lr}
 80a06ae:	4604      	mov	r4, r0
    		// when the timer is calling the std::function, we cannot dispose of it until the function completes.
		// the call has exited.
		dispose();
    }
 80a06b0:	f7ff ffdc 	bl	80a066c <_ZN5TimerD1Ev>
 80a06b4:	4620      	mov	r0, r4
 80a06b6:	f7ff fcf4 	bl	80a00a2 <_ZdlPv>
 80a06ba:	4620      	mov	r0, r4
 80a06bc:	bd10      	pop	{r4, pc}
	...

080a06c0 <_Z10getFgColorv>:
    saveSettings();
    return 1;
}

String getFgColor()
{
 80a06c0:	b513      	push	{r0, r1, r4, lr}
 80a06c2:	4604      	mov	r4, r0
    return String::format("%0.3d,%0.3d,%0.3d", fg_color.red, fg_color.green, fg_color.blue);
 80a06c4:	4905      	ldr	r1, [pc, #20]	; (80a06dc <_Z10getFgColorv+0x1c>)
 80a06c6:	784b      	ldrb	r3, [r1, #1]
 80a06c8:	780a      	ldrb	r2, [r1, #0]
 80a06ca:	7889      	ldrb	r1, [r1, #2]
 80a06cc:	9100      	str	r1, [sp, #0]
 80a06ce:	4904      	ldr	r1, [pc, #16]	; (80a06e0 <_Z10getFgColorv+0x20>)
 80a06d0:	f004 fc34 	bl	80a4f3c <_ZN6String6formatEPKcz>
}
 80a06d4:	4620      	mov	r0, r4
 80a06d6:	b002      	add	sp, #8
 80a06d8:	bd10      	pop	{r4, pc}
 80a06da:	bf00      	nop
 80a06dc:	20000590 	.word	0x20000590
 80a06e0:	080a64c3 	.word	0x080a64c3

080a06e4 <_Z10getBgColorv>:
    saveSettings();
    return 1;
}

String getBgColor()
{
 80a06e4:	b513      	push	{r0, r1, r4, lr}
 80a06e6:	4604      	mov	r4, r0
    return String::format("%0.3d,%0.3d,%0.3d", bg_color.red, bg_color.green, bg_color.blue);
 80a06e8:	4905      	ldr	r1, [pc, #20]	; (80a0700 <_Z10getBgColorv+0x1c>)
 80a06ea:	784b      	ldrb	r3, [r1, #1]
 80a06ec:	780a      	ldrb	r2, [r1, #0]
 80a06ee:	7889      	ldrb	r1, [r1, #2]
 80a06f0:	9100      	str	r1, [sp, #0]
 80a06f2:	4904      	ldr	r1, [pc, #16]	; (80a0704 <_Z10getBgColorv+0x20>)
 80a06f4:	f004 fc22 	bl	80a4f3c <_ZN6String6formatEPKcz>
}
 80a06f8:	4620      	mov	r0, r4
 80a06fa:	b002      	add	sp, #8
 80a06fc:	bd10      	pop	{r4, pc}
 80a06fe:	bf00      	nop
 80a0700:	200004f8 	.word	0x200004f8
 80a0704:	080a64c3 	.word	0x080a64c3

080a0708 <_Z12publishStatev>:
        leds[i] = EEPROM.read(address++);
    }
}

void publishState()
{
 80a0708:	b530      	push	{r4, r5, lr}
 80a070a:	b097      	sub	sp, #92	; 0x5c
    }
    inline static SleepResult sleep(const pin_t* pins, size_t pinsSize, const InterruptMode* edgeTriggerMode, size_t edgeTriggerModeSize, SleepOptionFlags flag, long seconds = 0) {
        return sleep(pins, pinsSize, edgeTriggerMode, edgeTriggerModeSize, seconds, flag);
    }

    static String deviceID(void) { return spark_deviceID(); }
 80a070c:	a803      	add	r0, sp, #12
 80a070e:	f003 f957 	bl	80a39c0 <spark_deviceID>

    String myID = System.deviceID();

    if (!client.isConnected()) {
 80a0712:	48a4      	ldr	r0, [pc, #656]	; (80a09a4 <_Z12publishStatev+0x29c>)
 80a0714:	f002 fc69 	bl	80a2fea <_ZN4MQTT11isConnectedEv>
 80a0718:	b928      	cbnz	r0, 80a0726 <_Z12publishStatev+0x1e>
        client.connect(myID, MQTT_USER, MQTT_PASSWORD);
 80a071a:	4ba3      	ldr	r3, [pc, #652]	; (80a09a8 <_Z12publishStatev+0x2a0>)
 80a071c:	4aa3      	ldr	r2, [pc, #652]	; (80a09ac <_Z12publishStatev+0x2a4>)
 80a071e:	9903      	ldr	r1, [sp, #12]
 80a0720:	48a0      	ldr	r0, [pc, #640]	; (80a09a4 <_Z12publishStatev+0x29c>)
 80a0722:	f002 fd47 	bl	80a31b4 <_ZN4MQTT7connectEPKcS1_S1_>
    }

    if (client.isConnected()) {
 80a0726:	489f      	ldr	r0, [pc, #636]	; (80a09a4 <_Z12publishStatev+0x29c>)
 80a0728:	f002 fc5f 	bl	80a2fea <_ZN4MQTT11isConnectedEv>
 80a072c:	4ca0      	ldr	r4, [pc, #640]	; (80a09b0 <_Z12publishStatev+0x2a8>)
 80a072e:	2800      	cmp	r0, #0
 80a0730:	f000 810e 	beq.w	80a0950 <_Z12publishStatev+0x248>

class StringSumHelper : public String
{
public:
	StringSumHelper(const String &s) : String(s) {}
	StringSumHelper(const char *p) : String(p) {}
 80a0734:	499f      	ldr	r1, [pc, #636]	; (80a09b4 <_Z12publishStatev+0x2ac>)
 80a0736:	a807      	add	r0, sp, #28
 80a0738:	f004 fb52 	bl	80a4de0 <_ZN6StringC1EPK19__FlashStringHelper>
        client.publish("/"+myID+"/state/DisplayMode", String(getDisplayMode("")));
 80a073c:	a903      	add	r1, sp, #12
 80a073e:	a807      	add	r0, sp, #28
 80a0740:	f004 fb9c 	bl	80a4e7c <_ZplRK15StringSumHelperRK6String>
 80a0744:	499c      	ldr	r1, [pc, #624]	; (80a09b8 <_Z12publishStatev+0x2b0>)
 80a0746:	f004 fba5 	bl	80a4e94 <_ZplRK15StringSumHelperPKc>
 80a074a:	499c      	ldr	r1, [pc, #624]	; (80a09bc <_Z12publishStatev+0x2b4>)
 80a074c:	6805      	ldr	r5, [r0, #0]
 80a074e:	a80b      	add	r0, sp, #44	; 0x2c
 80a0750:	f004 fb46 	bl	80a4de0 <_ZN6StringC1EPK19__FlashStringHelper>
 80a0754:	4b9a      	ldr	r3, [pc, #616]	; (80a09c0 <_Z12publishStatev+0x2b8>)
 80a0756:	220a      	movs	r2, #10
 80a0758:	6819      	ldr	r1, [r3, #0]
 80a075a:	a80f      	add	r0, sp, #60	; 0x3c
 80a075c:	f004 fb64 	bl	80a4e28 <_ZN6StringC1Eih>
 80a0760:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 80a0762:	4629      	mov	r1, r5
 80a0764:	488f      	ldr	r0, [pc, #572]	; (80a09a4 <_Z12publishStatev+0x29c>)
 80a0766:	f002 fda3 	bl	80a32b0 <_ZN4MQTT7publishEPKcS1_>
 80a076a:	a80f      	add	r0, sp, #60	; 0x3c
 80a076c:	f004 faf1 	bl	80a4d52 <_ZN6StringD1Ev>
 80a0770:	a80b      	add	r0, sp, #44	; 0x2c
 80a0772:	f004 faee 	bl	80a4d52 <_ZN6StringD1Ev>

        friend class StringPrintableHelper;

};

class StringSumHelper : public String
 80a0776:	a807      	add	r0, sp, #28
 80a0778:	f004 faeb 	bl	80a4d52 <_ZN6StringD1Ev>
{
public:
	StringSumHelper(const String &s) : String(s) {}
	StringSumHelper(const char *p) : String(p) {}
 80a077c:	498d      	ldr	r1, [pc, #564]	; (80a09b4 <_Z12publishStatev+0x2ac>)
 80a077e:	a807      	add	r0, sp, #28
 80a0780:	f004 fb2e 	bl	80a4de0 <_ZN6StringC1EPK19__FlashStringHelper>
        client.publish("/"+myID+"/state/Brightness", String(getBrightness("")));
 80a0784:	a903      	add	r1, sp, #12
 80a0786:	a807      	add	r0, sp, #28
 80a0788:	f004 fb78 	bl	80a4e7c <_ZplRK15StringSumHelperRK6String>
 80a078c:	498d      	ldr	r1, [pc, #564]	; (80a09c4 <_Z12publishStatev+0x2bc>)
 80a078e:	f004 fb81 	bl	80a4e94 <_ZplRK15StringSumHelperPKc>
 80a0792:	498a      	ldr	r1, [pc, #552]	; (80a09bc <_Z12publishStatev+0x2b4>)
 80a0794:	6805      	ldr	r5, [r0, #0]
 80a0796:	a80b      	add	r0, sp, #44	; 0x2c
 80a0798:	f004 fb22 	bl	80a4de0 <_ZN6StringC1EPK19__FlashStringHelper>
 80a079c:	4b8a      	ldr	r3, [pc, #552]	; (80a09c8 <_Z12publishStatev+0x2c0>)
 80a079e:	220a      	movs	r2, #10
 80a07a0:	7819      	ldrb	r1, [r3, #0]
 80a07a2:	a80f      	add	r0, sp, #60	; 0x3c
 80a07a4:	f004 fb40 	bl	80a4e28 <_ZN6StringC1Eih>
 80a07a8:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 80a07aa:	4629      	mov	r1, r5
 80a07ac:	487d      	ldr	r0, [pc, #500]	; (80a09a4 <_Z12publishStatev+0x29c>)
 80a07ae:	f002 fd7f 	bl	80a32b0 <_ZN4MQTT7publishEPKcS1_>
 80a07b2:	a80f      	add	r0, sp, #60	; 0x3c
 80a07b4:	f004 facd 	bl	80a4d52 <_ZN6StringD1Ev>
 80a07b8:	a80b      	add	r0, sp, #44	; 0x2c
 80a07ba:	f004 faca 	bl	80a4d52 <_ZN6StringD1Ev>

        friend class StringPrintableHelper;

};

class StringSumHelper : public String
 80a07be:	a807      	add	r0, sp, #28
 80a07c0:	f004 fac7 	bl	80a4d52 <_ZN6StringD1Ev>
{
public:
	StringSumHelper(const String &s) : String(s) {}
	StringSumHelper(const char *p) : String(p) {}
 80a07c4:	497b      	ldr	r1, [pc, #492]	; (80a09b4 <_Z12publishStatev+0x2ac>)
 80a07c6:	a80b      	add	r0, sp, #44	; 0x2c
 80a07c8:	f004 fb0a 	bl	80a4de0 <_ZN6StringC1EPK19__FlashStringHelper>
        client.publish("/"+myID+"/state/ForgroundColor", getFgColor());
 80a07cc:	a903      	add	r1, sp, #12
 80a07ce:	a80b      	add	r0, sp, #44	; 0x2c
 80a07d0:	f004 fb54 	bl	80a4e7c <_ZplRK15StringSumHelperRK6String>
 80a07d4:	497d      	ldr	r1, [pc, #500]	; (80a09cc <_Z12publishStatev+0x2c4>)
 80a07d6:	f004 fb5d 	bl	80a4e94 <_ZplRK15StringSumHelperPKc>
 80a07da:	6805      	ldr	r5, [r0, #0]
 80a07dc:	a80f      	add	r0, sp, #60	; 0x3c
 80a07de:	f7ff ff6f 	bl	80a06c0 <_Z10getFgColorv>
 80a07e2:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 80a07e4:	4629      	mov	r1, r5
 80a07e6:	486f      	ldr	r0, [pc, #444]	; (80a09a4 <_Z12publishStatev+0x29c>)
 80a07e8:	f002 fd62 	bl	80a32b0 <_ZN4MQTT7publishEPKcS1_>
 80a07ec:	a80f      	add	r0, sp, #60	; 0x3c
 80a07ee:	f004 fab0 	bl	80a4d52 <_ZN6StringD1Ev>

        friend class StringPrintableHelper;

};

class StringSumHelper : public String
 80a07f2:	a80b      	add	r0, sp, #44	; 0x2c
 80a07f4:	f004 faad 	bl	80a4d52 <_ZN6StringD1Ev>
{
public:
	StringSumHelper(const String &s) : String(s) {}
	StringSumHelper(const char *p) : String(p) {}
 80a07f8:	496e      	ldr	r1, [pc, #440]	; (80a09b4 <_Z12publishStatev+0x2ac>)
 80a07fa:	a80b      	add	r0, sp, #44	; 0x2c
 80a07fc:	f004 faf0 	bl	80a4de0 <_ZN6StringC1EPK19__FlashStringHelper>
        client.publish("/"+myID+"/state/BackgroundColor", getBgColor());
 80a0800:	a903      	add	r1, sp, #12
 80a0802:	a80b      	add	r0, sp, #44	; 0x2c
 80a0804:	f004 fb3a 	bl	80a4e7c <_ZplRK15StringSumHelperRK6String>
 80a0808:	4971      	ldr	r1, [pc, #452]	; (80a09d0 <_Z12publishStatev+0x2c8>)
 80a080a:	f004 fb43 	bl	80a4e94 <_ZplRK15StringSumHelperPKc>
 80a080e:	6805      	ldr	r5, [r0, #0]
 80a0810:	a80f      	add	r0, sp, #60	; 0x3c
 80a0812:	f7ff ff67 	bl	80a06e4 <_Z10getBgColorv>
 80a0816:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 80a0818:	4629      	mov	r1, r5
 80a081a:	4862      	ldr	r0, [pc, #392]	; (80a09a4 <_Z12publishStatev+0x29c>)
 80a081c:	f002 fd48 	bl	80a32b0 <_ZN4MQTT7publishEPKcS1_>
 80a0820:	a80f      	add	r0, sp, #60	; 0x3c
 80a0822:	f004 fa96 	bl	80a4d52 <_ZN6StringD1Ev>

        friend class StringPrintableHelper;

};

class StringSumHelper : public String
 80a0826:	a80b      	add	r0, sp, #44	; 0x2c
 80a0828:	f004 fa93 	bl	80a4d52 <_ZN6StringD1Ev>
{
public:
	StringSumHelper(const String &s) : String(s) {}
	StringSumHelper(const char *p) : String(p) {}
 80a082c:	4961      	ldr	r1, [pc, #388]	; (80a09b4 <_Z12publishStatev+0x2ac>)
 80a082e:	a80b      	add	r0, sp, #44	; 0x2c
 80a0830:	f004 fad6 	bl	80a4de0 <_ZN6StringC1EPK19__FlashStringHelper>
        client.publish("/"+myID+"/state/MaxDistance", String(maxDistance));
 80a0834:	a903      	add	r1, sp, #12
 80a0836:	a80b      	add	r0, sp, #44	; 0x2c
 80a0838:	f004 fb20 	bl	80a4e7c <_ZplRK15StringSumHelperRK6String>
 80a083c:	4965      	ldr	r1, [pc, #404]	; (80a09d4 <_Z12publishStatev+0x2cc>)
 80a083e:	f004 fb29 	bl	80a4e94 <_ZplRK15StringSumHelperPKc>
 80a0842:	4b65      	ldr	r3, [pc, #404]	; (80a09d8 <_Z12publishStatev+0x2d0>)
 80a0844:	6805      	ldr	r5, [r0, #0]
 80a0846:	8819      	ldrh	r1, [r3, #0]
 80a0848:	220a      	movs	r2, #10
 80a084a:	a80f      	add	r0, sp, #60	; 0x3c
 80a084c:	f004 faec 	bl	80a4e28 <_ZN6StringC1Eih>
 80a0850:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 80a0852:	4629      	mov	r1, r5
 80a0854:	4853      	ldr	r0, [pc, #332]	; (80a09a4 <_Z12publishStatev+0x29c>)
 80a0856:	f002 fd2b 	bl	80a32b0 <_ZN4MQTT7publishEPKcS1_>
 80a085a:	a80f      	add	r0, sp, #60	; 0x3c
 80a085c:	f004 fa79 	bl	80a4d52 <_ZN6StringD1Ev>

        friend class StringPrintableHelper;

};

class StringSumHelper : public String
 80a0860:	a80b      	add	r0, sp, #44	; 0x2c
 80a0862:	f004 fa76 	bl	80a4d52 <_ZN6StringD1Ev>
{
public:
	StringSumHelper(const String &s) : String(s) {}
	StringSumHelper(const char *p) : String(p) {}
 80a0866:	4953      	ldr	r1, [pc, #332]	; (80a09b4 <_Z12publishStatev+0x2ac>)
 80a0868:	a80b      	add	r0, sp, #44	; 0x2c
 80a086a:	f004 fab9 	bl	80a4de0 <_ZN6StringC1EPK19__FlashStringHelper>
        client.publish("/"+myID+"/state/LastDistance", String(lastDistance));
 80a086e:	a903      	add	r1, sp, #12
 80a0870:	a80b      	add	r0, sp, #44	; 0x2c
 80a0872:	f004 fb03 	bl	80a4e7c <_ZplRK15StringSumHelperRK6String>
 80a0876:	4959      	ldr	r1, [pc, #356]	; (80a09dc <_Z12publishStatev+0x2d4>)
 80a0878:	f004 fb0c 	bl	80a4e94 <_ZplRK15StringSumHelperPKc>
 80a087c:	6805      	ldr	r5, [r0, #0]
 80a087e:	220a      	movs	r2, #10
 80a0880:	8821      	ldrh	r1, [r4, #0]
 80a0882:	a80f      	add	r0, sp, #60	; 0x3c
 80a0884:	f004 fad0 	bl	80a4e28 <_ZN6StringC1Eih>
 80a0888:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 80a088a:	4629      	mov	r1, r5
 80a088c:	4845      	ldr	r0, [pc, #276]	; (80a09a4 <_Z12publishStatev+0x29c>)
 80a088e:	f002 fd0f 	bl	80a32b0 <_ZN4MQTT7publishEPKcS1_>
 80a0892:	a80f      	add	r0, sp, #60	; 0x3c
 80a0894:	f004 fa5d 	bl	80a4d52 <_ZN6StringD1Ev>

        friend class StringPrintableHelper;

};

class StringSumHelper : public String
 80a0898:	a80b      	add	r0, sp, #44	; 0x2c
 80a089a:	f004 fa5a 	bl	80a4d52 <_ZN6StringD1Ev>
{
public:
	StringSumHelper(const String &s) : String(s) {}
	StringSumHelper(const char *p) : String(p) {}
 80a089e:	4945      	ldr	r1, [pc, #276]	; (80a09b4 <_Z12publishStatev+0x2ac>)
 80a08a0:	a80b      	add	r0, sp, #44	; 0x2c
 80a08a2:	f004 fa9d 	bl	80a4de0 <_ZN6StringC1EPK19__FlashStringHelper>
        client.publish("/"+myID+"/state/CurrentDistance", String(getDistance()));
 80a08a6:	a903      	add	r1, sp, #12
 80a08a8:	a80b      	add	r0, sp, #44	; 0x2c
 80a08aa:	f004 fae7 	bl	80a4e7c <_ZplRK15StringSumHelperRK6String>
 80a08ae:	494c      	ldr	r1, [pc, #304]	; (80a09e0 <_Z12publishStatev+0x2d8>)
 80a08b0:	f004 faf0 	bl	80a4e94 <_ZplRK15StringSumHelperPKc>
 80a08b4:	6805      	ldr	r5, [r0, #0]
 80a08b6:	f001 fe41 	bl	80a253c <_Z11getDistancev>
 80a08ba:	220a      	movs	r2, #10
 80a08bc:	4601      	mov	r1, r0
 80a08be:	a80f      	add	r0, sp, #60	; 0x3c
 80a08c0:	f004 fab2 	bl	80a4e28 <_ZN6StringC1Eih>
 80a08c4:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 80a08c6:	4629      	mov	r1, r5
 80a08c8:	4836      	ldr	r0, [pc, #216]	; (80a09a4 <_Z12publishStatev+0x29c>)
 80a08ca:	f002 fcf1 	bl	80a32b0 <_ZN4MQTT7publishEPKcS1_>
 80a08ce:	a80f      	add	r0, sp, #60	; 0x3c
 80a08d0:	f004 fa3f 	bl	80a4d52 <_ZN6StringD1Ev>

        friend class StringPrintableHelper;

};

class StringSumHelper : public String
 80a08d4:	a80b      	add	r0, sp, #44	; 0x2c
 80a08d6:	f004 fa3c 	bl	80a4d52 <_ZN6StringD1Ev>
{
public:
	StringSumHelper(const String &s) : String(s) {}
	StringSumHelper(const char *p) : String(p) {}
 80a08da:	4936      	ldr	r1, [pc, #216]	; (80a09b4 <_Z12publishStatev+0x2ac>)
 80a08dc:	a807      	add	r0, sp, #28
 80a08de:	f004 fa7f 	bl	80a4de0 <_ZN6StringC1EPK19__FlashStringHelper>
        client.publish("/"+myID+"/state/FirmwareVersion", System.version());
 80a08e2:	a903      	add	r1, sp, #12
 80a08e4:	a807      	add	r0, sp, #28
 80a08e6:	f004 fac9 	bl	80a4e7c <_ZplRK15StringSumHelperRK6String>
 80a08ea:	493e      	ldr	r1, [pc, #248]	; (80a09e4 <_Z12publishStatev+0x2dc>)
 80a08ec:	f004 fad2 	bl	80a4e94 <_ZplRK15StringSumHelperPKc>
#define SYSTEM_VERSION_080RC14
#define SYSTEM_VERSION_100
#define SYSTEM_VERSION_101RC1
#define SYSTEM_VERSION_101

typedef struct __attribute__((packed)) SystemVersionInfo
 80a08f0:	231c      	movs	r3, #28
 80a08f2:	6805      	ldr	r5, [r0, #0]
    static bool enableFeature(const WiFiTesterFeature feature);

    String version()
    {
        SystemVersionInfo info;
        system_version_info(&info, nullptr);
 80a08f4:	2100      	movs	r1, #0
 80a08f6:	a80f      	add	r0, sp, #60	; 0x3c
 80a08f8:	f8ad 303c 	strh.w	r3, [sp, #60]	; 0x3c
 80a08fc:	f003 f898 	bl	80a3a30 <system_version_info>
        return String(info.versionString);
 80a0900:	a911      	add	r1, sp, #68	; 0x44
 80a0902:	a80b      	add	r0, sp, #44	; 0x2c
 80a0904:	f004 fa6c 	bl	80a4de0 <_ZN6StringC1EPK19__FlashStringHelper>
 80a0908:	9a0b      	ldr	r2, [sp, #44]	; 0x2c
 80a090a:	4629      	mov	r1, r5
 80a090c:	4825      	ldr	r0, [pc, #148]	; (80a09a4 <_Z12publishStatev+0x29c>)
 80a090e:	f002 fccf 	bl	80a32b0 <_ZN4MQTT7publishEPKcS1_>
 80a0912:	a80b      	add	r0, sp, #44	; 0x2c
 80a0914:	f004 fa1d 	bl	80a4d52 <_ZN6StringD1Ev>

        friend class StringPrintableHelper;

};

class StringSumHelper : public String
 80a0918:	a807      	add	r0, sp, #28
 80a091a:	f004 fa1a 	bl	80a4d52 <_ZN6StringD1Ev>
{
public:
	StringSumHelper(const String &s) : String(s) {}
	StringSumHelper(const char *p) : String(p) {}
 80a091e:	4925      	ldr	r1, [pc, #148]	; (80a09b4 <_Z12publishStatev+0x2ac>)
 80a0920:	a80f      	add	r0, sp, #60	; 0x3c
 80a0922:	f004 fa5d 	bl	80a4de0 <_ZN6StringC1EPK19__FlashStringHelper>
        client.publish("/"+myID+"/state/DisplayEnabled", displayEnabled ? "true" : "false");
 80a0926:	a903      	add	r1, sp, #12
 80a0928:	a80f      	add	r0, sp, #60	; 0x3c
 80a092a:	f004 faa7 	bl	80a4e7c <_ZplRK15StringSumHelperRK6String>
 80a092e:	492e      	ldr	r1, [pc, #184]	; (80a09e8 <_Z12publishStatev+0x2e0>)
 80a0930:	f004 fab0 	bl	80a4e94 <_ZplRK15StringSumHelperPKc>
 80a0934:	4b2d      	ldr	r3, [pc, #180]	; (80a09ec <_Z12publishStatev+0x2e4>)
 80a0936:	4a2e      	ldr	r2, [pc, #184]	; (80a09f0 <_Z12publishStatev+0x2e8>)
 80a0938:	7819      	ldrb	r1, [r3, #0]
 80a093a:	4b2e      	ldr	r3, [pc, #184]	; (80a09f4 <_Z12publishStatev+0x2ec>)
 80a093c:	2900      	cmp	r1, #0
 80a093e:	bf08      	it	eq
 80a0940:	461a      	moveq	r2, r3
 80a0942:	6801      	ldr	r1, [r0, #0]
 80a0944:	4817      	ldr	r0, [pc, #92]	; (80a09a4 <_Z12publishStatev+0x29c>)
 80a0946:	f002 fcb3 	bl	80a32b0 <_ZN4MQTT7publishEPKcS1_>

        friend class StringPrintableHelper;

};

class StringSumHelper : public String
 80a094a:	a80f      	add	r0, sp, #60	; 0x3c
 80a094c:	f004 fa01 	bl	80a4d52 <_ZN6StringD1Ev>
    }

    Particle.publish("Entfernung", String::format("Entfernung: %6d cm", lastDistance));
 80a0950:	8822      	ldrh	r2, [r4, #0]
 80a0952:	4929      	ldr	r1, [pc, #164]	; (80a09f8 <_Z12publishStatev+0x2f0>)
 80a0954:	a80f      	add	r0, sp, #60	; 0x3c
 80a0956:	f004 faf1 	bl	80a4f3c <_ZN6String6formatEPKcz>
 80a095a:	4b28      	ldr	r3, [pc, #160]	; (80a09fc <_Z12publishStatev+0x2f4>)
        return publish(eventName, eventData, 60, flags1, flags2);
    }

    inline particle::Future<bool> publish(const char *eventName, const char *eventData, int ttl, PublishFlags flags1, PublishFlags flags2 = PublishFlags())
    {
        return publish_event(eventName, eventData, ttl, flags1 | flags2);
 80a095c:	9a0f      	ldr	r2, [sp, #60]	; 0x3c
 80a095e:	781b      	ldrb	r3, [r3, #0]
 80a0960:	4927      	ldr	r1, [pc, #156]	; (80a0a00 <_Z12publishStatev+0x2f8>)
 80a0962:	f88d 3000 	strb.w	r3, [sp]
 80a0966:	a80b      	add	r0, sp, #44	; 0x2c
 80a0968:	233c      	movs	r3, #60	; 0x3c
 80a096a:	f003 fba9 	bl	80a40c0 <_ZN10CloudClass13publish_eventEPKcS1_iN8particle5FlagsI15PublishFlagTypehEE>
      // Does not throw if __r._M_get_use_count() == 0, caller must check.
      explicit __shared_count(const __weak_count<_Lp>& __r, std::nothrow_t);

      ~__shared_count() noexcept
      {
	if (_M_pi != nullptr)
 80a096e:	9c0c      	ldr	r4, [sp, #48]	; 0x30
 80a0970:	b17c      	cbz	r4, 80a0992 <_Z12publishStatev+0x28a>

  template<>
    inline void
    _Sp_counted_base<_S_single>::_M_release() noexcept
    {
      if (--_M_use_count == 0)
 80a0972:	6863      	ldr	r3, [r4, #4]
 80a0974:	3b01      	subs	r3, #1
 80a0976:	6063      	str	r3, [r4, #4]
 80a0978:	b95b      	cbnz	r3, 80a0992 <_Z12publishStatev+0x28a>
        {
          _M_dispose();
 80a097a:	6823      	ldr	r3, [r4, #0]
 80a097c:	4620      	mov	r0, r4
 80a097e:	689b      	ldr	r3, [r3, #8]
 80a0980:	4798      	blx	r3
          if (--_M_weak_count == 0)
 80a0982:	68a3      	ldr	r3, [r4, #8]
 80a0984:	3b01      	subs	r3, #1
 80a0986:	60a3      	str	r3, [r4, #8]
 80a0988:	b91b      	cbnz	r3, 80a0992 <_Z12publishStatev+0x28a>
            _M_destroy();
 80a098a:	6823      	ldr	r3, [r4, #0]
 80a098c:	4620      	mov	r0, r4
 80a098e:	68db      	ldr	r3, [r3, #12]
 80a0990:	4798      	blx	r3
 80a0992:	a80f      	add	r0, sp, #60	; 0x3c
 80a0994:	f004 f9dd 	bl	80a4d52 <_ZN6StringD1Ev>
}

void publishState()
{

    String myID = System.deviceID();
 80a0998:	a803      	add	r0, sp, #12
 80a099a:	f004 f9da 	bl	80a4d52 <_ZN6StringD1Ev>
        client.publish("/"+myID+"/state/FirmwareVersion", System.version());
        client.publish("/"+myID+"/state/DisplayEnabled", displayEnabled ? "true" : "false");
    }

    Particle.publish("Entfernung", String::format("Entfernung: %6d cm", lastDistance));
}
 80a099e:	b017      	add	sp, #92	; 0x5c
 80a09a0:	bd30      	pop	{r4, r5, pc}
 80a09a2:	bf00      	nop
 80a09a4:	200004fc 	.word	0x200004fc
 80a09a8:	080a64e0 	.word	0x080a64e0
 80a09ac:	080a6509 	.word	0x080a6509
 80a09b0:	20000570 	.word	0x20000570
 80a09b4:	080a6511 	.word	0x080a6511
 80a09b8:	080a6513 	.word	0x080a6513
 80a09bc:	080a6a47 	.word	0x080a6a47
 80a09c0:	20000300 	.word	0x20000300
 80a09c4:	080a6526 	.word	0x080a6526
 80a09c8:	20000304 	.word	0x20000304
 80a09cc:	080a6538 	.word	0x080a6538
 80a09d0:	080a654e 	.word	0x080a654e
 80a09d4:	080a6565 	.word	0x080a6565
 80a09d8:	20000594 	.word	0x20000594
 80a09dc:	080a6578 	.word	0x080a6578
 80a09e0:	080a658c 	.word	0x080a658c
 80a09e4:	080a65a3 	.word	0x080a65a3
 80a09e8:	080a65ba 	.word	0x080a65ba
 80a09ec:	20000305 	.word	0x20000305
 80a09f0:	080a64d5 	.word	0x080a64d5
 80a09f4:	080a64da 	.word	0x080a64da
 80a09f8:	080a65d0 	.word	0x080a65d0
 80a09fc:	200004fb 	.word	0x200004fb
 80a0a00:	080a65e3 	.word	0x080a65e3

080a0a04 <_Z12loadSettingsv>:
    saveSettings();
    return dispMode;
}

void loadSettings()
{
 80a0a04:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    int address = 1;

    brightness = EEPROM.read(address++);
 80a0a06:	f004 faf9 	bl	80a4ffc <_Z21__fetch_global_EEPROMv>
 80a0a0a:	2001      	movs	r0, #1
 80a0a0c:	f7ff fd3e 	bl	80a048c <_ZN11EEPROMClass4readEi.isra.8>
 80a0a10:	4b27      	ldr	r3, [pc, #156]	; (80a0ab0 <_Z12loadSettingsv+0xac>)
    dispMode = EEPROM.read(address++);
    fg_color.r = EEPROM.read(address++);
 80a0a12:	4c28      	ldr	r4, [pc, #160]	; (80a0ab4 <_Z12loadSettingsv+0xb0>)

void loadSettings()
{
    int address = 1;

    brightness = EEPROM.read(address++);
 80a0a14:	7018      	strb	r0, [r3, #0]
    dispMode = EEPROM.read(address++);
 80a0a16:	f004 faf1 	bl	80a4ffc <_Z21__fetch_global_EEPROMv>
 80a0a1a:	2002      	movs	r0, #2
 80a0a1c:	f7ff fd36 	bl	80a048c <_ZN11EEPROMClass4readEi.isra.8>
 80a0a20:	4b25      	ldr	r3, [pc, #148]	; (80a0ab8 <_Z12loadSettingsv+0xb4>)
    fg_color.g = EEPROM.read(address++);
    fg_color.b = EEPROM.read(address++);
    bg_color.r = EEPROM.read(address++);
    bg_color.g = EEPROM.read(address++);
    bg_color.b = EEPROM.read(address++);
    displayEnabled = EEPROM.read(address++);
 80a0a22:	250a      	movs	r5, #10
void loadSettings()
{
    int address = 1;

    brightness = EEPROM.read(address++);
    dispMode = EEPROM.read(address++);
 80a0a24:	6018      	str	r0, [r3, #0]
    fg_color.r = EEPROM.read(address++);
 80a0a26:	f004 fae9 	bl	80a4ffc <_Z21__fetch_global_EEPROMv>
 80a0a2a:	2003      	movs	r0, #3
 80a0a2c:	f7ff fd2e 	bl	80a048c <_ZN11EEPROMClass4readEi.isra.8>
 80a0a30:	7020      	strb	r0, [r4, #0]
    fg_color.g = EEPROM.read(address++);
 80a0a32:	f004 fae3 	bl	80a4ffc <_Z21__fetch_global_EEPROMv>
 80a0a36:	2004      	movs	r0, #4
 80a0a38:	f7ff fd28 	bl	80a048c <_ZN11EEPROMClass4readEi.isra.8>
 80a0a3c:	7060      	strb	r0, [r4, #1]
    fg_color.b = EEPROM.read(address++);
 80a0a3e:	f004 fadd 	bl	80a4ffc <_Z21__fetch_global_EEPROMv>
 80a0a42:	2005      	movs	r0, #5
 80a0a44:	f7ff fd22 	bl	80a048c <_ZN11EEPROMClass4readEi.isra.8>
 80a0a48:	70a0      	strb	r0, [r4, #2]
    bg_color.r = EEPROM.read(address++);
 80a0a4a:	f004 fad7 	bl	80a4ffc <_Z21__fetch_global_EEPROMv>
 80a0a4e:	2006      	movs	r0, #6
 80a0a50:	f7ff fd1c 	bl	80a048c <_ZN11EEPROMClass4readEi.isra.8>
 80a0a54:	4c19      	ldr	r4, [pc, #100]	; (80a0abc <_Z12loadSettingsv+0xb8>)
    }

    // allow assignment from 32-bit (really 24-bit) 0xRRGGBB color code
	inline CRGB& operator= (const uint32_t colorcode) __attribute__((always_inline))
    {
        r = (colorcode >> 16) & 0xFF;
 80a0a56:	2600      	movs	r6, #0
 80a0a58:	7020      	strb	r0, [r4, #0]
    bg_color.g = EEPROM.read(address++);
 80a0a5a:	f004 facf 	bl	80a4ffc <_Z21__fetch_global_EEPROMv>
 80a0a5e:	2007      	movs	r0, #7
 80a0a60:	f7ff fd14 	bl	80a048c <_ZN11EEPROMClass4readEi.isra.8>
 80a0a64:	7060      	strb	r0, [r4, #1]
    bg_color.b = EEPROM.read(address++);
 80a0a66:	f004 fac9 	bl	80a4ffc <_Z21__fetch_global_EEPROMv>
 80a0a6a:	2008      	movs	r0, #8
 80a0a6c:	f7ff fd0e 	bl	80a048c <_ZN11EEPROMClass4readEi.isra.8>
 80a0a70:	70a0      	strb	r0, [r4, #2]
    displayEnabled = EEPROM.read(address++);
 80a0a72:	f004 fac3 	bl	80a4ffc <_Z21__fetch_global_EEPROMv>
 80a0a76:	2009      	movs	r0, #9
 80a0a78:	f7ff fd08 	bl	80a048c <_ZN11EEPROMClass4readEi.isra.8>
 80a0a7c:	4b10      	ldr	r3, [pc, #64]	; (80a0ac0 <_Z12loadSettingsv+0xbc>)
 80a0a7e:	3000      	adds	r0, #0
 80a0a80:	bf18      	it	ne
 80a0a82:	2001      	movne	r0, #1
 80a0a84:	7018      	strb	r0, [r3, #0]

    maxDistance = getDistance();
 80a0a86:	f001 fd59 	bl	80a253c <_Z11getDistancev>
 80a0a8a:	4b0e      	ldr	r3, [pc, #56]	; (80a0ac4 <_Z12loadSettingsv+0xc0>)
 80a0a8c:	4c0e      	ldr	r4, [pc, #56]	; (80a0ac8 <_Z12loadSettingsv+0xc4>)
 80a0a8e:	8018      	strh	r0, [r3, #0]

    for (int i = 0; i < NUM_LEDS; i++) {
        leds[i] = EEPROM.read(address++);
 80a0a90:	f004 fab4 	bl	80a4ffc <_Z21__fetch_global_EEPROMv>
 80a0a94:	4628      	mov	r0, r5
 80a0a96:	f7ff fcf9 	bl	80a048c <_ZN11EEPROMClass4readEi.isra.8>
 80a0a9a:	1c6f      	adds	r7, r5, #1
    bg_color.b = EEPROM.read(address++);
    displayEnabled = EEPROM.read(address++);

    maxDistance = getDistance();

    for (int i = 0; i < NUM_LEDS; i++) {
 80a0a9c:	2f76      	cmp	r7, #118	; 0x76
 80a0a9e:	f804 6c01 	strb.w	r6, [r4, #-1]
        g = (colorcode >>  8) & 0xFF;
 80a0aa2:	7026      	strb	r6, [r4, #0]
        b = (colorcode >>  0) & 0xFF;
 80a0aa4:	7060      	strb	r0, [r4, #1]
 80a0aa6:	463d      	mov	r5, r7
 80a0aa8:	f104 0403 	add.w	r4, r4, #3
 80a0aac:	d1f0      	bne.n	80a0a90 <_Z12loadSettingsv+0x8c>
        leds[i] = EEPROM.read(address++);
    }
}
 80a0aae:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80a0ab0:	20000304 	.word	0x20000304
 80a0ab4:	20000590 	.word	0x20000590
 80a0ab8:	20000300 	.word	0x20000300
 80a0abc:	200004f8 	.word	0x200004f8
 80a0ac0:	20000305 	.word	0x20000305
 80a0ac4:	20000594 	.word	0x20000594
 80a0ac8:	200003b5 	.word	0x200003b5

080a0acc <_Z12saveSettingsv>:

    Particle.publish("Entfernung", String::format("Entfernung: %6d cm", lastDistance));
}

void saveSettings()
{
 80a0acc:	b570      	push	{r4, r5, r6, lr}
    int address = 1;

    EEPROM.write(address++, brightness);
 80a0ace:	f004 fa95 	bl	80a4ffc <_Z21__fetch_global_EEPROMv>
 80a0ad2:	4b29      	ldr	r3, [pc, #164]	; (80a0b78 <_Z12saveSettingsv+0xac>)
 80a0ad4:	2001      	movs	r0, #1
 80a0ad6:	7819      	ldrb	r1, [r3, #0]
 80a0ad8:	f7ff fcda 	bl	80a0490 <_ZN11EEPROMClass5writeEih.isra.9>
    EEPROM.write(address++, dispMode);
 80a0adc:	f004 fa8e 	bl	80a4ffc <_Z21__fetch_global_EEPROMv>
 80a0ae0:	4b26      	ldr	r3, [pc, #152]	; (80a0b7c <_Z12saveSettingsv+0xb0>)
    EEPROM.write(address++, fg_color.r);
 80a0ae2:	4c27      	ldr	r4, [pc, #156]	; (80a0b80 <_Z12saveSettingsv+0xb4>)
void saveSettings()
{
    int address = 1;

    EEPROM.write(address++, brightness);
    EEPROM.write(address++, dispMode);
 80a0ae4:	7819      	ldrb	r1, [r3, #0]
 80a0ae6:	2002      	movs	r0, #2
 80a0ae8:	f7ff fcd2 	bl	80a0490 <_ZN11EEPROMClass5writeEih.isra.9>
    EEPROM.write(address++, fg_color.r);
 80a0aec:	f004 fa86 	bl	80a4ffc <_Z21__fetch_global_EEPROMv>
 80a0af0:	7821      	ldrb	r1, [r4, #0]
 80a0af2:	2003      	movs	r0, #3
 80a0af4:	f7ff fccc 	bl	80a0490 <_ZN11EEPROMClass5writeEih.isra.9>
    EEPROM.write(address++, fg_color.g);
 80a0af8:	f004 fa80 	bl	80a4ffc <_Z21__fetch_global_EEPROMv>
 80a0afc:	7861      	ldrb	r1, [r4, #1]
 80a0afe:	2004      	movs	r0, #4
 80a0b00:	f7ff fcc6 	bl	80a0490 <_ZN11EEPROMClass5writeEih.isra.9>
    EEPROM.write(address++, fg_color.b);
 80a0b04:	f004 fa7a 	bl	80a4ffc <_Z21__fetch_global_EEPROMv>
 80a0b08:	78a1      	ldrb	r1, [r4, #2]
    EEPROM.write(address++, bg_color.r);
 80a0b0a:	4c1e      	ldr	r4, [pc, #120]	; (80a0b84 <_Z12saveSettingsv+0xb8>)

    EEPROM.write(address++, brightness);
    EEPROM.write(address++, dispMode);
    EEPROM.write(address++, fg_color.r);
    EEPROM.write(address++, fg_color.g);
    EEPROM.write(address++, fg_color.b);
 80a0b0c:	2005      	movs	r0, #5
 80a0b0e:	f7ff fcbf 	bl	80a0490 <_ZN11EEPROMClass5writeEih.isra.9>
    EEPROM.write(address++, bg_color.r);
 80a0b12:	f004 fa73 	bl	80a4ffc <_Z21__fetch_global_EEPROMv>
 80a0b16:	7821      	ldrb	r1, [r4, #0]
 80a0b18:	2006      	movs	r0, #6
 80a0b1a:	f7ff fcb9 	bl	80a0490 <_ZN11EEPROMClass5writeEih.isra.9>
    EEPROM.write(address++, bg_color.g);
 80a0b1e:	f004 fa6d 	bl	80a4ffc <_Z21__fetch_global_EEPROMv>
 80a0b22:	7861      	ldrb	r1, [r4, #1]
 80a0b24:	2007      	movs	r0, #7
 80a0b26:	f7ff fcb3 	bl	80a0490 <_ZN11EEPROMClass5writeEih.isra.9>
    EEPROM.write(address++, bg_color.b);
 80a0b2a:	f004 fa67 	bl	80a4ffc <_Z21__fetch_global_EEPROMv>
 80a0b2e:	78a1      	ldrb	r1, [r4, #2]
 80a0b30:	2008      	movs	r0, #8
 80a0b32:	f7ff fcad 	bl	80a0490 <_ZN11EEPROMClass5writeEih.isra.9>
    EEPROM.write(address++, displayEnabled);
 80a0b36:	f004 fa61 	bl	80a4ffc <_Z21__fetch_global_EEPROMv>
 80a0b3a:	4b13      	ldr	r3, [pc, #76]	; (80a0b88 <_Z12saveSettingsv+0xbc>)
 80a0b3c:	2009      	movs	r0, #9
 80a0b3e:	7819      	ldrb	r1, [r3, #0]
 80a0b40:	f7ff fca6 	bl	80a0490 <_ZN11EEPROMClass5writeEih.isra.9>
 80a0b44:	4c11      	ldr	r4, [pc, #68]	; (80a0b8c <_Z12saveSettingsv+0xc0>)
 80a0b46:	250a      	movs	r5, #10

    for (int i = 0; i < NUM_LEDS; i++) {
        EEPROM.write(address++, leds[i]);
 80a0b48:	f004 fa58 	bl	80a4ffc <_Z21__fetch_global_EEPROMv>
    }

    // this allows testing a CRGB for zero-ness
    inline operator bool() const __attribute__((always_inline))
    {
        return r || g || b;
 80a0b4c:	f814 3c01 	ldrb.w	r3, [r4, #-1]
 80a0b50:	1c6e      	adds	r6, r5, #1
 80a0b52:	b933      	cbnz	r3, 80a0b62 <_Z12saveSettingsv+0x96>
 80a0b54:	7823      	ldrb	r3, [r4, #0]
 80a0b56:	b923      	cbnz	r3, 80a0b62 <_Z12saveSettingsv+0x96>
 80a0b58:	7861      	ldrb	r1, [r4, #1]
 80a0b5a:	3100      	adds	r1, #0
 80a0b5c:	bf18      	it	ne
 80a0b5e:	2101      	movne	r1, #1
 80a0b60:	e000      	b.n	80a0b64 <_Z12saveSettingsv+0x98>
 80a0b62:	2101      	movs	r1, #1
 80a0b64:	4628      	mov	r0, r5
 80a0b66:	f7ff fc93 	bl	80a0490 <_ZN11EEPROMClass5writeEih.isra.9>
    EEPROM.write(address++, bg_color.r);
    EEPROM.write(address++, bg_color.g);
    EEPROM.write(address++, bg_color.b);
    EEPROM.write(address++, displayEnabled);

    for (int i = 0; i < NUM_LEDS; i++) {
 80a0b6a:	2e76      	cmp	r6, #118	; 0x76
 80a0b6c:	f104 0403 	add.w	r4, r4, #3
 80a0b70:	4635      	mov	r5, r6
 80a0b72:	d1e9      	bne.n	80a0b48 <_Z12saveSettingsv+0x7c>
        EEPROM.write(address++, leds[i]);
    }
}
 80a0b74:	bd70      	pop	{r4, r5, r6, pc}
 80a0b76:	bf00      	nop
 80a0b78:	20000304 	.word	0x20000304
 80a0b7c:	20000300 	.word	0x20000300
 80a0b80:	20000590 	.word	0x20000590
 80a0b84:	200004f8 	.word	0x200004f8
 80a0b88:	20000305 	.word	0x20000305
 80a0b8c:	200003b5 	.word	0x200003b5

080a0b90 <_Z13setBrightness6String>:

    lastDistance = currentDistance;
}

int setBrightness(String value)
{
 80a0b90:	b510      	push	{r4, lr}
    brightness = atoi(value);
 80a0b92:	6800      	ldr	r0, [r0, #0]
 80a0b94:	f005 fae8 	bl	80a6168 <atoi>
	//@}
#endif

	/// Set the global brightness scaling
	/// @param scale a 0-255 value for how much to scale all leds before writing them out
	void setBrightness(uint8_t scale) { m_Scale = scale; }
 80a0b98:	4b04      	ldr	r3, [pc, #16]	; (80a0bac <_Z13setBrightness6String+0x1c>)
 80a0b9a:	b2c0      	uxtb	r0, r0
 80a0b9c:	4c04      	ldr	r4, [pc, #16]	; (80a0bb0 <_Z13setBrightness6String+0x20>)
 80a0b9e:	7018      	strb	r0, [r3, #0]
 80a0ba0:	7020      	strb	r0, [r4, #0]
    FastLED.setBrightness(brightness);

    saveSettings();
 80a0ba2:	f7ff ff93 	bl	80a0acc <_Z12saveSettingsv>
    return brightness;
}
 80a0ba6:	7820      	ldrb	r0, [r4, #0]
 80a0ba8:	bd10      	pop	{r4, pc}
 80a0baa:	bf00      	nop
 80a0bac:	200008ec 	.word	0x200008ec
 80a0bb0:	20000304 	.word	0x20000304

080a0bb4 <_Z23setBrightnessByDistancev>:
{
    return brightness;
}

void setBrightnessByDistance()
{
 80a0bb4:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    uint16_t currentDistance = getDistance();
 80a0bb6:	f001 fcc1 	bl	80a253c <_Z11getDistancev>

    if ((currentDistance >=5) && (currentDistance <=29))
 80a0bba:	1f43      	subs	r3, r0, #5
 80a0bbc:	b29b      	uxth	r3, r3
 80a0bbe:	2b18      	cmp	r3, #24
    return brightness;
}

void setBrightnessByDistance()
{
    uint16_t currentDistance = getDistance();
 80a0bc0:	4604      	mov	r4, r0

    if ((currentDistance >=5) && (currentDistance <=29))
 80a0bc2:	d80b      	bhi.n	80a0bdc <_Z23setBrightnessByDistancev+0x28>
    {
        setBrightness(String((currentDistance - 4) * 10));
 80a0bc4:	220a      	movs	r2, #10
 80a0bc6:	1f01      	subs	r1, r0, #4
 80a0bc8:	4351      	muls	r1, r2
 80a0bca:	4668      	mov	r0, sp
 80a0bcc:	f004 f92c 	bl	80a4e28 <_ZN6StringC1Eih>
 80a0bd0:	4668      	mov	r0, sp
 80a0bd2:	f7ff ffdd 	bl	80a0b90 <_Z13setBrightness6String>
 80a0bd6:	4668      	mov	r0, sp
 80a0bd8:	f004 f8bb 	bl	80a4d52 <_ZN6StringD1Ev>
    }

    lastDistance = currentDistance;
 80a0bdc:	4b01      	ldr	r3, [pc, #4]	; (80a0be4 <_Z23setBrightnessByDistancev+0x30>)
 80a0bde:	801c      	strh	r4, [r3, #0]
}
 80a0be0:	b004      	add	sp, #16
 80a0be2:	bd10      	pop	{r4, pc}
 80a0be4:	20000570 	.word	0x20000570

080a0be8 <_Z10setFgColor6String>:
{
    return String::format("%0.3d,%0.3d,%0.3d", fg_color.red, fg_color.green, fg_color.blue);
}

int setFgColor(String command)
{
 80a0be8:	b537      	push	{r0, r1, r2, r4, r5, lr}
 80a0bea:	4604      	mov	r4, r0
    char *rgbstr = (char *) malloc(command.length() + 1);
 80a0bec:	6880      	ldr	r0, [r0, #8]
 80a0bee:	3001      	adds	r0, #1
 80a0bf0:	f002 ff4a 	bl	80a3a88 <malloc>

    rgbstr = strcpy(rgbstr, (const char *) command);
 80a0bf4:	6821      	ldr	r1, [r4, #0]
    return String::format("%0.3d,%0.3d,%0.3d", fg_color.red, fg_color.green, fg_color.blue);
}

int setFgColor(String command)
{
    char *rgbstr = (char *) malloc(command.length() + 1);
 80a0bf6:	9001      	str	r0, [sp, #4]

    rgbstr = strcpy(rgbstr, (const char *) command);
 80a0bf8:	f005 fb48 	bl	80a628c <strcpy>

    if (command.length() == 11) {
 80a0bfc:	68a3      	ldr	r3, [r4, #8]

int setFgColor(String command)
{
    char *rgbstr = (char *) malloc(command.length() + 1);

    rgbstr = strcpy(rgbstr, (const char *) command);
 80a0bfe:	9001      	str	r0, [sp, #4]

    if (command.length() == 11) {
 80a0c00:	2b0b      	cmp	r3, #11
 80a0c02:	d117      	bne.n	80a0c34 <_Z10setFgColor6String+0x4c>
        int r = atoi(strsep(&rgbstr, ","));
 80a0c04:	490f      	ldr	r1, [pc, #60]	; (80a0c44 <_Z10setFgColor6String+0x5c>)
 80a0c06:	a801      	add	r0, sp, #4
 80a0c08:	f005 fb6b 	bl	80a62e2 <strsep>
 80a0c0c:	f005 faac 	bl	80a6168 <atoi>
        int g = atoi(strsep(&rgbstr, ","));
 80a0c10:	490c      	ldr	r1, [pc, #48]	; (80a0c44 <_Z10setFgColor6String+0x5c>)
    char *rgbstr = (char *) malloc(command.length() + 1);

    rgbstr = strcpy(rgbstr, (const char *) command);

    if (command.length() == 11) {
        int r = atoi(strsep(&rgbstr, ","));
 80a0c12:	4605      	mov	r5, r0
        int g = atoi(strsep(&rgbstr, ","));
 80a0c14:	a801      	add	r0, sp, #4
 80a0c16:	f005 fb64 	bl	80a62e2 <strsep>
 80a0c1a:	f005 faa5 	bl	80a6168 <atoi>
        int b = atoi(strsep(&rgbstr, ","));
 80a0c1e:	4909      	ldr	r1, [pc, #36]	; (80a0c44 <_Z10setFgColor6String+0x5c>)

    rgbstr = strcpy(rgbstr, (const char *) command);

    if (command.length() == 11) {
        int r = atoi(strsep(&rgbstr, ","));
        int g = atoi(strsep(&rgbstr, ","));
 80a0c20:	4604      	mov	r4, r0
        int b = atoi(strsep(&rgbstr, ","));
 80a0c22:	a801      	add	r0, sp, #4
 80a0c24:	f005 fb5d 	bl	80a62e2 <strsep>
 80a0c28:	f005 fa9e 	bl	80a6168 <atoi>
    }

    // allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
 80a0c2c:	4b06      	ldr	r3, [pc, #24]	; (80a0c48 <_Z10setFgColor6String+0x60>)
 80a0c2e:	701d      	strb	r5, [r3, #0]
        g = rhs.g;
 80a0c30:	705c      	strb	r4, [r3, #1]
        b = rhs.b;
 80a0c32:	7098      	strb	r0, [r3, #2]

        fg_color = CRGB(r, g, b);
    }

    free(rgbstr);
 80a0c34:	9801      	ldr	r0, [sp, #4]
 80a0c36:	f002 ff2f 	bl	80a3a98 <free>

    saveSettings();
 80a0c3a:	f7ff ff47 	bl	80a0acc <_Z12saveSettingsv>
    return 1;
}
 80a0c3e:	2001      	movs	r0, #1
 80a0c40:	b003      	add	sp, #12
 80a0c42:	bd30      	pop	{r4, r5, pc}
 80a0c44:	080a65ee 	.word	0x080a65ee
 80a0c48:	20000590 	.word	0x20000590

080a0c4c <_Z10setBgColor6String>:
{
    return String::format("%0.3d,%0.3d,%0.3d", bg_color.red, bg_color.green, bg_color.blue);
}

int setBgColor(String command)
{
 80a0c4c:	b537      	push	{r0, r1, r2, r4, r5, lr}
 80a0c4e:	4604      	mov	r4, r0
    char *rgbstr = (char *) malloc(command.length() + 1);
 80a0c50:	6880      	ldr	r0, [r0, #8]
 80a0c52:	3001      	adds	r0, #1
 80a0c54:	f002 ff18 	bl	80a3a88 <malloc>

    rgbstr = strcpy(rgbstr, (const char *) command);
 80a0c58:	6821      	ldr	r1, [r4, #0]
    return String::format("%0.3d,%0.3d,%0.3d", bg_color.red, bg_color.green, bg_color.blue);
}

int setBgColor(String command)
{
    char *rgbstr = (char *) malloc(command.length() + 1);
 80a0c5a:	9001      	str	r0, [sp, #4]

    rgbstr = strcpy(rgbstr, (const char *) command);
 80a0c5c:	f005 fb16 	bl	80a628c <strcpy>

    if (command.length() == 11) {
 80a0c60:	68a3      	ldr	r3, [r4, #8]

int setBgColor(String command)
{
    char *rgbstr = (char *) malloc(command.length() + 1);

    rgbstr = strcpy(rgbstr, (const char *) command);
 80a0c62:	9001      	str	r0, [sp, #4]

    if (command.length() == 11) {
 80a0c64:	2b0b      	cmp	r3, #11
 80a0c66:	d117      	bne.n	80a0c98 <_Z10setBgColor6String+0x4c>
        int r = atoi(strsep(&rgbstr, ","));
 80a0c68:	490f      	ldr	r1, [pc, #60]	; (80a0ca8 <_Z10setBgColor6String+0x5c>)
 80a0c6a:	a801      	add	r0, sp, #4
 80a0c6c:	f005 fb39 	bl	80a62e2 <strsep>
 80a0c70:	f005 fa7a 	bl	80a6168 <atoi>
        int g = atoi(strsep(&rgbstr, ","));
 80a0c74:	490c      	ldr	r1, [pc, #48]	; (80a0ca8 <_Z10setBgColor6String+0x5c>)
    char *rgbstr = (char *) malloc(command.length() + 1);

    rgbstr = strcpy(rgbstr, (const char *) command);

    if (command.length() == 11) {
        int r = atoi(strsep(&rgbstr, ","));
 80a0c76:	4605      	mov	r5, r0
        int g = atoi(strsep(&rgbstr, ","));
 80a0c78:	a801      	add	r0, sp, #4
 80a0c7a:	f005 fb32 	bl	80a62e2 <strsep>
 80a0c7e:	f005 fa73 	bl	80a6168 <atoi>
        int b = atoi(strsep(&rgbstr, ","));
 80a0c82:	4909      	ldr	r1, [pc, #36]	; (80a0ca8 <_Z10setBgColor6String+0x5c>)

    rgbstr = strcpy(rgbstr, (const char *) command);

    if (command.length() == 11) {
        int r = atoi(strsep(&rgbstr, ","));
        int g = atoi(strsep(&rgbstr, ","));
 80a0c84:	4604      	mov	r4, r0
        int b = atoi(strsep(&rgbstr, ","));
 80a0c86:	a801      	add	r0, sp, #4
 80a0c88:	f005 fb2b 	bl	80a62e2 <strsep>
 80a0c8c:	f005 fa6c 	bl	80a6168 <atoi>
    }

    // allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
 80a0c90:	4b06      	ldr	r3, [pc, #24]	; (80a0cac <_Z10setBgColor6String+0x60>)
 80a0c92:	701d      	strb	r5, [r3, #0]
        g = rhs.g;
 80a0c94:	705c      	strb	r4, [r3, #1]
        b = rhs.b;
 80a0c96:	7098      	strb	r0, [r3, #2]

        bg_color = CRGB(r, g, b);
    }

    free(rgbstr);
 80a0c98:	9801      	ldr	r0, [sp, #4]
 80a0c9a:	f002 fefd 	bl	80a3a98 <free>

    saveSettings();
 80a0c9e:	f7ff ff15 	bl	80a0acc <_Z12saveSettingsv>
    return 1;
}
 80a0ca2:	2001      	movs	r0, #1
 80a0ca4:	b003      	add	sp, #12
 80a0ca6:	bd30      	pop	{r4, r5, pc}
 80a0ca8:	080a65ee 	.word	0x080a65ee
 80a0cac:	200004f8 	.word	0x200004f8

080a0cb0 <_Z14setDisplayMode6String>:
{
    return dispMode;
}

int setDisplayMode(String command)
{
 80a0cb0:	b510      	push	{r4, lr}
    dispMode = atoi(command);
 80a0cb2:	6800      	ldr	r0, [r0, #0]
 80a0cb4:	f005 fa58 	bl	80a6168 <atoi>
 80a0cb8:	4b18      	ldr	r3, [pc, #96]	; (80a0d1c <_Z14setDisplayMode6String+0x6c>)
 80a0cba:	6018      	str	r0, [r3, #0]

    switch (dispMode) {
 80a0cbc:	3801      	subs	r0, #1
 80a0cbe:	461c      	mov	r4, r3
 80a0cc0:	280a      	cmp	r0, #10
 80a0cc2:	d827      	bhi.n	80a0d14 <_Z14setDisplayMode6String+0x64>
 80a0cc4:	e8df f000 	tbb	[pc, r0]
 80a0cc8:	0f0c0906 	.word	0x0f0c0906
 80a0ccc:	1b181512 	.word	0x1b181512
 80a0cd0:	211e      	.short	0x211e
 80a0cd2:	24          	.byte	0x24
 80a0cd3:	00          	.byte	0x00
    case 1:
        setupNoise();
 80a0cd4:	f001 f82a 	bl	80a1d2c <_Z10setupNoisev>
        break;
 80a0cd8:	e01c      	b.n	80a0d14 <_Z14setDisplayMode6String+0x64>
    case 2:
        setupRainbowCycle();
 80a0cda:	f7ff fb11 	bl	80a0300 <_Z17setupRainbowCyclev>
        break;
 80a0cde:	e019      	b.n	80a0d14 <_Z14setDisplayMode6String+0x64>
    case 3:
        setupNoisePlusPalette();
 80a0ce0:	f000 fe48 	bl	80a1974 <_Z21setupNoisePlusPalettev>
        break;
 80a0ce4:	e016      	b.n	80a0d14 <_Z14setDisplayMode6String+0x64>
    case 4:
        setupSingleColor();
 80a0ce6:	f000 fd0f 	bl	80a1708 <_Z16setupSingleColorv>
        break;
 80a0cea:	e013      	b.n	80a0d14 <_Z14setDisplayMode6String+0x64>
    case 5:
        setupCylon();
 80a0cec:	f7ff f9e6 	bl	80a00bc <_Z10setupCylonv>
        break;
 80a0cf0:	e010      	b.n	80a0d14 <_Z14setDisplayMode6String+0x64>
    case 6:
        setupRainSnow();
 80a0cf2:	f001 fab9 	bl	80a2268 <_Z13setupRainSnowv>
        break;
 80a0cf6:	e00d      	b.n	80a0d14 <_Z14setDisplayMode6String+0x64>
    case 7:
        setupFire();
 80a0cf8:	f001 f876 	bl	80a1de8 <_Z9setupFirev>
        break;
 80a0cfc:	e00a      	b.n	80a0d14 <_Z14setDisplayMode6String+0x64>
    case 8:
        setupHorizontalSplit();
 80a0cfe:	f7ff fafb 	bl	80a02f8 <_Z20setupHorizontalSplitv>
        break;
 80a0d02:	e007      	b.n	80a0d14 <_Z14setDisplayMode6String+0x64>
    case 9:
        setupHorizontalDoubleSplit();
 80a0d04:	f001 faac 	bl	80a2260 <_Z26setupHorizontalDoubleSplitv>
        break;
 80a0d08:	e004      	b.n	80a0d14 <_Z14setDisplayMode6String+0x64>
    case 10:
        setupVerticalSplit();
 80a0d0a:	f001 fa47 	bl	80a219c <_Z18setupVerticalSplitv>
        break;
 80a0d0e:	e001      	b.n	80a0d14 <_Z14setDisplayMode6String+0x64>
    case 11:
        setupSpiral();
 80a0d10:	f001 f992 	bl	80a2038 <_Z11setupSpiralv>
        break;
    default:
        break;
    }

    saveSettings();
 80a0d14:	f7ff feda 	bl	80a0acc <_Z12saveSettingsv>
    return dispMode;
}
 80a0d18:	6820      	ldr	r0, [r4, #0]
 80a0d1a:	bd10      	pop	{r4, pc}
 80a0d1c:	20000300 	.word	0x20000300

080a0d20 <_Z13mqtt_callbackPcPhj>:
// 11: Spiral

int dispMode = 1;

void mqtt_callback(char *topic, byte *payload, unsigned int length)
{
 80a0d20:	b570      	push	{r4, r5, r6, lr}
 80a0d22:	4615      	mov	r5, r2
 80a0d24:	b094      	sub	sp, #80	; 0x50
 80a0d26:	460e      	mov	r6, r1
    // handle message arrived - we are only subscribing to one topic so assume all are led related

    String myTopic = String(topic);
 80a0d28:	4601      	mov	r1, r0
 80a0d2a:	4668      	mov	r0, sp
 80a0d2c:	f004 f858 	bl	80a4de0 <_ZN6StringC1EPK19__FlashStringHelper>

    bool stateChanged = false;

    char *myPayload = (char *) malloc(length + 1);
 80a0d30:	1c68      	adds	r0, r5, #1
 80a0d32:	f002 fea9 	bl	80a3a88 <malloc>
 80a0d36:	4604      	mov	r4, r0

    memcpy(myPayload, payload, length);
 80a0d38:	462a      	mov	r2, r5
 80a0d3a:	4631      	mov	r1, r6
 80a0d3c:	f005 fa26 	bl	80a618c <memcpy>
    myPayload[length] = 0;
 80a0d40:	2300      	movs	r3, #0
    }
    inline static SleepResult sleep(const pin_t* pins, size_t pinsSize, const InterruptMode* edgeTriggerMode, size_t edgeTriggerModeSize, SleepOptionFlags flag, long seconds = 0) {
        return sleep(pins, pinsSize, edgeTriggerMode, edgeTriggerModeSize, seconds, flag);
    }

    static String deviceID(void) { return spark_deviceID(); }
 80a0d42:	a804      	add	r0, sp, #16
 80a0d44:	5563      	strb	r3, [r4, r5]
 80a0d46:	f002 fe3b 	bl	80a39c0 <spark_deviceID>

    String myID = System.deviceID();

    if (!client.isConnected()) {
 80a0d4a:	487f      	ldr	r0, [pc, #508]	; (80a0f48 <_Z13mqtt_callbackPcPhj+0x228>)
 80a0d4c:	f002 f94d 	bl	80a2fea <_ZN4MQTT11isConnectedEv>
 80a0d50:	b928      	cbnz	r0, 80a0d5e <_Z13mqtt_callbackPcPhj+0x3e>
        client.connect(myID, MQTT_USER, MQTT_PASSWORD);
 80a0d52:	4b7e      	ldr	r3, [pc, #504]	; (80a0f4c <_Z13mqtt_callbackPcPhj+0x22c>)
 80a0d54:	4a7e      	ldr	r2, [pc, #504]	; (80a0f50 <_Z13mqtt_callbackPcPhj+0x230>)
 80a0d56:	9904      	ldr	r1, [sp, #16]
 80a0d58:	487b      	ldr	r0, [pc, #492]	; (80a0f48 <_Z13mqtt_callbackPcPhj+0x228>)
 80a0d5a:	f002 fa2b 	bl	80a31b4 <_ZN4MQTT7connectEPKcS1_S1_>
{
public:
	StringSumHelper(const String &s) : String(s) {}
	StringSumHelper(const char *p) : String(p) {}
 80a0d5e:	497d      	ldr	r1, [pc, #500]	; (80a0f54 <_Z13mqtt_callbackPcPhj+0x234>)
 80a0d60:	a808      	add	r0, sp, #32
 80a0d62:	f004 f83d 	bl	80a4de0 <_ZN6StringC1EPK19__FlashStringHelper>
    }

    client.publish("/"+myID+"/state/LastPayload", "Last Payload: " + String(myPayload));
 80a0d66:	a904      	add	r1, sp, #16
 80a0d68:	a808      	add	r0, sp, #32
 80a0d6a:	f004 f887 	bl	80a4e7c <_ZplRK15StringSumHelperRK6String>
 80a0d6e:	497a      	ldr	r1, [pc, #488]	; (80a0f58 <_Z13mqtt_callbackPcPhj+0x238>)
 80a0d70:	f004 f890 	bl	80a4e94 <_ZplRK15StringSumHelperPKc>
 80a0d74:	4979      	ldr	r1, [pc, #484]	; (80a0f5c <_Z13mqtt_callbackPcPhj+0x23c>)
 80a0d76:	6805      	ldr	r5, [r0, #0]
 80a0d78:	a810      	add	r0, sp, #64	; 0x40
 80a0d7a:	f004 f831 	bl	80a4de0 <_ZN6StringC1EPK19__FlashStringHelper>
 80a0d7e:	4621      	mov	r1, r4
 80a0d80:	a80c      	add	r0, sp, #48	; 0x30
 80a0d82:	f004 f82d 	bl	80a4de0 <_ZN6StringC1EPK19__FlashStringHelper>
 80a0d86:	a90c      	add	r1, sp, #48	; 0x30
 80a0d88:	a810      	add	r0, sp, #64	; 0x40
 80a0d8a:	f004 f877 	bl	80a4e7c <_ZplRK15StringSumHelperRK6String>
 80a0d8e:	4629      	mov	r1, r5
 80a0d90:	6802      	ldr	r2, [r0, #0]
 80a0d92:	486d      	ldr	r0, [pc, #436]	; (80a0f48 <_Z13mqtt_callbackPcPhj+0x228>)
 80a0d94:	f002 fa8c 	bl	80a32b0 <_ZN4MQTT7publishEPKcS1_>
 80a0d98:	a80c      	add	r0, sp, #48	; 0x30
 80a0d9a:	f003 ffda 	bl	80a4d52 <_ZN6StringD1Ev>

        friend class StringPrintableHelper;

};

class StringSumHelper : public String
 80a0d9e:	a810      	add	r0, sp, #64	; 0x40
 80a0da0:	f003 ffd7 	bl	80a4d52 <_ZN6StringD1Ev>
 80a0da4:	a808      	add	r0, sp, #32
 80a0da6:	f003 ffd4 	bl	80a4d52 <_ZN6StringD1Ev>
{
public:
	StringSumHelper(const String &s) : String(s) {}
	StringSumHelper(const char *p) : String(p) {}
 80a0daa:	496a      	ldr	r1, [pc, #424]	; (80a0f54 <_Z13mqtt_callbackPcPhj+0x234>)
 80a0dac:	a810      	add	r0, sp, #64	; 0x40
 80a0dae:	f004 f817 	bl	80a4de0 <_ZN6StringC1EPK19__FlashStringHelper>

    if (myTopic == "/"+myID+"/set/DisplayMode") {
 80a0db2:	a904      	add	r1, sp, #16
 80a0db4:	a810      	add	r0, sp, #64	; 0x40
 80a0db6:	f004 f861 	bl	80a4e7c <_ZplRK15StringSumHelperRK6String>
 80a0dba:	4969      	ldr	r1, [pc, #420]	; (80a0f60 <_Z13mqtt_callbackPcPhj+0x240>)
 80a0dbc:	f004 f86a 	bl	80a4e94 <_ZplRK15StringSumHelperPKc>
	// comparison (only works w/ Strings and "strings")
	operator StringIfHelperType() const { return buffer ? &String::StringIfHelper : 0; }
	int compareTo(const String &s) const;
	unsigned char equals(const String &s) const;
	unsigned char equals(const char *cstr) const;
	unsigned char operator == (const String &rhs) const {return equals(rhs);}
 80a0dc0:	4601      	mov	r1, r0
 80a0dc2:	4668      	mov	r0, sp
 80a0dc4:	f004 f88e 	bl	80a4ee4 <_ZNK6String6equalsERKS_>
 80a0dc8:	4605      	mov	r5, r0

        friend class StringPrintableHelper;

};

class StringSumHelper : public String
 80a0dca:	a810      	add	r0, sp, #64	; 0x40
 80a0dcc:	f003 ffc1 	bl	80a4d52 <_ZN6StringD1Ev>
 80a0dd0:	b155      	cbz	r5, 80a0de8 <_Z13mqtt_callbackPcPhj+0xc8>
        setDisplayMode(String(myPayload));
 80a0dd2:	4621      	mov	r1, r4
 80a0dd4:	a810      	add	r0, sp, #64	; 0x40
 80a0dd6:	f004 f803 	bl	80a4de0 <_ZN6StringC1EPK19__FlashStringHelper>
 80a0dda:	a810      	add	r0, sp, #64	; 0x40
 80a0ddc:	f7ff ff68 	bl	80a0cb0 <_Z14setDisplayMode6String>
 80a0de0:	a810      	add	r0, sp, #64	; 0x40
 80a0de2:	f003 ffb6 	bl	80a4d52 <_ZN6StringD1Ev>
        stateChanged = true;
 80a0de6:	2501      	movs	r5, #1
{
public:
	StringSumHelper(const String &s) : String(s) {}
	StringSumHelper(const char *p) : String(p) {}
 80a0de8:	495a      	ldr	r1, [pc, #360]	; (80a0f54 <_Z13mqtt_callbackPcPhj+0x234>)
 80a0dea:	a810      	add	r0, sp, #64	; 0x40
 80a0dec:	f003 fff8 	bl	80a4de0 <_ZN6StringC1EPK19__FlashStringHelper>
    }

    if (myTopic == "/"+myID+"/set/Brightness") {
 80a0df0:	a904      	add	r1, sp, #16
 80a0df2:	a810      	add	r0, sp, #64	; 0x40
 80a0df4:	f004 f842 	bl	80a4e7c <_ZplRK15StringSumHelperRK6String>
 80a0df8:	495a      	ldr	r1, [pc, #360]	; (80a0f64 <_Z13mqtt_callbackPcPhj+0x244>)
 80a0dfa:	f004 f84b 	bl	80a4e94 <_ZplRK15StringSumHelperPKc>
	// comparison (only works w/ Strings and "strings")
	operator StringIfHelperType() const { return buffer ? &String::StringIfHelper : 0; }
	int compareTo(const String &s) const;
	unsigned char equals(const String &s) const;
	unsigned char equals(const char *cstr) const;
	unsigned char operator == (const String &rhs) const {return equals(rhs);}
 80a0dfe:	4601      	mov	r1, r0
 80a0e00:	4668      	mov	r0, sp
 80a0e02:	f004 f86f 	bl	80a4ee4 <_ZNK6String6equalsERKS_>
 80a0e06:	4606      	mov	r6, r0

        friend class StringPrintableHelper;

};

class StringSumHelper : public String
 80a0e08:	a810      	add	r0, sp, #64	; 0x40
 80a0e0a:	f003 ffa2 	bl	80a4d52 <_ZN6StringD1Ev>
 80a0e0e:	b156      	cbz	r6, 80a0e26 <_Z13mqtt_callbackPcPhj+0x106>
        setBrightness(String(myPayload));
 80a0e10:	4621      	mov	r1, r4
 80a0e12:	a810      	add	r0, sp, #64	; 0x40
 80a0e14:	f003 ffe4 	bl	80a4de0 <_ZN6StringC1EPK19__FlashStringHelper>
 80a0e18:	a810      	add	r0, sp, #64	; 0x40
 80a0e1a:	f7ff feb9 	bl	80a0b90 <_Z13setBrightness6String>
 80a0e1e:	a810      	add	r0, sp, #64	; 0x40
 80a0e20:	f003 ff97 	bl	80a4d52 <_ZN6StringD1Ev>
        stateChanged = true;
 80a0e24:	2501      	movs	r5, #1
{
public:
	StringSumHelper(const String &s) : String(s) {}
	StringSumHelper(const char *p) : String(p) {}
 80a0e26:	494b      	ldr	r1, [pc, #300]	; (80a0f54 <_Z13mqtt_callbackPcPhj+0x234>)
 80a0e28:	a810      	add	r0, sp, #64	; 0x40
 80a0e2a:	f003 ffd9 	bl	80a4de0 <_ZN6StringC1EPK19__FlashStringHelper>
    }

    if (myTopic == "/"+myID+"/set/ForgroundColor") {
 80a0e2e:	a904      	add	r1, sp, #16
 80a0e30:	a810      	add	r0, sp, #64	; 0x40
 80a0e32:	f004 f823 	bl	80a4e7c <_ZplRK15StringSumHelperRK6String>
 80a0e36:	494c      	ldr	r1, [pc, #304]	; (80a0f68 <_Z13mqtt_callbackPcPhj+0x248>)
 80a0e38:	f004 f82c 	bl	80a4e94 <_ZplRK15StringSumHelperPKc>
	// comparison (only works w/ Strings and "strings")
	operator StringIfHelperType() const { return buffer ? &String::StringIfHelper : 0; }
	int compareTo(const String &s) const;
	unsigned char equals(const String &s) const;
	unsigned char equals(const char *cstr) const;
	unsigned char operator == (const String &rhs) const {return equals(rhs);}
 80a0e3c:	4601      	mov	r1, r0
 80a0e3e:	4668      	mov	r0, sp
 80a0e40:	f004 f850 	bl	80a4ee4 <_ZNK6String6equalsERKS_>
 80a0e44:	4606      	mov	r6, r0

        friend class StringPrintableHelper;

};

class StringSumHelper : public String
 80a0e46:	a810      	add	r0, sp, #64	; 0x40
 80a0e48:	f003 ff83 	bl	80a4d52 <_ZN6StringD1Ev>
 80a0e4c:	b156      	cbz	r6, 80a0e64 <_Z13mqtt_callbackPcPhj+0x144>
        setFgColor(String(myPayload));
 80a0e4e:	4621      	mov	r1, r4
 80a0e50:	a810      	add	r0, sp, #64	; 0x40
 80a0e52:	f003 ffc5 	bl	80a4de0 <_ZN6StringC1EPK19__FlashStringHelper>
 80a0e56:	a810      	add	r0, sp, #64	; 0x40
 80a0e58:	f7ff fec6 	bl	80a0be8 <_Z10setFgColor6String>
 80a0e5c:	a810      	add	r0, sp, #64	; 0x40
 80a0e5e:	f003 ff78 	bl	80a4d52 <_ZN6StringD1Ev>
        stateChanged = true;
 80a0e62:	2501      	movs	r5, #1
{
public:
	StringSumHelper(const String &s) : String(s) {}
	StringSumHelper(const char *p) : String(p) {}
 80a0e64:	493b      	ldr	r1, [pc, #236]	; (80a0f54 <_Z13mqtt_callbackPcPhj+0x234>)
 80a0e66:	a810      	add	r0, sp, #64	; 0x40
 80a0e68:	f003 ffba 	bl	80a4de0 <_ZN6StringC1EPK19__FlashStringHelper>
    }

    if (myTopic == "/"+myID+"/set/BackgroundColor") {
 80a0e6c:	a904      	add	r1, sp, #16
 80a0e6e:	a810      	add	r0, sp, #64	; 0x40
 80a0e70:	f004 f804 	bl	80a4e7c <_ZplRK15StringSumHelperRK6String>
 80a0e74:	493d      	ldr	r1, [pc, #244]	; (80a0f6c <_Z13mqtt_callbackPcPhj+0x24c>)
 80a0e76:	f004 f80d 	bl	80a4e94 <_ZplRK15StringSumHelperPKc>
	// comparison (only works w/ Strings and "strings")
	operator StringIfHelperType() const { return buffer ? &String::StringIfHelper : 0; }
	int compareTo(const String &s) const;
	unsigned char equals(const String &s) const;
	unsigned char equals(const char *cstr) const;
	unsigned char operator == (const String &rhs) const {return equals(rhs);}
 80a0e7a:	4601      	mov	r1, r0
 80a0e7c:	4668      	mov	r0, sp
 80a0e7e:	f004 f831 	bl	80a4ee4 <_ZNK6String6equalsERKS_>
 80a0e82:	4606      	mov	r6, r0

        friend class StringPrintableHelper;

};

class StringSumHelper : public String
 80a0e84:	a810      	add	r0, sp, #64	; 0x40
 80a0e86:	f003 ff64 	bl	80a4d52 <_ZN6StringD1Ev>
 80a0e8a:	b156      	cbz	r6, 80a0ea2 <_Z13mqtt_callbackPcPhj+0x182>
        setBgColor(String(myPayload));
 80a0e8c:	4621      	mov	r1, r4
 80a0e8e:	a810      	add	r0, sp, #64	; 0x40
 80a0e90:	f003 ffa6 	bl	80a4de0 <_ZN6StringC1EPK19__FlashStringHelper>
 80a0e94:	a810      	add	r0, sp, #64	; 0x40
 80a0e96:	f7ff fed9 	bl	80a0c4c <_Z10setBgColor6String>
 80a0e9a:	a810      	add	r0, sp, #64	; 0x40
 80a0e9c:	f003 ff59 	bl	80a4d52 <_ZN6StringD1Ev>
        stateChanged = true;
 80a0ea0:	2501      	movs	r5, #1
{
public:
	StringSumHelper(const String &s) : String(s) {}
	StringSumHelper(const char *p) : String(p) {}
 80a0ea2:	492c      	ldr	r1, [pc, #176]	; (80a0f54 <_Z13mqtt_callbackPcPhj+0x234>)
 80a0ea4:	a810      	add	r0, sp, #64	; 0x40
 80a0ea6:	f003 ff9b 	bl	80a4de0 <_ZN6StringC1EPK19__FlashStringHelper>
    }

    if (myTopic == "/"+myID+"/set/EnableDisplay") {
 80a0eaa:	a904      	add	r1, sp, #16
 80a0eac:	a810      	add	r0, sp, #64	; 0x40
 80a0eae:	f003 ffe5 	bl	80a4e7c <_ZplRK15StringSumHelperRK6String>
 80a0eb2:	492f      	ldr	r1, [pc, #188]	; (80a0f70 <_Z13mqtt_callbackPcPhj+0x250>)
 80a0eb4:	f003 ffee 	bl	80a4e94 <_ZplRK15StringSumHelperPKc>
	// comparison (only works w/ Strings and "strings")
	operator StringIfHelperType() const { return buffer ? &String::StringIfHelper : 0; }
	int compareTo(const String &s) const;
	unsigned char equals(const String &s) const;
	unsigned char equals(const char *cstr) const;
	unsigned char operator == (const String &rhs) const {return equals(rhs);}
 80a0eb8:	4601      	mov	r1, r0
 80a0eba:	4668      	mov	r0, sp
 80a0ebc:	f004 f812 	bl	80a4ee4 <_ZNK6String6equalsERKS_>
 80a0ec0:	4606      	mov	r6, r0

        friend class StringPrintableHelper;

};

class StringSumHelper : public String
 80a0ec2:	a810      	add	r0, sp, #64	; 0x40
 80a0ec4:	f003 ff45 	bl	80a4d52 <_ZN6StringD1Ev>
 80a0ec8:	b37e      	cbz	r6, 80a0f2a <_Z13mqtt_callbackPcPhj+0x20a>
        if ((String(myPayload) == "1") or (String(myPayload).toLowerCase() == "true")) {
 80a0eca:	4621      	mov	r1, r4
 80a0ecc:	a80c      	add	r0, sp, #48	; 0x30
 80a0ece:	f003 ff87 	bl	80a4de0 <_ZN6StringC1EPK19__FlashStringHelper>
	operator StringIfHelperType() const { return buffer ? &String::StringIfHelper : 0; }
	int compareTo(const String &s) const;
	unsigned char equals(const String &s) const;
	unsigned char equals(const char *cstr) const;
	unsigned char operator == (const String &rhs) const {return equals(rhs);}
	unsigned char operator == (const char *cstr) const {return equals(cstr);}
 80a0ed2:	4928      	ldr	r1, [pc, #160]	; (80a0f74 <_Z13mqtt_callbackPcPhj+0x254>)
 80a0ed4:	a80c      	add	r0, sp, #48	; 0x30
 80a0ed6:	f004 f812 	bl	80a4efe <_ZNK6String6equalsEPKc>
 80a0eda:	b980      	cbnz	r0, 80a0efe <_Z13mqtt_callbackPcPhj+0x1de>
 80a0edc:	4621      	mov	r1, r4
 80a0ede:	a810      	add	r0, sp, #64	; 0x40
 80a0ee0:	f003 ff7e 	bl	80a4de0 <_ZN6StringC1EPK19__FlashStringHelper>
 80a0ee4:	a810      	add	r0, sp, #64	; 0x40
 80a0ee6:	f004 f81c 	bl	80a4f22 <_ZN6String11toLowerCaseEv>
 80a0eea:	4923      	ldr	r1, [pc, #140]	; (80a0f78 <_Z13mqtt_callbackPcPhj+0x258>)
 80a0eec:	f004 f807 	bl	80a4efe <_ZNK6String6equalsEPKc>
 80a0ef0:	1c05      	adds	r5, r0, #0
 80a0ef2:	a810      	add	r0, sp, #64	; 0x40
 80a0ef4:	bf18      	it	ne
 80a0ef6:	2501      	movne	r5, #1
 80a0ef8:	f003 ff2b 	bl	80a4d52 <_ZN6StringD1Ev>
 80a0efc:	e000      	b.n	80a0f00 <_Z13mqtt_callbackPcPhj+0x1e0>
 80a0efe:	2501      	movs	r5, #1
 80a0f00:	a80c      	add	r0, sp, #48	; 0x30
 80a0f02:	f003 ff26 	bl	80a4d52 <_ZN6StringD1Ev>
 80a0f06:	4e1d      	ldr	r6, [pc, #116]	; (80a0f7c <_Z13mqtt_callbackPcPhj+0x25c>)
            enableDisplay("");
 80a0f08:	491d      	ldr	r1, [pc, #116]	; (80a0f80 <_Z13mqtt_callbackPcPhj+0x260>)
 80a0f0a:	a810      	add	r0, sp, #64	; 0x40
        setBgColor(String(myPayload));
        stateChanged = true;
    }

    if (myTopic == "/"+myID+"/set/EnableDisplay") {
        if ((String(myPayload) == "1") or (String(myPayload).toLowerCase() == "true")) {
 80a0f0c:	b125      	cbz	r5, 80a0f18 <_Z13mqtt_callbackPcPhj+0x1f8>
            enableDisplay("");
 80a0f0e:	f003 ff67 	bl	80a4de0 <_ZN6StringC1EPK19__FlashStringHelper>
    return brightness;
}

int enableDisplay(String command)
{
    displayEnabled = true;
 80a0f12:	2301      	movs	r3, #1
 80a0f14:	7033      	strb	r3, [r6, #0]
 80a0f16:	e002      	b.n	80a0f1e <_Z13mqtt_callbackPcPhj+0x1fe>

    if (myTopic == "/"+myID+"/set/EnableDisplay") {
        if ((String(myPayload) == "1") or (String(myPayload).toLowerCase() == "true")) {
            enableDisplay("");
        } else {
            disableDisplay("");
 80a0f18:	f003 ff62 	bl	80a4de0 <_ZN6StringC1EPK19__FlashStringHelper>
    return 1;
}

int disableDisplay(String command)
{
    displayEnabled = false;
 80a0f1c:	7035      	strb	r5, [r6, #0]

    saveSettings();
 80a0f1e:	f7ff fdd5 	bl	80a0acc <_Z12saveSettingsv>

    if (myTopic == "/"+myID+"/set/EnableDisplay") {
        if ((String(myPayload) == "1") or (String(myPayload).toLowerCase() == "true")) {
            enableDisplay("");
        } else {
            disableDisplay("");
 80a0f22:	a810      	add	r0, sp, #64	; 0x40
 80a0f24:	f003 ff15 	bl	80a4d52 <_ZN6StringD1Ev>
 80a0f28:	e00b      	b.n	80a0f42 <_Z13mqtt_callbackPcPhj+0x222>
        }
        stateChanged = true;
    }

    if (stateChanged) {
 80a0f2a:	b955      	cbnz	r5, 80a0f42 <_Z13mqtt_callbackPcPhj+0x222>
        publishState();
    }

    free(myPayload);
 80a0f2c:	4620      	mov	r0, r4
 80a0f2e:	f002 fdb3 	bl	80a3a98 <free>
    char *myPayload = (char *) malloc(length + 1);

    memcpy(myPayload, payload, length);
    myPayload[length] = 0;

    String myID = System.deviceID();
 80a0f32:	a804      	add	r0, sp, #16
 80a0f34:	f003 ff0d 	bl	80a4d52 <_ZN6StringD1Ev>

void mqtt_callback(char *topic, byte *payload, unsigned int length)
{
    // handle message arrived - we are only subscribing to one topic so assume all are led related

    String myTopic = String(topic);
 80a0f38:	4668      	mov	r0, sp
 80a0f3a:	f003 ff0a 	bl	80a4d52 <_ZN6StringD1Ev>
        publishState();
    }

    free(myPayload);
    myPayload = NULL;
}
 80a0f3e:	b014      	add	sp, #80	; 0x50
 80a0f40:	bd70      	pop	{r4, r5, r6, pc}
        }
        stateChanged = true;
    }

    if (stateChanged) {
        publishState();
 80a0f42:	f7ff fbe1 	bl	80a0708 <_Z12publishStatev>
 80a0f46:	e7f1      	b.n	80a0f2c <_Z13mqtt_callbackPcPhj+0x20c>
 80a0f48:	200004fc 	.word	0x200004fc
 80a0f4c:	080a64e0 	.word	0x080a64e0
 80a0f50:	080a6509 	.word	0x080a6509
 80a0f54:	080a6511 	.word	0x080a6511
 80a0f58:	080a65f0 	.word	0x080a65f0
 80a0f5c:	080a6603 	.word	0x080a6603
 80a0f60:	080a6612 	.word	0x080a6612
 80a0f64:	080a6623 	.word	0x080a6623
 80a0f68:	080a6633 	.word	0x080a6633
 80a0f6c:	080a6647 	.word	0x080a6647
 80a0f70:	080a665c 	.word	0x080a665c
 80a0f74:	080a6a88 	.word	0x080a6a88
 80a0f78:	080a64d5 	.word	0x080a64d5
 80a0f7c:	20000305 	.word	0x20000305
 80a0f80:	080a6a47 	.word	0x080a6a47

080a0f84 <setup>:
        EEPROM.write(address++, leds[i]);
    }
}

void setup()
{
 80a0f84:	b510      	push	{r4, lr}
 80a0f86:	b088      	sub	sp, #32
#ifdef DEBUG
    Serial.begin(9600);
 80a0f88:	f002 fea4 	bl	80a3cd4 <_Z16_fetch_usbserialv>
 80a0f8c:	f44f 5116 	mov.w	r1, #9600	; 0x2580
 80a0f90:	f002 fe86 	bl	80a3ca0 <_ZN9USBSerial5beginEl>
#endif
    loadSettings();
 80a0f94:	f7ff fd36 	bl	80a0a04 <_Z12loadSettingsv>

    switch (dispMode) {
 80a0f98:	4b4e      	ldr	r3, [pc, #312]	; (80a10d4 <setup+0x150>)
 80a0f9a:	681b      	ldr	r3, [r3, #0]
 80a0f9c:	3b01      	subs	r3, #1
 80a0f9e:	2b0a      	cmp	r3, #10
 80a0fa0:	d827      	bhi.n	80a0ff2 <setup+0x6e>
 80a0fa2:	e8df f003 	tbb	[pc, r3]
 80a0fa6:	0906      	.short	0x0906
 80a0fa8:	15120f0c 	.word	0x15120f0c
 80a0fac:	211e1b18 	.word	0x211e1b18
 80a0fb0:	24          	.byte	0x24
 80a0fb1:	00          	.byte	0x00
    case 1:
        setupNoise();
 80a0fb2:	f000 febb 	bl	80a1d2c <_Z10setupNoisev>
        break;
 80a0fb6:	e01c      	b.n	80a0ff2 <setup+0x6e>
    case 2:
        setupRainbowCycle();
 80a0fb8:	f7ff f9a2 	bl	80a0300 <_Z17setupRainbowCyclev>
        break;
 80a0fbc:	e019      	b.n	80a0ff2 <setup+0x6e>
    case 3:
        setupNoisePlusPalette();
 80a0fbe:	f000 fcd9 	bl	80a1974 <_Z21setupNoisePlusPalettev>
        break;
 80a0fc2:	e016      	b.n	80a0ff2 <setup+0x6e>
    case 4:
        setupSingleColor();
 80a0fc4:	f000 fba0 	bl	80a1708 <_Z16setupSingleColorv>
        break;
 80a0fc8:	e013      	b.n	80a0ff2 <setup+0x6e>
    case 5:
        setupCylon();
 80a0fca:	f7ff f877 	bl	80a00bc <_Z10setupCylonv>
        break;
 80a0fce:	e010      	b.n	80a0ff2 <setup+0x6e>
    case 6:
        setupRainSnow();
 80a0fd0:	f001 f94a 	bl	80a2268 <_Z13setupRainSnowv>
        break;
 80a0fd4:	e00d      	b.n	80a0ff2 <setup+0x6e>
    case 7:
        setupFire();
 80a0fd6:	f000 ff07 	bl	80a1de8 <_Z9setupFirev>
        break;
 80a0fda:	e00a      	b.n	80a0ff2 <setup+0x6e>
    case 8:
        setupHorizontalSplit();
 80a0fdc:	f7ff f98c 	bl	80a02f8 <_Z20setupHorizontalSplitv>
        break;
 80a0fe0:	e007      	b.n	80a0ff2 <setup+0x6e>
    case 9:
        setupHorizontalDoubleSplit();
 80a0fe2:	f001 f93d 	bl	80a2260 <_Z26setupHorizontalDoubleSplitv>
        break;
 80a0fe6:	e004      	b.n	80a0ff2 <setup+0x6e>
    case 10:
        setupVerticalSplit();
 80a0fe8:	f001 f8d8 	bl	80a219c <_Z18setupVerticalSplitv>
        break;
 80a0fec:	e001      	b.n	80a0ff2 <setup+0x6e>
    case 11:
        setupSpiral();
 80a0fee:	f001 f823 	bl	80a2038 <_Z11setupSpiralv>
        break;
    default:
        break;
    }

    randomSeed(analogRead(A0) + micros());
 80a0ff2:	200a      	movs	r0, #10
 80a0ff4:	f004 f8b1 	bl	80a515a <analogRead>
 80a0ff8:	4604      	mov	r4, r0

#include "timer_hal.h"
#include "delay_hal.h"

inline system_tick_t millis(void) { return HAL_Timer_Get_Milli_Seconds(); }
inline unsigned long micros(void) { return HAL_Timer_Get_Micro_Seconds(); }
 80a0ffa:	f002 fc69 	bl	80a38d0 <HAL_Timer_Get_Micro_Seconds>
 80a0ffe:	4420      	add	r0, r4
 80a1000:	f002 fdb9 	bl	80a3b76 <_Z10randomSeedj>
    Time.zone(+1);
 80a1004:	f04f 507e 	mov.w	r0, #1065353216	; 0x3f800000
 80a1008:	f003 fa72 	bl	80a44f0 <_ZN9TimeClass4zoneEf>
	/// @tparam DATA_PIN - the optional data pin for the leds (required)
	/// @tparam RGB_ORDER - the rgb ordering for the leds (e.g. what order red, green, and blue data is written out in)
	/// @returns a reference to the added controller
	template<template<uint8_t DATA_PIN, EOrder RGB_ORDER> class CHIPSET, uint8_t DATA_PIN, EOrder RGB_ORDER>
	static CLEDController &addLeds(struct CRGB *data, int nLedsOrOffset, int nLedsIfOffset = 0) {
		static CHIPSET<DATA_PIN, RGB_ORDER> c;
 80a100c:	4832      	ldr	r0, [pc, #200]	; (80a10d8 <setup+0x154>)
 80a100e:	6804      	ldr	r4, [r0, #0]
 80a1010:	f014 0401 	ands.w	r4, r4, #1
 80a1014:	d11f      	bne.n	80a1056 <setup+0xd2>
 80a1016:	f7ff f848 	bl	80a00aa <__cxa_guard_acquire>
 80a101a:	b1e0      	cbz	r0, 80a1056 <setup+0xd2>
#ifdef SUPPORT_ARGB
    // as above, but every 4th uint8_t is assumed to be alpha channel data, and will be skipped
    virtual void show(const struct CARGB *data, int nLeds, CRGB scale) = 0;
#endif
public:
    CLEDController() : m_Data(NULL), m_ColorCorrection(UncorrectedColor), m_ColorTemperature(UncorrectedTemperature), m_DitherMode(BINARY_DITHER), m_nLeds(0) {
 80a101c:	4b2f      	ldr	r3, [pc, #188]	; (80a10dc <setup+0x158>)
    : r((colorcode >> 16) & 0xFF), g((colorcode >> 8) & 0xFF), b((colorcode >> 0) & 0xFF)
    {
    }

    inline CRGB( LEDColorCorrection colorcode) __attribute__((always_inline))
    : r((colorcode >> 16) & 0xFF), g((colorcode >> 8) & 0xFF), b((colorcode >> 0) & 0xFF)
 80a101e:	22ff      	movs	r2, #255	; 0xff
 80a1020:	731a      	strb	r2, [r3, #12]
 80a1022:	735a      	strb	r2, [r3, #13]
 80a1024:	739a      	strb	r2, [r3, #14]
    {

    }

    inline CRGB( ColorTemperature colorcode) __attribute__((always_inline))
    : r((colorcode >> 16) & 0xFF), g((colorcode >> 8) & 0xFF), b((colorcode >> 0) & 0xFF)
 80a1026:	73da      	strb	r2, [r3, #15]
 80a1028:	741a      	strb	r2, [r3, #16]
 80a102a:	745a      	strb	r2, [r3, #17]
 80a102c:	2201      	movs	r2, #1
 80a102e:	749a      	strb	r2, [r3, #18]
        m_pNext = NULL;
        if(m_pHead==NULL) { m_pHead = this; }
 80a1030:	4a2b      	ldr	r2, [pc, #172]	; (80a10e0 <setup+0x15c>)
#ifdef SUPPORT_ARGB
    // as above, but every 4th uint8_t is assumed to be alpha channel data, and will be skipped
    virtual void show(const struct CARGB *data, int nLeds, CRGB scale) = 0;
#endif
public:
    CLEDController() : m_Data(NULL), m_ColorCorrection(UncorrectedColor), m_ColorTemperature(UncorrectedTemperature), m_DitherMode(BINARY_DITHER), m_nLeds(0) {
 80a1032:	605c      	str	r4, [r3, #4]
        m_pNext = NULL;
        if(m_pHead==NULL) { m_pHead = this; }
 80a1034:	6811      	ldr	r1, [r2, #0]
#ifdef SUPPORT_ARGB
    // as above, but every 4th uint8_t is assumed to be alpha channel data, and will be skipped
    virtual void show(const struct CARGB *data, int nLeds, CRGB scale) = 0;
#endif
public:
    CLEDController() : m_Data(NULL), m_ColorCorrection(UncorrectedColor), m_ColorTemperature(UncorrectedTemperature), m_DitherMode(BINARY_DITHER), m_nLeds(0) {
 80a1036:	615c      	str	r4, [r3, #20]
        m_pNext = NULL;
 80a1038:	609c      	str	r4, [r3, #8]
        if(m_pHead==NULL) { m_pHead = this; }
 80a103a:	b901      	cbnz	r1, 80a103e <setup+0xba>
 80a103c:	6013      	str	r3, [r2, #0]
        if(m_pTail != NULL) { m_pTail->m_pNext = this; }
 80a103e:	4a29      	ldr	r2, [pc, #164]	; (80a10e4 <setup+0x160>)
 80a1040:	6811      	ldr	r1, [r2, #0]
 80a1042:	b101      	cbz	r1, 80a1046 <setup+0xc2>
 80a1044:	608b      	str	r3, [r1, #8]
        m_pTail = this;
 80a1046:	6013      	str	r3, [r2, #0]
// Class to ensure that a minimum amount of time has kicked since the last time run - and delay if not enough time has passed yet
// this should make sure that chipsets that have 
template<int WAIT> class CMinWait {
	uint16_t mLastMicros;
public:
	CMinWait() { mLastMicros = 0; }
 80a1048:	2200      	movs	r2, #0
 80a104a:	841a      	strh	r2, [r3, #32]
template<uint8_t DATA_PIN, EOrder RGB_ORDER> class TM1803 : public TM1803Controller400Khz<DATA_PIN, RGB_ORDER> {};
template<uint8_t DATA_PIN, EOrder RGB_ORDER> class UCS1903 : public UCS1903Controller400Khz<DATA_PIN, RGB_ORDER> {};
template<uint8_t DATA_PIN, EOrder RGB_ORDER> class UCS1903B : public UCS1903BController800Khz<DATA_PIN, RGB_ORDER> {};
template<uint8_t DATA_PIN, EOrder RGB_ORDER> class UCS1904 : public UCS1904Controller800Khz<DATA_PIN, RGB_ORDER> {};
template<uint8_t DATA_PIN, EOrder RGB_ORDER> class WS2812 : public WS2812Controller800Khz<DATA_PIN, RGB_ORDER> {};
template<uint8_t DATA_PIN, EOrder RGB_ORDER> class WS2812B : public WS2812Controller800Khz<DATA_PIN, RGB_ORDER> {};
 80a104c:	4a26      	ldr	r2, [pc, #152]	; (80a10e8 <setup+0x164>)
	/// @tparam DATA_PIN - the optional data pin for the leds (required)
	/// @tparam RGB_ORDER - the rgb ordering for the leds (e.g. what order red, green, and blue data is written out in)
	/// @returns a reference to the added controller
	template<template<uint8_t DATA_PIN, EOrder RGB_ORDER> class CHIPSET, uint8_t DATA_PIN, EOrder RGB_ORDER>
	static CLEDController &addLeds(struct CRGB *data, int nLedsOrOffset, int nLedsIfOffset = 0) {
		static CHIPSET<DATA_PIN, RGB_ORDER> c;
 80a104e:	4822      	ldr	r0, [pc, #136]	; (80a10d8 <setup+0x154>)
template<uint8_t DATA_PIN, EOrder RGB_ORDER> class TM1803 : public TM1803Controller400Khz<DATA_PIN, RGB_ORDER> {};
template<uint8_t DATA_PIN, EOrder RGB_ORDER> class UCS1903 : public UCS1903Controller400Khz<DATA_PIN, RGB_ORDER> {};
template<uint8_t DATA_PIN, EOrder RGB_ORDER> class UCS1903B : public UCS1903BController800Khz<DATA_PIN, RGB_ORDER> {};
template<uint8_t DATA_PIN, EOrder RGB_ORDER> class UCS1904 : public UCS1904Controller800Khz<DATA_PIN, RGB_ORDER> {};
template<uint8_t DATA_PIN, EOrder RGB_ORDER> class WS2812 : public WS2812Controller800Khz<DATA_PIN, RGB_ORDER> {};
template<uint8_t DATA_PIN, EOrder RGB_ORDER> class WS2812B : public WS2812Controller800Khz<DATA_PIN, RGB_ORDER> {};
 80a1050:	601a      	str	r2, [r3, #0]
	/// @tparam DATA_PIN - the optional data pin for the leds (required)
	/// @tparam RGB_ORDER - the rgb ordering for the leds (e.g. what order red, green, and blue data is written out in)
	/// @returns a reference to the added controller
	template<template<uint8_t DATA_PIN, EOrder RGB_ORDER> class CHIPSET, uint8_t DATA_PIN, EOrder RGB_ORDER>
	static CLEDController &addLeds(struct CRGB *data, int nLedsOrOffset, int nLedsIfOffset = 0) {
		static CHIPSET<DATA_PIN, RGB_ORDER> c;
 80a1052:	f7ff f82f 	bl	80a00b4 <__cxa_guard_release>
		return addLeds(&c, data, nLedsOrOffset, nLedsIfOffset);
 80a1056:	4925      	ldr	r1, [pc, #148]	; (80a10ec <setup+0x168>)
 80a1058:	2300      	movs	r3, #0
 80a105a:	226c      	movs	r2, #108	; 0x6c
 80a105c:	481f      	ldr	r0, [pc, #124]	; (80a10dc <setup+0x158>)
 80a105e:	f001 fe14 	bl	80a2c8a <_ZN9NSFastLED8CFastLED7addLedsEPNS_14CLEDControllerEPNS_4CRGBEii>
    FastLED.addLeds<WS2812B, DATA_PIN, COLOR_ORDER>(leds, NUM_LEDS);
    FastLED.setBrightness(brightness);
 80a1062:	4b23      	ldr	r3, [pc, #140]	; (80a10f0 <setup+0x16c>)
 80a1064:	a804      	add	r0, sp, #16
	//@}
#endif

	/// Set the global brightness scaling
	/// @param scale a 0-255 value for how much to scale all leds before writing them out
	void setBrightness(uint8_t scale) { m_Scale = scale; }
 80a1066:	781a      	ldrb	r2, [r3, #0]
 80a1068:	4b22      	ldr	r3, [pc, #136]	; (80a10f4 <setup+0x170>)
 80a106a:	701a      	strb	r2, [r3, #0]
 80a106c:	f002 fca8 	bl	80a39c0 <spark_deviceID>

    client.connect(System.deviceID(), MQTT_USER, MQTT_PASSWORD); // uid:pwd based authentication
 80a1070:	4b21      	ldr	r3, [pc, #132]	; (80a10f8 <setup+0x174>)
 80a1072:	4a22      	ldr	r2, [pc, #136]	; (80a10fc <setup+0x178>)
 80a1074:	9904      	ldr	r1, [sp, #16]
 80a1076:	4822      	ldr	r0, [pc, #136]	; (80a1100 <setup+0x17c>)
 80a1078:	f002 f89c 	bl	80a31b4 <_ZN4MQTT7connectEPKcS1_S1_>
 80a107c:	a804      	add	r0, sp, #16
 80a107e:	f003 fe68 	bl	80a4d52 <_ZN6StringD1Ev>

    if (client.isConnected()) {
 80a1082:	481f      	ldr	r0, [pc, #124]	; (80a1100 <setup+0x17c>)
 80a1084:	f001 ffb1 	bl	80a2fea <_ZN4MQTT11isConnectedEv>
 80a1088:	b308      	cbz	r0, 80a10ce <setup+0x14a>
        PublisherTimer.start();
 80a108a:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
 80a108e:	481d      	ldr	r0, [pc, #116]	; (80a1104 <setup+0x180>)
 80a1090:	f7ff fad7 	bl	80a0642 <_ZN5Timer5startEj>
        DistanceSonarTimer.start();
 80a1094:	f06f 4100 	mvn.w	r1, #2147483648	; 0x80000000
 80a1098:	481b      	ldr	r0, [pc, #108]	; (80a1108 <setup+0x184>)
 80a109a:	f7ff fad2 	bl	80a0642 <_ZN5Timer5startEj>

class StringSumHelper : public String
{
public:
	StringSumHelper(const String &s) : String(s) {}
	StringSumHelper(const char *p) : String(p) {}
 80a109e:	491b      	ldr	r1, [pc, #108]	; (80a110c <setup+0x188>)
 80a10a0:	a804      	add	r0, sp, #16
 80a10a2:	f003 fe9d 	bl	80a4de0 <_ZN6StringC1EPK19__FlashStringHelper>
 80a10a6:	4668      	mov	r0, sp
 80a10a8:	f002 fc8a 	bl	80a39c0 <spark_deviceID>
        client.subscribe("/"+System.deviceID()+"/set/+");
 80a10ac:	4669      	mov	r1, sp
 80a10ae:	a804      	add	r0, sp, #16
 80a10b0:	f003 fee4 	bl	80a4e7c <_ZplRK15StringSumHelperRK6String>
 80a10b4:	4916      	ldr	r1, [pc, #88]	; (80a1110 <setup+0x18c>)
 80a10b6:	f003 feed 	bl	80a4e94 <_ZplRK15StringSumHelperPKc>
 80a10ba:	6801      	ldr	r1, [r0, #0]
 80a10bc:	4810      	ldr	r0, [pc, #64]	; (80a1100 <setup+0x17c>)
 80a10be:	f002 fa6a 	bl	80a3596 <_ZN4MQTT9subscribeEPKc>
 80a10c2:	4668      	mov	r0, sp
 80a10c4:	f003 fe45 	bl	80a4d52 <_ZN6StringD1Ev>

        friend class StringPrintableHelper;

};

class StringSumHelper : public String
 80a10c8:	a804      	add	r0, sp, #16
 80a10ca:	f003 fe42 	bl	80a4d52 <_ZN6StringD1Ev>
    }
}
 80a10ce:	b008      	add	sp, #32
 80a10d0:	bd10      	pop	{r4, pc}
 80a10d2:	bf00      	nop
 80a10d4:	20000300 	.word	0x20000300
 80a10d8:	2000038c 	.word	0x2000038c
 80a10dc:	20000390 	.word	0x20000390
 80a10e0:	20000904 	.word	0x20000904
 80a10e4:	200008f4 	.word	0x200008f4
 80a10e8:	080a64ac 	.word	0x080a64ac
 80a10ec:	200003b4 	.word	0x200003b4
 80a10f0:	20000304 	.word	0x20000304
 80a10f4:	200008ec 	.word	0x200008ec
 80a10f8:	080a64e0 	.word	0x080a64e0
 80a10fc:	080a6509 	.word	0x080a6509
 80a1100:	200004fc 	.word	0x200004fc
 80a1104:	20000574 	.word	0x20000574
 80a1108:	20000598 	.word	0x20000598
 80a110c:	080a6511 	.word	0x080a6511
 80a1110:	080a666f 	.word	0x080a666f

080a1114 <loop>:

void loop()
{
 80a1114:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
#endif

#include "timer_hal.h"
#include "delay_hal.h"

inline system_tick_t millis(void) { return HAL_Timer_Get_Milli_Seconds(); }
 80a1118:	f002 fbe2 	bl	80a38e0 <HAL_Timer_Get_Milli_Seconds>

    // once a day sync time with cloud:
    if (millis() - lastSync > ONE_DAY_MILLIS) {
 80a111c:	4c31      	ldr	r4, [pc, #196]	; (80a11e4 <loop+0xd0>)
 80a111e:	6823      	ldr	r3, [r4, #0]
 80a1120:	1ac0      	subs	r0, r0, r3
 80a1122:	4b31      	ldr	r3, [pc, #196]	; (80a11e8 <loop+0xd4>)
 80a1124:	4298      	cmp	r0, r3
 80a1126:	d905      	bls.n	80a1134 <loop+0x20>
        CLOUD_FN(spark_unsubscribe(NULL), (void)0);
    }

    bool syncTime(void)
    {
        return CLOUD_FN(spark_sync_time(NULL), false);
 80a1128:	2000      	movs	r0, #0
 80a112a:	f002 fc59 	bl	80a39e0 <spark_sync_time>
 80a112e:	f002 fbd7 	bl	80a38e0 <HAL_Timer_Get_Milli_Seconds>
        // Request time synchronization from the Particle Cloud
        Particle.syncTime();
        lastSync = millis();
 80a1132:	6020      	str	r0, [r4, #0]
    }

    if (displayEnabled) {
 80a1134:	4b2d      	ldr	r3, [pc, #180]	; (80a11ec <loop+0xd8>)
 80a1136:	781c      	ldrb	r4, [r3, #0]
 80a1138:	b36c      	cbz	r4, 80a1196 <loop+0x82>
        switch (dispMode) {
 80a113a:	4b2d      	ldr	r3, [pc, #180]	; (80a11f0 <loop+0xdc>)
 80a113c:	681b      	ldr	r3, [r3, #0]
 80a113e:	3b01      	subs	r3, #1
 80a1140:	2b0a      	cmp	r3, #10
 80a1142:	d83d      	bhi.n	80a11c0 <loop+0xac>
 80a1144:	e8df f003 	tbb	[pc, r3]
 80a1148:	0f0c0906 	.word	0x0f0c0906
 80a114c:	1b181512 	.word	0x1b181512
 80a1150:	211e      	.short	0x211e
 80a1152:	24          	.byte	0x24
 80a1153:	00          	.byte	0x00
        case 1:
            loopNoise();
 80a1154:	f000 fe0c 	bl	80a1d70 <_Z9loopNoisev>
            break;
 80a1158:	e032      	b.n	80a11c0 <loop+0xac>
        case 2:
            loopRainbowCycle();
 80a115a:	f7ff f915 	bl	80a0388 <_Z16loopRainbowCyclev>
            break;
 80a115e:	e02f      	b.n	80a11c0 <loop+0xac>
        case 3:
            loopNoisePlusPalette();
 80a1160:	f000 fdc0 	bl	80a1ce4 <_Z20loopNoisePlusPalettev>
            break;
 80a1164:	e02c      	b.n	80a11c0 <loop+0xac>
        case 4:
            loopSingleColor();
 80a1166:	f000 fabb 	bl	80a16e0 <_Z15loopSingleColorv>
            break;
 80a116a:	e029      	b.n	80a11c0 <loop+0xac>
        case 5:
            loopCylon();
 80a116c:	f7fe ffe4 	bl	80a0138 <_Z9loopCylonv>
            break;
 80a1170:	e026      	b.n	80a11c0 <loop+0xac>
        case 6:
            loopRainSnow();
 80a1172:	f001 f8a1 	bl	80a22b8 <_Z12loopRainSnowv>
            break;
 80a1176:	e023      	b.n	80a11c0 <loop+0xac>
        case 7:
            loopFire();
 80a1178:	f000 fe46 	bl	80a1e08 <_Z8loopFirev>
            break;
 80a117c:	e020      	b.n	80a11c0 <loop+0xac>
        case 8:
            loopHorizontalSplit();
 80a117e:	f7ff f87d 	bl	80a027c <_Z19loopHorizontalSplitv>
            break;
 80a1182:	e01d      	b.n	80a11c0 <loop+0xac>
        case 9:
            loopHorizontalDoubleSplit();
 80a1184:	f001 f80e 	bl	80a21a4 <_Z25loopHorizontalDoubleSplitv>
            break;
 80a1188:	e01a      	b.n	80a11c0 <loop+0xac>
        case 10:
            loopVerticalSplit();
 80a118a:	f000 ffbd 	bl	80a2108 <_Z17loopVerticalSplitv>
            break;
 80a118e:	e017      	b.n	80a11c0 <loop+0xac>
        case 11:
            loopSpiral();
 80a1190:	f000 ff82 	bl	80a2098 <_Z10loopSpiralv>
            break;
 80a1194:	e014      	b.n	80a11c0 <loop+0xac>
    }

    // allow assignment from 32-bit (really 24-bit) 0xRRGGBB color code
	inline CRGB& operator= (const uint32_t colorcode) __attribute__((always_inline))
    {
        r = (colorcode >> 16) & 0xFF;
 80a1196:	4626      	mov	r6, r4
 80a1198:	4f16      	ldr	r7, [pc, #88]	; (80a11f4 <loop+0xe0>)
 80a119a:	2500      	movs	r5, #0
            break;
        }
    } else {
        for (int i = 0; i < kMatrixHeight; i++) {
            for (int j = 0; j < kMatrixWidth; j++) {
                leds[XY(i, j)] = 0;
 80a119c:	fa5f f884 	uxtb.w	r8, r4
 80a11a0:	b2e9      	uxtb	r1, r5
 80a11a2:	4640      	mov	r0, r8
 80a11a4:	f001 f934 	bl	80a2410 <_Z2XYhh>
        default:
            break;
        }
    } else {
        for (int i = 0; i < kMatrixHeight; i++) {
            for (int j = 0; j < kMatrixWidth; j++) {
 80a11a8:	3501      	adds	r5, #1
 80a11aa:	eb00 0040 	add.w	r0, r0, r0, lsl #1
 80a11ae:	183b      	adds	r3, r7, r0
 80a11b0:	2d04      	cmp	r5, #4
 80a11b2:	543e      	strb	r6, [r7, r0]
        g = (colorcode >>  8) & 0xFF;
 80a11b4:	705e      	strb	r6, [r3, #1]
        b = (colorcode >>  0) & 0xFF;
 80a11b6:	709e      	strb	r6, [r3, #2]
 80a11b8:	d1f2      	bne.n	80a11a0 <loop+0x8c>
            break;
        default:
            break;
        }
    } else {
        for (int i = 0; i < kMatrixHeight; i++) {
 80a11ba:	3401      	adds	r4, #1
 80a11bc:	2c1b      	cmp	r4, #27
 80a11be:	d1ec      	bne.n	80a119a <loop+0x86>
	/// Update all our controllers with the current led colors, using the passed in brightness
	/// @param scale temporarily override the scale
	void show(uint8_t scale);

	/// Update all our controllers with the current led colors
	void show() { show(m_Scale); }
 80a11c0:	480d      	ldr	r0, [pc, #52]	; (80a11f8 <loop+0xe4>)
 80a11c2:	7801      	ldrb	r1, [r0, #0]
 80a11c4:	f001 fd92 	bl	80a2cec <_ZN9NSFastLED8CFastLED4showEh>
            }
        }
    }

    LEDS.show();
    delay(10);
 80a11c8:	200a      	movs	r0, #10
 80a11ca:	f003 f8dd 	bl	80a4388 <delay>

    if (client.isConnected()) {
 80a11ce:	480b      	ldr	r0, [pc, #44]	; (80a11fc <loop+0xe8>)
 80a11d0:	f001 ff0b 	bl	80a2fea <_ZN4MQTT11isConnectedEv>
 80a11d4:	b120      	cbz	r0, 80a11e0 <loop+0xcc>
        client.loop();
    }
}
 80a11d6:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}

    LEDS.show();
    delay(10);

    if (client.isConnected()) {
        client.loop();
 80a11da:	4808      	ldr	r0, [pc, #32]	; (80a11fc <loop+0xe8>)
 80a11dc:	f002 b8af 	b.w	80a333e <_ZN4MQTT4loopEv>
 80a11e0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80a11e4:	2000056c 	.word	0x2000056c
 80a11e8:	05265c00 	.word	0x05265c00
 80a11ec:	20000305 	.word	0x20000305
 80a11f0:	20000300 	.word	0x20000300
 80a11f4:	200003b4 	.word	0x200003b4
 80a11f8:	200008ec 	.word	0x200008ec
 80a11fc:	200004fc 	.word	0x200004fc

080a1200 <_ZNKSt8functionIFvvEEclEv>:
  template<typename _Res, typename... _ArgTypes>
    _Res
    function<_Res(_ArgTypes...)>::
    operator()(_ArgTypes... __args) const
    {
      if (_M_empty())
 80a1200:	6882      	ldr	r2, [r0, #8]
	  }
      }

  template<typename _Res, typename... _ArgTypes>
    _Res
    function<_Res(_ArgTypes...)>::
 80a1202:	b510      	push	{r4, lr}
    operator()(_ArgTypes... __args) const
    {
      if (_M_empty())
 80a1204:	b90a      	cbnz	r2, 80a120a <_ZNKSt8functionIFvvEEclEv+0xa>
	__throw_bad_function_call();
 80a1206:	f003 ffde 	bl	80a51c6 <_ZSt25__throw_bad_function_callv>
      return _M_invoker(_M_functor, std::forward<_ArgTypes>(__args)...);
 80a120a:	68c3      	ldr	r3, [r0, #12]
    }
 80a120c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    function<_Res(_ArgTypes...)>::
    operator()(_ArgTypes... __args) const
    {
      if (_M_empty())
	__throw_bad_function_call();
      return _M_invoker(_M_functor, std::forward<_ArgTypes>(__args)...);
 80a1210:	4718      	bx	r3

080a1212 <_ZN5Timer7timeoutEv>:

    /*
     * Subclasses can either provide a callback function, or override
     * this timeout method.
     */
    virtual void timeout()
 80a1212:	b510      	push	{r4, lr}
    {
		running = true;
 80a1214:	2301      	movs	r3, #1
 80a1216:	7103      	strb	r3, [r0, #4]
        if (callback)
 80a1218:	6943      	ldr	r3, [r0, #20]

    /*
     * Subclasses can either provide a callback function, or override
     * this timeout method.
     */
    virtual void timeout()
 80a121a:	4604      	mov	r4, r0
    {
		running = true;
        if (callback)
 80a121c:	b113      	cbz	r3, 80a1224 <_ZN5Timer7timeoutEv+0x12>
        {
            callback();
 80a121e:	300c      	adds	r0, #12
 80a1220:	f7ff ffee 	bl	80a1200 <_ZNKSt8functionIFvvEEclEv>
        }
        running = false;
 80a1224:	2300      	movs	r3, #0
 80a1226:	7123      	strb	r3, [r4, #4]
 80a1228:	bd10      	pop	{r4, pc}

080a122a <_ZN6Thread3runEPv>:
        return *this;
    }

private:

    static os_thread_return_t run(void* param) {
 80a122a:	b538      	push	{r3, r4, r5, lr}
        Data* th = (Data*)param;
        th->started = true;
        if (th->func) {
 80a122c:	6882      	ldr	r2, [r0, #8]

private:

    static os_thread_return_t run(void* param) {
        Data* th = (Data*)param;
        th->started = true;
 80a122e:	2301      	movs	r3, #1
        return *this;
    }

private:

    static os_thread_return_t run(void* param) {
 80a1230:	4604      	mov	r4, r0
        Data* th = (Data*)param;
        th->started = true;
 80a1232:	7403      	strb	r3, [r0, #16]
 80a1234:	461d      	mov	r5, r3
        if (th->func) {
 80a1236:	b112      	cbz	r2, 80a123e <_ZN6Thread3runEPv+0x14>
            (*(th->func))(th->func_param);
 80a1238:	68c0      	ldr	r0, [r0, #12]
 80a123a:	4790      	blx	r2
 80a123c:	e003      	b.n	80a1246 <_ZN6Thread3runEPv+0x1c>
      }

      /// Return the stored pointer.
      pointer
      get() const noexcept
      { return std::get<0>(_M_t); }
 80a123e:	6800      	ldr	r0, [r0, #0]
        } else if (th->wrapper) {
 80a1240:	b108      	cbz	r0, 80a1246 <_ZN6Thread3runEPv+0x1c>
            (*(th->wrapper))();
 80a1242:	f7ff ffdd 	bl	80a1200 <_ZNKSt8functionIFvvEEclEv>
        }
        th->exited = true;
 80a1246:	7465      	strb	r5, [r4, #17]
        os_thread_exit(nullptr);
 80a1248:	2000      	movs	r0, #0
    }
 80a124a:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
            (*(th->func))(th->func_param);
        } else if (th->wrapper) {
            (*(th->wrapper))();
        }
        th->exited = true;
        os_thread_exit(nullptr);
 80a124e:	f002 bb0f 	b.w	80a3870 <os_thread_exit>

080a1252 <_ZN9NSFastLED8CMinWaitILi50EE4waitEv>:

	void wait() { 
 80a1252:	b510      	push	{r4, lr}
 80a1254:	4604      	mov	r4, r0
inline unsigned long micros(void) { return HAL_Timer_Get_Micro_Seconds(); }
 80a1256:	f002 fb3b 	bl	80a38d0 <HAL_Timer_Get_Micro_Seconds>
		uint16_t diff;
		do {
 80a125a:	8823      	ldrh	r3, [r4, #0]
 80a125c:	1ac0      	subs	r0, r0, r3
 80a125e:	b280      	uxth	r0, r0
 80a1260:	2831      	cmp	r0, #49	; 0x31
 80a1262:	d9f8      	bls.n	80a1256 <_ZN9NSFastLED8CMinWaitILi50EE4waitEv+0x4>
			diff = (micros() & 0xFFFF) - mLastMicros;			
		} while(diff < WAIT);
	}
 80a1264:	bd10      	pop	{r4, pc}
	...

080a1268 <_ZN9NSFastLED19ClocklessControllerILi4ELi30ELi75ELi45ELNS_6EOrderE66ELi0ELb0ELi50EE15showRGBInternalERNS_15PixelControllerILS1_66EEE>:
    }
  }

  // This method is made static to force making register Y available to use for data on AVR - if the method is non-static, then
  // gcc will use register Y for the this pointer.
  static uint32_t showRGBInternal(PixelController<RGB_ORDER> & pixels) {
 80a1268:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
    // Get access to the clock
    CoreDebug->DEMCR  |= CoreDebug_DEMCR_TRCENA_Msk;
 80a126c:	4a8a      	ldr	r2, [pc, #552]	; (80a1498 <_ZN9NSFastLED19ClocklessControllerILi4ELi30ELi75ELi45ELNS_6EOrderE66ELi0ELb0ELi50EE15showRGBInternalERNS_15PixelControllerILS1_66EEE+0x230>)
 80a126e:	68d3      	ldr	r3, [r2, #12]
 80a1270:	f043 7380 	orr.w	r3, r3, #16777216	; 0x1000000
 80a1274:	60d3      	str	r3, [r2, #12]
    DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
 80a1276:	4b89      	ldr	r3, [pc, #548]	; (80a149c <_ZN9NSFastLED19ClocklessControllerILi4ELi30ELi75ELi45ELNS_6EOrderE66ELi0ELb0ELi50EE15showRGBInternalERNS_15PixelControllerILS1_66EEE+0x234>)
 80a1278:	681a      	ldr	r2, [r3, #0]
 80a127a:	f042 0201 	orr.w	r2, r2, #1
 80a127e:	601a      	str	r2, [r3, #0]
    DWT->CYCCNT = 0;
 80a1280:	2200      	movs	r2, #0
 80a1282:	605a      	str	r2, [r3, #4]

    register data_ptr_t port = FastPin<DATA_PIN>::port();
    register data_t hi = *port | FastPin<DATA_PIN>::mask();;
 80a1284:	f103 43c0 	add.w	r3, r3, #1610612736	; 0x60000000
 80a1288:	f503 33fa 	add.w	r3, r3, #128000	; 0x1f400
 80a128c:	695c      	ldr	r4, [r3, #20]
    register data_t lo = *port & ~FastPin<DATA_PIN>::mask();;
 80a128e:	695a      	ldr	r2, [r3, #20]
    CoreDebug->DEMCR  |= CoreDebug_DEMCR_TRCENA_Msk;
    DWT->CTRL |= DWT_CTRL_CYCCNTENA_Msk;
    DWT->CYCCNT = 0;

    register data_ptr_t port = FastPin<DATA_PIN>::port();
    register data_t hi = *port | FastPin<DATA_PIN>::mask();;
 80a1290:	f044 0408 	orr.w	r4, r4, #8
    register data_t lo = *port & ~FastPin<DATA_PIN>::mask();;
 80a1294:	f022 0208 	bic.w	r2, r2, #8
    *port = lo;
 80a1298:	615a      	str	r2, [r3, #20]
                d[2] = e[2] - d[2];
        }

        // Some chipsets pre-cycle the first byte, which means we want to cycle byte 0's dithering separately
        __attribute__((always_inline)) inline void preStepFirstByteDithering() {
            d[RO(0)] = e[RO(0)] - d[RO(0)];
 80a129a:	7a45      	ldrb	r5, [r0, #9]
 80a129c:	7b01      	ldrb	r1, [r0, #12]
 80a129e:	1b49      	subs	r1, r1, r5
 80a12a0:	b2c9      	uxtb	r1, r1
        }

        template<int SLOT>  __attribute__((always_inline)) inline static uint8_t loadByte(PixelController & pc) { return pc.mData[RO(SLOT)]; }
 80a12a2:	6805      	ldr	r5, [r0, #0]
                d[2] = e[2] - d[2];
        }

        // Some chipsets pre-cycle the first byte, which means we want to cycle byte 0's dithering separately
        __attribute__((always_inline)) inline void preStepFirstByteDithering() {
            d[RO(0)] = e[RO(0)] - d[RO(0)];
 80a12a4:	7241      	strb	r1, [r0, #9]
        }

        template<int SLOT>  __attribute__((always_inline)) inline static uint8_t loadByte(PixelController & pc) { return pc.mData[RO(SLOT)]; }
 80a12a6:	786d      	ldrb	r5, [r5, #1]
        template<int SLOT>  __attribute__((always_inline)) inline static uint8_t dither(PixelController & pc, uint8_t b) { return b ? qadd8(b, pc.d[RO(SLOT)]) : 0; }
 80a12a8:	b125      	cbz	r5, 80a12b4 <_ZN9NSFastLED19ClocklessControllerILi4ELi30ELi75ELi45ELNS_6EOrderE66ELi0ELb0ELi50EE15showRGBInternalERNS_15PixelControllerILS1_66EEE+0x4c>

// qadd8: add one byte to another, saturating at 0xFF
LIB8STATIC uint8_t qadd8( uint8_t i, uint8_t j)
{
#if QADD8_C == 1
    unsigned int t = i + j;
 80a12aa:	4429      	add	r1, r5
 80a12ac:	29ff      	cmp	r1, #255	; 0xff
 80a12ae:	bfa8      	it	ge
 80a12b0:	21ff      	movge	r1, #255	; 0xff
    if( t > 255) t = 255;
    return t;
 80a12b2:	b2cd      	uxtb	r5, r1
//         In other words, it computes i * (scale / 256)
//         4 clocks AVR with MUL, 2 clocks ARM
LIB8STATIC uint8_t scale8( uint8_t i, fract8 scale)
{
#if SCALE8_C == 1
    return ((uint16_t)i * (uint16_t)(scale) ) >> 8;
 80a12b4:	7bc1      	ldrb	r1, [r0, #15]
 80a12b6:	4369      	muls	r1, r5
 80a12b8:	f3c1 2907 	ubfx	r9, r1, #8, #8
  This function disables IRQ interrupts by setting the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_irq(void)
{
  __ASM volatile ("cpsid i");
 80a12bc:	b672      	cpsid	i
    This function disables FIQ interrupts by setting the F-bit in the CPSR.
    Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __disable_fault_irq(void)
{
  __ASM volatile ("cpsid f");
 80a12be:	b671      	cpsid	f

#define _CYCCNT (*(volatile uint32_t*)(0xE0001004UL))

  template<int BITS> __attribute__ ((always_inline)) inline static void writeBits(register uint32_t & next_mark, register data_ptr_t port, register data_t hi, register data_t lo, register uint8_t & b)  {
    for(register uint32_t i = BITS-1; i > 0; i--) {
      while(_CYCCNT < (T1+T2+T3-ADJ));
 80a12c0:	f8df e1dc 	ldr.w	lr, [pc, #476]	; 80a14a0 <_ZN9NSFastLED19ClocklessControllerILi4ELi30ELi75ELi45ELNS_6EOrderE66ELi0ELb0ELi50EE15showRGBInternalERNS_15PixelControllerILS1_66EEE+0x238>

    cli();

    uint32_t next_mark = (T1+T2+T3);

    DWT->CYCCNT = 0;
 80a12c4:	4975      	ldr	r1, [pc, #468]	; (80a149c <_ZN9NSFastLED19ClocklessControllerILi4ELi30ELi75ELi45ELNS_6EOrderE66ELi0ELb0ELi50EE15showRGBInternalERNS_15PixelControllerILS1_66EEE+0x234>)
 80a12c6:	2500      	movs	r5, #0

  template<int BITS> __attribute__ ((always_inline)) inline static void writeBits(register uint32_t & next_mark, register data_ptr_t port, register data_t hi, register data_t lo, register uint8_t & b)  {
    for(register uint32_t i = BITS-1; i > 0; i--) {
      while(_CYCCNT < (T1+T2+T3-ADJ));
      FastPin<DATA_PIN>::fastset(port, hi);
      _CYCCNT = 4;
 80a12c8:	2604      	movs	r6, #4

    cli();

    uint32_t next_mark = (T1+T2+T3);

    DWT->CYCCNT = 0;
 80a12ca:	604d      	str	r5, [r1, #4]
 80a12cc:	46f0      	mov	r8, lr
 80a12ce:	4675      	mov	r5, lr
 80a12d0:	4671      	mov	r1, lr

  template<int BITS> __attribute__ ((always_inline)) inline static void writeBits(register uint32_t & next_mark, register data_ptr_t port, register data_t hi, register data_t lo, register uint8_t & b)  {
    for(register uint32_t i = BITS-1; i > 0; i--) {
      while(_CYCCNT < (T1+T2+T3-ADJ));
      FastPin<DATA_PIN>::fastset(port, hi);
      _CYCCNT = 4;
 80a12d2:	46b4      	mov	ip, r6
    cli();

    uint32_t next_mark = (T1+T2+T3);

    DWT->CYCCNT = 0;
    while(pixels.has(1)) {
 80a12d4:	6847      	ldr	r7, [r0, #4]
 80a12d6:	2f00      	cmp	r7, #0
 80a12d8:	f340 80d7 	ble.w	80a148a <_ZN9NSFastLED19ClocklessControllerILi4ELi30ELi75ELi45ELNS_6EOrderE66ELi0ELb0ELi50EE15showRGBInternalERNS_15PixelControllerILS1_66EEE+0x222>

        // step the dithering forward
         __attribute__((always_inline)) inline void stepDithering() {
         		// IF UPDATING HERE, BE SURE TO UPDATE THE ASM VERSION IN
         		// clockless_trinket.h!
                d[0] = e[0] - d[0];
 80a12dc:	f890 a008 	ldrb.w	sl, [r0, #8]
 80a12e0:	7ac7      	ldrb	r7, [r0, #11]
 80a12e2:	ebca 0707 	rsb	r7, sl, r7
 80a12e6:	7207      	strb	r7, [r0, #8]
                d[1] = e[1] - d[1];
 80a12e8:	f890 a009 	ldrb.w	sl, [r0, #9]
 80a12ec:	7b07      	ldrb	r7, [r0, #12]
 80a12ee:	ebca 0707 	rsb	r7, sl, r7
 80a12f2:	7247      	strb	r7, [r0, #9]
                d[2] = e[2] - d[2];
 80a12f4:	f890 a00a 	ldrb.w	sl, [r0, #10]
 80a12f8:	7b47      	ldrb	r7, [r0, #13]
 80a12fa:	ebca 0707 	rsb	r7, sl, r7
 80a12fe:	7287      	strb	r7, [r0, #10]
 80a1300:	2707      	movs	r7, #7

#define _CYCCNT (*(volatile uint32_t*)(0xE0001004UL))

  template<int BITS> __attribute__ ((always_inline)) inline static void writeBits(register uint32_t & next_mark, register data_ptr_t port, register data_t hi, register data_t lo, register uint8_t & b)  {
    for(register uint32_t i = BITS-1; i > 0; i--) {
      while(_CYCCNT < (T1+T2+T3-ADJ));
 80a1302:	f8de a000 	ldr.w	sl, [lr]
 80a1306:	f1ba 0f8d 	cmp.w	sl, #141	; 0x8d
 80a130a:	d9fa      	bls.n	80a1302 <_ZN9NSFastLED19ClocklessControllerILi4ELi30ELi75ELi45ELNS_6EOrderE66ELi0ELb0ELi50EE15showRGBInternalERNS_15PixelControllerILS1_66EEE+0x9a>
      FastPin<DATA_PIN>::fastset(port, hi);
      _CYCCNT = 4;
      if(b&0x80) {
 80a130c:	f019 0f80 	tst.w	r9, #128	; 0x80

  inline static void toggle() __attribute__ ((always_inline)) { if(_GPIO::r()->ODR & _MASK) { lo(); } else { hi(); } }

  inline static void hi(register port_ptr_t port) __attribute__ ((always_inline)) { hi(); }
  inline static void lo(register port_ptr_t port) __attribute__ ((always_inline)) { lo(); }
  inline static void fastset(register port_ptr_t port, register port_t val) __attribute__ ((always_inline)) { *port = val; }
 80a1310:	615c      	str	r4, [r3, #20]

  template<int BITS> __attribute__ ((always_inline)) inline static void writeBits(register uint32_t & next_mark, register data_ptr_t port, register data_t hi, register data_t lo, register uint8_t & b)  {
    for(register uint32_t i = BITS-1; i > 0; i--) {
      while(_CYCCNT < (T1+T2+T3-ADJ));
      FastPin<DATA_PIN>::fastset(port, hi);
      _CYCCNT = 4;
 80a1312:	602e      	str	r6, [r5, #0]
      if(b&0x80) {
 80a1314:	d005      	beq.n	80a1322 <_ZN9NSFastLED19ClocklessControllerILi4ELi30ELi75ELi45ELNS_6EOrderE66ELi0ELb0ELi50EE15showRGBInternalERNS_15PixelControllerILS1_66EEE+0xba>
        while(_CYCCNT < (T1+T2-ADJ));
 80a1316:	f8d8 a000 	ldr.w	sl, [r8]
 80a131a:	f1ba 0f60 	cmp.w	sl, #96	; 0x60
 80a131e:	d9fa      	bls.n	80a1316 <_ZN9NSFastLED19ClocklessControllerILi4ELi30ELi75ELi45ELNS_6EOrderE66ELi0ELb0ELi50EE15showRGBInternalERNS_15PixelControllerILS1_66EEE+0xae>
 80a1320:	e004      	b.n	80a132c <_ZN9NSFastLED19ClocklessControllerILi4ELi30ELi75ELi45ELNS_6EOrderE66ELi0ELb0ELi50EE15showRGBInternalERNS_15PixelControllerILS1_66EEE+0xc4>
        FastPin<DATA_PIN>::fastset(port, lo);
      } else {
        while(_CYCCNT < (T1-(ADJ/2)));
 80a1322:	f8d8 a000 	ldr.w	sl, [r8]
 80a1326:	f1ba 0f19 	cmp.w	sl, #25
 80a132a:	d9fa      	bls.n	80a1322 <_ZN9NSFastLED19ClocklessControllerILi4ELi30ELi75ELi45ELNS_6EOrderE66ELi0ELb0ELi50EE15showRGBInternalERNS_15PixelControllerILS1_66EEE+0xba>
        FastPin<DATA_PIN>::fastset(port, lo);
      }
      b <<= 1;
 80a132c:	ea4f 0949 	mov.w	r9, r9, lsl #1
  #endif

#define _CYCCNT (*(volatile uint32_t*)(0xE0001004UL))

  template<int BITS> __attribute__ ((always_inline)) inline static void writeBits(register uint32_t & next_mark, register data_ptr_t port, register data_t hi, register data_t lo, register uint8_t & b)  {
    for(register uint32_t i = BITS-1; i > 0; i--) {
 80a1330:	3f01      	subs	r7, #1
 80a1332:	615a      	str	r2, [r3, #20]
        FastPin<DATA_PIN>::fastset(port, lo);
      } else {
        while(_CYCCNT < (T1-(ADJ/2)));
        FastPin<DATA_PIN>::fastset(port, lo);
      }
      b <<= 1;
 80a1334:	fa5f f989 	uxtb.w	r9, r9
  #endif

#define _CYCCNT (*(volatile uint32_t*)(0xE0001004UL))

  template<int BITS> __attribute__ ((always_inline)) inline static void writeBits(register uint32_t & next_mark, register data_ptr_t port, register data_t hi, register data_t lo, register uint8_t & b)  {
    for(register uint32_t i = BITS-1; i > 0; i--) {
 80a1338:	d1e3      	bne.n	80a1302 <_ZN9NSFastLED19ClocklessControllerILi4ELi30ELi75ELi45ELNS_6EOrderE66ELi0ELb0ELi50EE15showRGBInternalERNS_15PixelControllerILS1_66EEE+0x9a>
        FastPin<DATA_PIN>::fastset(port, lo);
      }
      b <<= 1;
    }

    while(_CYCCNT < (T1+T2+T3-ADJ));
 80a133a:	680f      	ldr	r7, [r1, #0]
 80a133c:	2f8d      	cmp	r7, #141	; 0x8d
 80a133e:	d9fc      	bls.n	80a133a <_ZN9NSFastLED19ClocklessControllerILi4ELi30ELi75ELi45ELNS_6EOrderE66ELi0ELb0ELi50EE15showRGBInternalERNS_15PixelControllerILS1_66EEE+0xd2>
    FastPin<DATA_PIN>::fastset(port, hi);
    _CYCCNT = 4;

    if(b&0x80) {
 80a1340:	f019 0f80 	tst.w	r9, #128	; 0x80
 80a1344:	615c      	str	r4, [r3, #20]
      b <<= 1;
    }

    while(_CYCCNT < (T1+T2+T3-ADJ));
    FastPin<DATA_PIN>::fastset(port, hi);
    _CYCCNT = 4;
 80a1346:	602e      	str	r6, [r5, #0]

    if(b&0x80) {
 80a1348:	d003      	beq.n	80a1352 <_ZN9NSFastLED19ClocklessControllerILi4ELi30ELi75ELi45ELNS_6EOrderE66ELi0ELb0ELi50EE15showRGBInternalERNS_15PixelControllerILS1_66EEE+0xea>
      while(_CYCCNT < (T1+T2-ADJ));
 80a134a:	680f      	ldr	r7, [r1, #0]
 80a134c:	2f60      	cmp	r7, #96	; 0x60
 80a134e:	d9fc      	bls.n	80a134a <_ZN9NSFastLED19ClocklessControllerILi4ELi30ELi75ELi45ELNS_6EOrderE66ELi0ELb0ELi50EE15showRGBInternalERNS_15PixelControllerILS1_66EEE+0xe2>
 80a1350:	e002      	b.n	80a1358 <_ZN9NSFastLED19ClocklessControllerILi4ELi30ELi75ELi45ELNS_6EOrderE66ELi0ELb0ELi50EE15showRGBInternalERNS_15PixelControllerILS1_66EEE+0xf0>
      FastPin<DATA_PIN>::fastset(port, lo);
    } else {
      while(_CYCCNT < (T1-(ADJ/2)));
 80a1352:	680f      	ldr	r7, [r1, #0]
 80a1354:	2f19      	cmp	r7, #25
 80a1356:	d9fc      	bls.n	80a1352 <_ZN9NSFastLED19ClocklessControllerILi4ELi30ELi75ELi45ELNS_6EOrderE66ELi0ELb0ELi50EE15showRGBInternalERNS_15PixelControllerILS1_66EEE+0xea>
 80a1358:	615a      	str	r2, [r3, #20]
        // Some chipsets pre-cycle the first byte, which means we want to cycle byte 0's dithering separately
        __attribute__((always_inline)) inline void preStepFirstByteDithering() {
            d[RO(0)] = e[RO(0)] - d[RO(0)];
        }

        template<int SLOT>  __attribute__((always_inline)) inline static uint8_t loadByte(PixelController & pc) { return pc.mData[RO(SLOT)]; }
 80a135a:	6807      	ldr	r7, [r0, #0]
 80a135c:	783f      	ldrb	r7, [r7, #0]
        template<int SLOT>  __attribute__((always_inline)) inline static uint8_t dither(PixelController & pc, uint8_t b) { return b ? qadd8(b, pc.d[RO(SLOT)]) : 0; }
 80a135e:	b137      	cbz	r7, 80a136e <_ZN9NSFastLED19ClocklessControllerILi4ELi30ELi75ELi45ELNS_6EOrderE66ELi0ELb0ELi50EE15showRGBInternalERNS_15PixelControllerILS1_66EEE+0x106>

// qadd8: add one byte to another, saturating at 0xFF
LIB8STATIC uint8_t qadd8( uint8_t i, uint8_t j)
{
#if QADD8_C == 1
    unsigned int t = i + j;
 80a1360:	f890 9008 	ldrb.w	r9, [r0, #8]
 80a1364:	444f      	add	r7, r9
 80a1366:	2fff      	cmp	r7, #255	; 0xff
 80a1368:	bfa8      	it	ge
 80a136a:	27ff      	movge	r7, #255	; 0xff
    if( t > 255) t = 255;
    return t;
 80a136c:	b2ff      	uxtb	r7, r7
//         In other words, it computes i * (scale / 256)
//         4 clocks AVR with MUL, 2 clocks ARM
LIB8STATIC uint8_t scale8( uint8_t i, fract8 scale)
{
#if SCALE8_C == 1
    return ((uint16_t)i * (uint16_t)(scale) ) >> 8;
 80a136e:	f890 900e 	ldrb.w	r9, [r0, #14]
 80a1372:	fb07 f709 	mul.w	r7, r7, r9
 80a1376:	f04f 0907 	mov.w	r9, #7
 80a137a:	f3c7 2707 	ubfx	r7, r7, #8, #8

#define _CYCCNT (*(volatile uint32_t*)(0xE0001004UL))

  template<int BITS> __attribute__ ((always_inline)) inline static void writeBits(register uint32_t & next_mark, register data_ptr_t port, register data_t hi, register data_t lo, register uint8_t & b)  {
    for(register uint32_t i = BITS-1; i > 0; i--) {
      while(_CYCCNT < (T1+T2+T3-ADJ));
 80a137e:	f8d1 a000 	ldr.w	sl, [r1]
 80a1382:	f1ba 0f8d 	cmp.w	sl, #141	; 0x8d
 80a1386:	d9fa      	bls.n	80a137e <_ZN9NSFastLED19ClocklessControllerILi4ELi30ELi75ELi45ELNS_6EOrderE66ELi0ELb0ELi50EE15showRGBInternalERNS_15PixelControllerILS1_66EEE+0x116>
      FastPin<DATA_PIN>::fastset(port, hi);
      _CYCCNT = 4;
      if(b&0x80) {
 80a1388:	f017 0f80 	tst.w	r7, #128	; 0x80
 80a138c:	615c      	str	r4, [r3, #20]

  template<int BITS> __attribute__ ((always_inline)) inline static void writeBits(register uint32_t & next_mark, register data_ptr_t port, register data_t hi, register data_t lo, register uint8_t & b)  {
    for(register uint32_t i = BITS-1; i > 0; i--) {
      while(_CYCCNT < (T1+T2+T3-ADJ));
      FastPin<DATA_PIN>::fastset(port, hi);
      _CYCCNT = 4;
 80a138e:	f8c5 c000 	str.w	ip, [r5]
      if(b&0x80) {
 80a1392:	d005      	beq.n	80a13a0 <_ZN9NSFastLED19ClocklessControllerILi4ELi30ELi75ELi45ELNS_6EOrderE66ELi0ELb0ELi50EE15showRGBInternalERNS_15PixelControllerILS1_66EEE+0x138>
        while(_CYCCNT < (T1+T2-ADJ));
 80a1394:	f8d1 a000 	ldr.w	sl, [r1]
 80a1398:	f1ba 0f60 	cmp.w	sl, #96	; 0x60
 80a139c:	d9fa      	bls.n	80a1394 <_ZN9NSFastLED19ClocklessControllerILi4ELi30ELi75ELi45ELNS_6EOrderE66ELi0ELb0ELi50EE15showRGBInternalERNS_15PixelControllerILS1_66EEE+0x12c>
 80a139e:	e004      	b.n	80a13aa <_ZN9NSFastLED19ClocklessControllerILi4ELi30ELi75ELi45ELNS_6EOrderE66ELi0ELb0ELi50EE15showRGBInternalERNS_15PixelControllerILS1_66EEE+0x142>
        FastPin<DATA_PIN>::fastset(port, lo);
      } else {
        while(_CYCCNT < (T1-(ADJ/2)));
 80a13a0:	f8d1 a000 	ldr.w	sl, [r1]
 80a13a4:	f1ba 0f19 	cmp.w	sl, #25
 80a13a8:	d9fa      	bls.n	80a13a0 <_ZN9NSFastLED19ClocklessControllerILi4ELi30ELi75ELi45ELNS_6EOrderE66ELi0ELb0ELi50EE15showRGBInternalERNS_15PixelControllerILS1_66EEE+0x138>
        FastPin<DATA_PIN>::fastset(port, lo);
      }
      b <<= 1;
 80a13aa:	007f      	lsls	r7, r7, #1
  #endif

#define _CYCCNT (*(volatile uint32_t*)(0xE0001004UL))

  template<int BITS> __attribute__ ((always_inline)) inline static void writeBits(register uint32_t & next_mark, register data_ptr_t port, register data_t hi, register data_t lo, register uint8_t & b)  {
    for(register uint32_t i = BITS-1; i > 0; i--) {
 80a13ac:	f1b9 0901 	subs.w	r9, r9, #1
 80a13b0:	615a      	str	r2, [r3, #20]
        FastPin<DATA_PIN>::fastset(port, lo);
      } else {
        while(_CYCCNT < (T1-(ADJ/2)));
        FastPin<DATA_PIN>::fastset(port, lo);
      }
      b <<= 1;
 80a13b2:	b2ff      	uxtb	r7, r7
  #endif

#define _CYCCNT (*(volatile uint32_t*)(0xE0001004UL))

  template<int BITS> __attribute__ ((always_inline)) inline static void writeBits(register uint32_t & next_mark, register data_ptr_t port, register data_t hi, register data_t lo, register uint8_t & b)  {
    for(register uint32_t i = BITS-1; i > 0; i--) {
 80a13b4:	d1e3      	bne.n	80a137e <_ZN9NSFastLED19ClocklessControllerILi4ELi30ELi75ELi45ELNS_6EOrderE66ELi0ELb0ELi50EE15showRGBInternalERNS_15PixelControllerILS1_66EEE+0x116>
        FastPin<DATA_PIN>::fastset(port, lo);
      }
      b <<= 1;
    }

    while(_CYCCNT < (T1+T2+T3-ADJ));
 80a13b6:	f8d1 9000 	ldr.w	r9, [r1]
 80a13ba:	f1b9 0f8d 	cmp.w	r9, #141	; 0x8d
 80a13be:	d9fa      	bls.n	80a13b6 <_ZN9NSFastLED19ClocklessControllerILi4ELi30ELi75ELi45ELNS_6EOrderE66ELi0ELb0ELi50EE15showRGBInternalERNS_15PixelControllerILS1_66EEE+0x14e>
    FastPin<DATA_PIN>::fastset(port, hi);
    _CYCCNT = 4;

    if(b&0x80) {
 80a13c0:	063f      	lsls	r7, r7, #24
 80a13c2:	615c      	str	r4, [r3, #20]
      b <<= 1;
    }

    while(_CYCCNT < (T1+T2+T3-ADJ));
    FastPin<DATA_PIN>::fastset(port, hi);
    _CYCCNT = 4;
 80a13c4:	602e      	str	r6, [r5, #0]

    if(b&0x80) {
 80a13c6:	d503      	bpl.n	80a13d0 <_ZN9NSFastLED19ClocklessControllerILi4ELi30ELi75ELi45ELNS_6EOrderE66ELi0ELb0ELi50EE15showRGBInternalERNS_15PixelControllerILS1_66EEE+0x168>
      while(_CYCCNT < (T1+T2-ADJ));
 80a13c8:	680f      	ldr	r7, [r1, #0]
 80a13ca:	2f60      	cmp	r7, #96	; 0x60
 80a13cc:	d9fc      	bls.n	80a13c8 <_ZN9NSFastLED19ClocklessControllerILi4ELi30ELi75ELi45ELNS_6EOrderE66ELi0ELb0ELi50EE15showRGBInternalERNS_15PixelControllerILS1_66EEE+0x160>
 80a13ce:	e002      	b.n	80a13d6 <_ZN9NSFastLED19ClocklessControllerILi4ELi30ELi75ELi45ELNS_6EOrderE66ELi0ELb0ELi50EE15showRGBInternalERNS_15PixelControllerILS1_66EEE+0x16e>
      FastPin<DATA_PIN>::fastset(port, lo);
    } else {
      while(_CYCCNT < (T1-(ADJ/2)));
 80a13d0:	680f      	ldr	r7, [r1, #0]
 80a13d2:	2f19      	cmp	r7, #25
 80a13d4:	d9fc      	bls.n	80a13d0 <_ZN9NSFastLED19ClocklessControllerILi4ELi30ELi75ELi45ELNS_6EOrderE66ELi0ELb0ELi50EE15showRGBInternalERNS_15PixelControllerILS1_66EEE+0x168>
 80a13d6:	615a      	str	r2, [r3, #20]
        // Some chipsets pre-cycle the first byte, which means we want to cycle byte 0's dithering separately
        __attribute__((always_inline)) inline void preStepFirstByteDithering() {
            d[RO(0)] = e[RO(0)] - d[RO(0)];
        }

        template<int SLOT>  __attribute__((always_inline)) inline static uint8_t loadByte(PixelController & pc) { return pc.mData[RO(SLOT)]; }
 80a13d8:	6807      	ldr	r7, [r0, #0]
 80a13da:	78bf      	ldrb	r7, [r7, #2]
        template<int SLOT>  __attribute__((always_inline)) inline static uint8_t dither(PixelController & pc, uint8_t b) { return b ? qadd8(b, pc.d[RO(SLOT)]) : 0; }
 80a13dc:	b137      	cbz	r7, 80a13ec <_ZN9NSFastLED19ClocklessControllerILi4ELi30ELi75ELi45ELNS_6EOrderE66ELi0ELb0ELi50EE15showRGBInternalERNS_15PixelControllerILS1_66EEE+0x184>

// qadd8: add one byte to another, saturating at 0xFF
LIB8STATIC uint8_t qadd8( uint8_t i, uint8_t j)
{
#if QADD8_C == 1
    unsigned int t = i + j;
 80a13de:	f890 900a 	ldrb.w	r9, [r0, #10]
 80a13e2:	444f      	add	r7, r9
 80a13e4:	2fff      	cmp	r7, #255	; 0xff
 80a13e6:	bfa8      	it	ge
 80a13e8:	27ff      	movge	r7, #255	; 0xff
    if( t > 255) t = 255;
    return t;
 80a13ea:	b2ff      	uxtb	r7, r7
//         In other words, it computes i * (scale / 256)
//         4 clocks AVR with MUL, 2 clocks ARM
LIB8STATIC uint8_t scale8( uint8_t i, fract8 scale)
{
#if SCALE8_C == 1
    return ((uint16_t)i * (uint16_t)(scale) ) >> 8;
 80a13ec:	f890 9010 	ldrb.w	r9, [r0, #16]
 80a13f0:	fb07 f709 	mul.w	r7, r7, r9
 80a13f4:	f04f 0907 	mov.w	r9, #7
 80a13f8:	f3c7 2707 	ubfx	r7, r7, #8, #8

#define _CYCCNT (*(volatile uint32_t*)(0xE0001004UL))

  template<int BITS> __attribute__ ((always_inline)) inline static void writeBits(register uint32_t & next_mark, register data_ptr_t port, register data_t hi, register data_t lo, register uint8_t & b)  {
    for(register uint32_t i = BITS-1; i > 0; i--) {
      while(_CYCCNT < (T1+T2+T3-ADJ));
 80a13fc:	f8d1 a000 	ldr.w	sl, [r1]
 80a1400:	f1ba 0f8d 	cmp.w	sl, #141	; 0x8d
 80a1404:	d9fa      	bls.n	80a13fc <_ZN9NSFastLED19ClocklessControllerILi4ELi30ELi75ELi45ELNS_6EOrderE66ELi0ELb0ELi50EE15showRGBInternalERNS_15PixelControllerILS1_66EEE+0x194>
      FastPin<DATA_PIN>::fastset(port, hi);
      _CYCCNT = 4;
      if(b&0x80) {
 80a1406:	f017 0f80 	tst.w	r7, #128	; 0x80
 80a140a:	615c      	str	r4, [r3, #20]

  template<int BITS> __attribute__ ((always_inline)) inline static void writeBits(register uint32_t & next_mark, register data_ptr_t port, register data_t hi, register data_t lo, register uint8_t & b)  {
    for(register uint32_t i = BITS-1; i > 0; i--) {
      while(_CYCCNT < (T1+T2+T3-ADJ));
      FastPin<DATA_PIN>::fastset(port, hi);
      _CYCCNT = 4;
 80a140c:	f8c5 c000 	str.w	ip, [r5]
      if(b&0x80) {
 80a1410:	d005      	beq.n	80a141e <_ZN9NSFastLED19ClocklessControllerILi4ELi30ELi75ELi45ELNS_6EOrderE66ELi0ELb0ELi50EE15showRGBInternalERNS_15PixelControllerILS1_66EEE+0x1b6>
        while(_CYCCNT < (T1+T2-ADJ));
 80a1412:	f8d1 a000 	ldr.w	sl, [r1]
 80a1416:	f1ba 0f60 	cmp.w	sl, #96	; 0x60
 80a141a:	d9fa      	bls.n	80a1412 <_ZN9NSFastLED19ClocklessControllerILi4ELi30ELi75ELi45ELNS_6EOrderE66ELi0ELb0ELi50EE15showRGBInternalERNS_15PixelControllerILS1_66EEE+0x1aa>
 80a141c:	e004      	b.n	80a1428 <_ZN9NSFastLED19ClocklessControllerILi4ELi30ELi75ELi45ELNS_6EOrderE66ELi0ELb0ELi50EE15showRGBInternalERNS_15PixelControllerILS1_66EEE+0x1c0>
        FastPin<DATA_PIN>::fastset(port, lo);
      } else {
        while(_CYCCNT < (T1-(ADJ/2)));
 80a141e:	f8d1 a000 	ldr.w	sl, [r1]
 80a1422:	f1ba 0f19 	cmp.w	sl, #25
 80a1426:	d9fa      	bls.n	80a141e <_ZN9NSFastLED19ClocklessControllerILi4ELi30ELi75ELi45ELNS_6EOrderE66ELi0ELb0ELi50EE15showRGBInternalERNS_15PixelControllerILS1_66EEE+0x1b6>
        FastPin<DATA_PIN>::fastset(port, lo);
      }
      b <<= 1;
 80a1428:	007f      	lsls	r7, r7, #1
  #endif

#define _CYCCNT (*(volatile uint32_t*)(0xE0001004UL))

  template<int BITS> __attribute__ ((always_inline)) inline static void writeBits(register uint32_t & next_mark, register data_ptr_t port, register data_t hi, register data_t lo, register uint8_t & b)  {
    for(register uint32_t i = BITS-1; i > 0; i--) {
 80a142a:	f1b9 0901 	subs.w	r9, r9, #1
 80a142e:	615a      	str	r2, [r3, #20]
        FastPin<DATA_PIN>::fastset(port, lo);
      } else {
        while(_CYCCNT < (T1-(ADJ/2)));
        FastPin<DATA_PIN>::fastset(port, lo);
      }
      b <<= 1;
 80a1430:	b2ff      	uxtb	r7, r7
  #endif

#define _CYCCNT (*(volatile uint32_t*)(0xE0001004UL))

  template<int BITS> __attribute__ ((always_inline)) inline static void writeBits(register uint32_t & next_mark, register data_ptr_t port, register data_t hi, register data_t lo, register uint8_t & b)  {
    for(register uint32_t i = BITS-1; i > 0; i--) {
 80a1432:	d1e3      	bne.n	80a13fc <_ZN9NSFastLED19ClocklessControllerILi4ELi30ELi75ELi45ELNS_6EOrderE66ELi0ELb0ELi50EE15showRGBInternalERNS_15PixelControllerILS1_66EEE+0x194>
        FastPin<DATA_PIN>::fastset(port, lo);
      }
      b <<= 1;
    }

    while(_CYCCNT < (T1+T2+T3-ADJ));
 80a1434:	f8d1 9000 	ldr.w	r9, [r1]
 80a1438:	f1b9 0f8d 	cmp.w	r9, #141	; 0x8d
 80a143c:	d9fa      	bls.n	80a1434 <_ZN9NSFastLED19ClocklessControllerILi4ELi30ELi75ELi45ELNS_6EOrderE66ELi0ELb0ELi50EE15showRGBInternalERNS_15PixelControllerILS1_66EEE+0x1cc>
    FastPin<DATA_PIN>::fastset(port, hi);
    _CYCCNT = 4;

    if(b&0x80) {
 80a143e:	063f      	lsls	r7, r7, #24
 80a1440:	615c      	str	r4, [r3, #20]
      b <<= 1;
    }

    while(_CYCCNT < (T1+T2+T3-ADJ));
    FastPin<DATA_PIN>::fastset(port, hi);
    _CYCCNT = 4;
 80a1442:	602e      	str	r6, [r5, #0]

    if(b&0x80) {
 80a1444:	d503      	bpl.n	80a144e <_ZN9NSFastLED19ClocklessControllerILi4ELi30ELi75ELi45ELNS_6EOrderE66ELi0ELb0ELi50EE15showRGBInternalERNS_15PixelControllerILS1_66EEE+0x1e6>
      while(_CYCCNT < (T1+T2-ADJ));
 80a1446:	680f      	ldr	r7, [r1, #0]
 80a1448:	2f60      	cmp	r7, #96	; 0x60
 80a144a:	d9fc      	bls.n	80a1446 <_ZN9NSFastLED19ClocklessControllerILi4ELi30ELi75ELi45ELNS_6EOrderE66ELi0ELb0ELi50EE15showRGBInternalERNS_15PixelControllerILS1_66EEE+0x1de>
 80a144c:	e002      	b.n	80a1454 <_ZN9NSFastLED19ClocklessControllerILi4ELi30ELi75ELi45ELNS_6EOrderE66ELi0ELb0ELi50EE15showRGBInternalERNS_15PixelControllerILS1_66EEE+0x1ec>
      FastPin<DATA_PIN>::fastset(port, lo);
    } else {
      while(_CYCCNT < (T1-(ADJ/2)));
 80a144e:	680f      	ldr	r7, [r1, #0]
 80a1450:	2f19      	cmp	r7, #25
 80a1452:	d9fc      	bls.n	80a144e <_ZN9NSFastLED19ClocklessControllerILi4ELi30ELi75ELi45ELNS_6EOrderE66ELi0ELb0ELi50EE15showRGBInternalERNS_15PixelControllerILS1_66EEE+0x1e6>
 80a1454:	615a      	str	r2, [r3, #20]

        // get the amount to advance the pointer by
        __attribute__((always_inline)) inline int advanceBy() { return mAdvance; }

        // advance the data pointer forward, adjust position counter
         __attribute__((always_inline)) inline void advanceData() { mData += mAdvance; mLen--;}
 80a1456:	6807      	ldr	r7, [r0, #0]
 80a1458:	f890 9011 	ldrb.w	r9, [r0, #17]
 80a145c:	44b9      	add	r9, r7
 80a145e:	6847      	ldr	r7, [r0, #4]
 80a1460:	f8c0 9000 	str.w	r9, [r0]
 80a1464:	3f01      	subs	r7, #1
 80a1466:	6047      	str	r7, [r0, #4]
        // Some chipsets pre-cycle the first byte, which means we want to cycle byte 0's dithering separately
        __attribute__((always_inline)) inline void preStepFirstByteDithering() {
            d[RO(0)] = e[RO(0)] - d[RO(0)];
        }

        template<int SLOT>  __attribute__((always_inline)) inline static uint8_t loadByte(PixelController & pc) { return pc.mData[RO(SLOT)]; }
 80a1468:	f899 7001 	ldrb.w	r7, [r9, #1]
        template<int SLOT>  __attribute__((always_inline)) inline static uint8_t dither(PixelController & pc, uint8_t b) { return b ? qadd8(b, pc.d[RO(SLOT)]) : 0; }
 80a146c:	b137      	cbz	r7, 80a147c <_ZN9NSFastLED19ClocklessControllerILi4ELi30ELi75ELi45ELNS_6EOrderE66ELi0ELb0ELi50EE15showRGBInternalERNS_15PixelControllerILS1_66EEE+0x214>

// qadd8: add one byte to another, saturating at 0xFF
LIB8STATIC uint8_t qadd8( uint8_t i, uint8_t j)
{
#if QADD8_C == 1
    unsigned int t = i + j;
 80a146e:	f890 9009 	ldrb.w	r9, [r0, #9]
 80a1472:	444f      	add	r7, r9
 80a1474:	2fff      	cmp	r7, #255	; 0xff
 80a1476:	bfa8      	it	ge
 80a1478:	27ff      	movge	r7, #255	; 0xff
    if( t > 255) t = 255;
    return t;
 80a147a:	b2ff      	uxtb	r7, r7
//         In other words, it computes i * (scale / 256)
//         4 clocks AVR with MUL, 2 clocks ARM
LIB8STATIC uint8_t scale8( uint8_t i, fract8 scale)
{
#if SCALE8_C == 1
    return ((uint16_t)i * (uint16_t)(scale) ) >> 8;
 80a147c:	f890 900f 	ldrb.w	r9, [r0, #15]
 80a1480:	fb07 f909 	mul.w	r9, r7, r9
 80a1484:	f3c9 2907 	ubfx	r9, r9, #8, #8
    cli();

    uint32_t next_mark = (T1+T2+T3);

    DWT->CYCCNT = 0;
    while(pixels.has(1)) {
 80a1488:	e724      	b.n	80a12d4 <_ZN9NSFastLED19ClocklessControllerILi4ELi30ELi75ELi45ELNS_6EOrderE66ELi0ELb0ELi50EE15showRGBInternalERNS_15PixelControllerILS1_66EEE+0x6c>
  This function enables IRQ interrupts by clearing the I-bit in the CPSR.
  Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_irq(void)
{
  __ASM volatile ("cpsie i");
 80a148a:	b662      	cpsie	i
    This function enables FIQ interrupts by clearing the F-bit in the CPSR.
    Can only be executed in Privileged modes.
 */
__attribute__( ( always_inline ) ) __STATIC_INLINE void __enable_fault_irq(void)
{
  __ASM volatile ("cpsie f");
 80a148c:	b661      	cpsie	f
      sei();
      #endif
    };

    sei();
    return DWT->CYCCNT;
 80a148e:	4b03      	ldr	r3, [pc, #12]	; (80a149c <_ZN9NSFastLED19ClocklessControllerILi4ELi30ELi75ELi45ELNS_6EOrderE66ELi0ELb0ELi50EE15showRGBInternalERNS_15PixelControllerILS1_66EEE+0x234>)
 80a1490:	6858      	ldr	r0, [r3, #4]
  }
 80a1492:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80a1496:	bf00      	nop
 80a1498:	e000edf0 	.word	0xe000edf0
 80a149c:	e0001000 	.word	0xe0001000
 80a14a0:	e0001004 	.word	0xe0001004

080a14a4 <_ZN9NSFastLED15PixelControllerILNS_6EOrderE66EE21init_binary_ditheringEv>:
            mData += 1;
            mAdvance = 4;
        }
#endif

        void init_binary_dithering() {
 80a14a4:	b530      	push	{r4, r5, lr}
                                  (UPDATES_PER_FULL_DITHER_CYCLE>128) )
#define VIRTUAL_BITS RECOMMENDED_VIRTUAL_BITS

            // R is the digther signal 'counter'.
            static byte R = 0;
            R++;
 80a14a6:	4b17      	ldr	r3, [pc, #92]	; (80a1504 <_ZN9NSFastLED15PixelControllerILNS_6EOrderE66EE21init_binary_ditheringEv+0x60>)
            // actual dithering.

            // Setup the initial D and E values
            for(int i = 0; i < 3; i++) {
                    byte s = mScale.raw[i];
                    e[i] = s ? (256/s) + 1 : 0;
 80a14a8:	f44f 7580 	mov.w	r5, #256	; 0x100
            R++;

            // R is wrapped around at 2^ditherBits,
            // so if ditherBits is 2, R will cycle through (0,1,2,3)
            byte ditherBits = VIRTUAL_BITS;
            R &= (0x01 << ditherBits) - 1;
 80a14ac:	781a      	ldrb	r2, [r3, #0]
 80a14ae:	3201      	adds	r2, #1
 80a14b0:	f002 0207 	and.w	r2, r2, #7
            // If 'ditherBits' is 2, Q here will cycle through (0,128,64,192)
            byte Q = 0;

            // Reverse bits in a byte
            {
                if(R & 0x01) { Q |= 0x80; }
 80a14b4:	f012 0f01 	tst.w	r2, #1
            R++;

            // R is wrapped around at 2^ditherBits,
            // so if ditherBits is 2, R will cycle through (0,1,2,3)
            byte ditherBits = VIRTUAL_BITS;
            R &= (0x01 << ditherBits) - 1;
 80a14b8:	701a      	strb	r2, [r3, #0]
            // If 'ditherBits' is 2, Q here will cycle through (0,128,64,192)
            byte Q = 0;

            // Reverse bits in a byte
            {
                if(R & 0x01) { Q |= 0x80; }
 80a14ba:	bf0c      	ite	eq
 80a14bc:	2300      	moveq	r3, #0
 80a14be:	2380      	movne	r3, #128	; 0x80
                if(R & 0x02) { Q |= 0x40; }
 80a14c0:	0791      	lsls	r1, r2, #30
 80a14c2:	bf44      	itt	mi
 80a14c4:	f043 0340 	orrmi.w	r3, r3, #64	; 0x40
 80a14c8:	b2db      	uxtbmi	r3, r3
                if(R & 0x04) { Q |= 0x20; }
 80a14ca:	0752      	lsls	r2, r2, #29
 80a14cc:	bf48      	it	mi
 80a14ce:	f043 0320 	orrmi.w	r3, r3, #32
            // Now we adjust Q to fall in the center of each range,
            // instead of at the start of the range.
            // If ditherBits is 2, Q will be (0, 128, 64, 192) at first,
            // and this adjustment makes it (31, 159, 95, 223).
            if( ditherBits < 8) {
                Q += 0x01 << (7 - ditherBits);
 80a14d2:	3310      	adds	r3, #16
 80a14d4:	f100 010a 	add.w	r1, r0, #10
 80a14d8:	b2da      	uxtb	r2, r3
 80a14da:	300d      	adds	r0, #13
            // which is added to pixel values to affect the
            // actual dithering.

            // Setup the initial D and E values
            for(int i = 0; i < 3; i++) {
                    byte s = mScale.raw[i];
 80a14dc:	790b      	ldrb	r3, [r1, #4]
                    e[i] = s ? (256/s) + 1 : 0;
 80a14de:	b11b      	cbz	r3, 80a14e8 <_ZN9NSFastLED15PixelControllerILNS_6EOrderE66EE21init_binary_ditheringEv+0x44>
 80a14e0:	fb95 f3f3 	sdiv	r3, r5, r3
 80a14e4:	3301      	adds	r3, #1
 80a14e6:	b2db      	uxtb	r3, r3
                    d[i] = scale8(Q, e[i]);
 80a14e8:	fb03 f402 	mul.w	r4, r3, r2
            // actual dithering.

            // Setup the initial D and E values
            for(int i = 0; i < 3; i++) {
                    byte s = mScale.raw[i];
                    e[i] = s ? (256/s) + 1 : 0;
 80a14ec:	f801 3f01 	strb.w	r3, [r1, #1]!
                    d[i] = scale8(Q, e[i]);
 80a14f0:	1224      	asrs	r4, r4, #8
 80a14f2:	f801 4c03 	strb.w	r4, [r1, #-3]
                    if(e[i]) e[i]--;
 80a14f6:	b10b      	cbz	r3, 80a14fc <_ZN9NSFastLED15PixelControllerILNS_6EOrderE66EE21init_binary_ditheringEv+0x58>
 80a14f8:	3b01      	subs	r3, #1
 80a14fa:	700b      	strb	r3, [r1, #0]
            // D and E form the "scaled dither signal"
            // which is added to pixel values to affect the
            // actual dithering.

            // Setup the initial D and E values
            for(int i = 0; i < 3; i++) {
 80a14fc:	4288      	cmp	r0, r1
 80a14fe:	d1ed      	bne.n	80a14dc <_ZN9NSFastLED15PixelControllerILNS_6EOrderE66EE21init_binary_ditheringEv+0x38>
                    e[i] = s ? (256/s) + 1 : 0;
                    d[i] = scale8(Q, e[i]);
                    if(e[i]) e[i]--;
            }
#endif
        }
 80a1500:	bd30      	pop	{r4, r5, pc}
 80a1502:	bf00      	nop
 80a1504:	20000388 	.word	0x20000388

080a1508 <_ZN9NSFastLED19ClocklessControllerILi4ELi30ELi75ELi45ELNS_6EOrderE66ELi0ELb0ELi50EE4showEPKNS_4CRGBEiS3_>:
    mWait.wait();
    showRGBInternal(pixels);
    mWait.mark();
  }

  virtual void show(const struct CRGB *rgbdata, int nLeds, CRGB scale) {
 80a1508:	b510      	push	{r4, lr}
 80a150a:	b086      	sub	sp, #24
            enable_dithering(dither);
            mData += skip;
            mAdvance = (advance) ? 3+skip : 0;
        }

        PixelController(const CRGB *d, int len, CRGB & s, EDitherMode dither = BINARY_DITHER) : mData((const uint8_t*)d), mLen(len), mScale(s) {
 80a150c:	9202      	str	r2, [sp, #8]
    }

    // allow copy construction
	inline CRGB(const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
 80a150e:	781a      	ldrb	r2, [r3, #0]
 80a1510:	4604      	mov	r4, r0
 80a1512:	7c80      	ldrb	r0, [r0, #18]
 80a1514:	f88d 2012 	strb.w	r2, [sp, #18]
        g = rhs.g;
 80a1518:	785a      	ldrb	r2, [r3, #1]
        b = rhs.b;
 80a151a:	789b      	ldrb	r3, [r3, #2]
            return mLen >= n;
        }

        // toggle dithering enable
        void enable_dithering(EDitherMode dither) {
            switch(dither) {
 80a151c:	2801      	cmp	r0, #1
            enable_dithering(dither);
            mData += skip;
            mAdvance = (advance) ? 3+skip : 0;
        }

        PixelController(const CRGB *d, int len, CRGB & s, EDitherMode dither = BINARY_DITHER) : mData((const uint8_t*)d), mLen(len), mScale(s) {
 80a151e:	9101      	str	r1, [sp, #4]

    // allow copy construction
	inline CRGB(const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
        g = rhs.g;
 80a1520:	f88d 2013 	strb.w	r2, [sp, #19]
        b = rhs.b;
 80a1524:	f88d 3014 	strb.w	r3, [sp, #20]
            return mLen >= n;
        }

        // toggle dithering enable
        void enable_dithering(EDitherMode dither) {
            switch(dither) {
 80a1528:	d103      	bne.n	80a1532 <_ZN9NSFastLED19ClocklessControllerILi4ELi30ELi75ELi45ELNS_6EOrderE66ELi0ELb0ELi50EE4showEPKNS_4CRGBEiS3_+0x2a>
                case BINARY_DITHER: init_binary_dithering(); break;
 80a152a:	a801      	add	r0, sp, #4
 80a152c:	f7ff ffba 	bl	80a14a4 <_ZN9NSFastLED15PixelControllerILNS_6EOrderE66EE21init_binary_ditheringEv>
 80a1530:	e00c      	b.n	80a154c <_ZN9NSFastLED19ClocklessControllerILi4ELi30ELi75ELi45ELNS_6EOrderE66ELi0ELb0ELi50EE4showEPKNS_4CRGBEiS3_+0x44>
                default: d[0]=d[1]=d[2]=e[0]=e[1]=e[2]=0; break;
 80a1532:	2300      	movs	r3, #0
 80a1534:	f88d 3011 	strb.w	r3, [sp, #17]
 80a1538:	f88d 3010 	strb.w	r3, [sp, #16]
 80a153c:	f88d 300f 	strb.w	r3, [sp, #15]
 80a1540:	f88d 300e 	strb.w	r3, [sp, #14]
 80a1544:	f88d 300d 	strb.w	r3, [sp, #13]
 80a1548:	f88d 300c 	strb.w	r3, [sp, #12]
            mAdvance = (advance) ? 3+skip : 0;
        }

        PixelController(const CRGB *d, int len, CRGB & s, EDitherMode dither = BINARY_DITHER) : mData((const uint8_t*)d), mLen(len), mScale(s) {
            enable_dithering(dither);
            mAdvance = 3;
 80a154c:	2303      	movs	r3, #3
    PixelController<RGB_ORDER> pixels(rgbdata, nLeds, scale, getDither());

    mWait.wait();
 80a154e:	f104 0020 	add.w	r0, r4, #32
 80a1552:	f88d 3015 	strb.w	r3, [sp, #21]
 80a1556:	f7ff fe7c 	bl	80a1252 <_ZN9NSFastLED8CMinWaitILi50EE4waitEv>
    showRGBInternal(pixels);
 80a155a:	a801      	add	r0, sp, #4
 80a155c:	f7ff fe84 	bl	80a1268 <_ZN9NSFastLED19ClocklessControllerILi4ELi30ELi75ELi45ELNS_6EOrderE66ELi0ELb0ELi50EE15showRGBInternalERNS_15PixelControllerILS1_66EEE>
 80a1560:	f002 f9b6 	bl	80a38d0 <HAL_Timer_Get_Micro_Seconds>

	void mark() { mLastMicros = micros() & 0xFFFF; }
 80a1564:	8420      	strh	r0, [r4, #32]
    mWait.mark();
  }
 80a1566:	b006      	add	sp, #24
 80a1568:	bd10      	pop	{r4, pc}

080a156a <_ZN9NSFastLED19ClocklessControllerILi4ELi30ELi75ELi45ELNS_6EOrderE66ELi0ELb0ELi50EE9showColorERKNS_4CRGBEiS3_>:
  }

protected:

  // set all the leds on the controller to a given color
  virtual void showColor(const struct CRGB & rgbdata, int nLeds, CRGB scale) {
 80a156a:	b510      	push	{r4, lr}
 80a156c:	b086      	sub	sp, #24
        }

        PixelController(const CRGB &d, int len, CRGB & s, EDitherMode dither = BINARY_DITHER) : mData((const uint8_t*)&d), mLen(len), mScale(s) {
 80a156e:	9202      	str	r2, [sp, #8]
    }

    // allow copy construction
	inline CRGB(const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
 80a1570:	781a      	ldrb	r2, [r3, #0]
 80a1572:	4604      	mov	r4, r0
 80a1574:	7c80      	ldrb	r0, [r0, #18]
 80a1576:	f88d 2012 	strb.w	r2, [sp, #18]
        g = rhs.g;
 80a157a:	785a      	ldrb	r2, [r3, #1]
        b = rhs.b;
 80a157c:	789b      	ldrb	r3, [r3, #2]
            return mLen >= n;
        }

        // toggle dithering enable
        void enable_dithering(EDitherMode dither) {
            switch(dither) {
 80a157e:	2801      	cmp	r0, #1
        PixelController(const CRGB *d, int len, CRGB & s, EDitherMode dither = BINARY_DITHER) : mData((const uint8_t*)d), mLen(len), mScale(s) {
            enable_dithering(dither);
            mAdvance = 3;
        }

        PixelController(const CRGB &d, int len, CRGB & s, EDitherMode dither = BINARY_DITHER) : mData((const uint8_t*)&d), mLen(len), mScale(s) {
 80a1580:	9101      	str	r1, [sp, #4]

    // allow copy construction
	inline CRGB(const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
        g = rhs.g;
 80a1582:	f88d 2013 	strb.w	r2, [sp, #19]
        b = rhs.b;
 80a1586:	f88d 3014 	strb.w	r3, [sp, #20]
            return mLen >= n;
        }

        // toggle dithering enable
        void enable_dithering(EDitherMode dither) {
            switch(dither) {
 80a158a:	d103      	bne.n	80a1594 <_ZN9NSFastLED19ClocklessControllerILi4ELi30ELi75ELi45ELNS_6EOrderE66ELi0ELb0ELi50EE9showColorERKNS_4CRGBEiS3_+0x2a>
                case BINARY_DITHER: init_binary_dithering(); break;
 80a158c:	a801      	add	r0, sp, #4
 80a158e:	f7ff ff89 	bl	80a14a4 <_ZN9NSFastLED15PixelControllerILNS_6EOrderE66EE21init_binary_ditheringEv>
 80a1592:	e00c      	b.n	80a15ae <_ZN9NSFastLED19ClocklessControllerILi4ELi30ELi75ELi45ELNS_6EOrderE66ELi0ELb0ELi50EE9showColorERKNS_4CRGBEiS3_+0x44>
                default: d[0]=d[1]=d[2]=e[0]=e[1]=e[2]=0; break;
 80a1594:	2300      	movs	r3, #0
 80a1596:	f88d 3011 	strb.w	r3, [sp, #17]
 80a159a:	f88d 3010 	strb.w	r3, [sp, #16]
 80a159e:	f88d 300f 	strb.w	r3, [sp, #15]
 80a15a2:	f88d 300e 	strb.w	r3, [sp, #14]
 80a15a6:	f88d 300d 	strb.w	r3, [sp, #13]
 80a15aa:	f88d 300c 	strb.w	r3, [sp, #12]
            mAdvance = 3;
        }

        PixelController(const CRGB &d, int len, CRGB & s, EDitherMode dither = BINARY_DITHER) : mData((const uint8_t*)&d), mLen(len), mScale(s) {
            enable_dithering(dither);
            mAdvance = 0;
 80a15ae:	2300      	movs	r3, #0
    PixelController<RGB_ORDER> pixels(rgbdata, nLeds, scale, getDither());

    mWait.wait();
 80a15b0:	f104 0020 	add.w	r0, r4, #32
 80a15b4:	f88d 3015 	strb.w	r3, [sp, #21]
 80a15b8:	f7ff fe4b 	bl	80a1252 <_ZN9NSFastLED8CMinWaitILi50EE4waitEv>
    showRGBInternal(pixels);
 80a15bc:	a801      	add	r0, sp, #4
 80a15be:	f7ff fe53 	bl	80a1268 <_ZN9NSFastLED19ClocklessControllerILi4ELi30ELi75ELi45ELNS_6EOrderE66ELi0ELb0ELi50EE15showRGBInternalERNS_15PixelControllerILS1_66EEE>
 80a15c2:	f002 f985 	bl	80a38d0 <HAL_Timer_Get_Micro_Seconds>
 80a15c6:	8420      	strh	r0, [r4, #32]
    mWait.mark();
  }
 80a15c8:	b006      	add	sp, #24
 80a15ca:	bd10      	pop	{r4, pc}

080a15cc <_GLOBAL__sub_I_leds>:
    }
}
 80a15cc:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
} // namespace particle

// particle::Flag<TagT, ValueT>
template<typename TagT, typename ValueT>
inline particle::Flag<TagT, ValueT>::Flag(ValueT val) :
        val_(val) {
 80a15d0:	4b30      	ldr	r3, [pc, #192]	; (80a1694 <_GLOBAL__sub_I_leds+0xc8>)
 80a15d2:	b085      	sub	sp, #20
 80a15d4:	2400      	movs	r4, #0
 80a15d6:	701c      	strb	r4, [r3, #0]
 80a15d8:	f002 f9c2 	bl	80a3960 <HAL_Pin_Map>
    {
    }

    // allow construction from R, G, B
    inline CRGB( uint8_t ir, uint8_t ig, uint8_t ib)  __attribute__((always_inline))
        : r(ir), g(ig), b(ib)
 80a15dc:	4b2e      	ldr	r3, [pc, #184]	; (80a1698 <_GLOBAL__sub_I_leds+0xcc>)
 80a15de:	22c8      	movs	r2, #200	; 0xc8
 80a15e0:	701a      	strb	r2, [r3, #0]
 80a15e2:	705a      	strb	r2, [r3, #1]
 80a15e4:	709a      	strb	r2, [r3, #2]
// Timer functions:
//
void publishState();
void setBrightnessByDistance();

MQTT client(MQTT_HOST, 1883, mqtt_callback);
 80a15e6:	4e2d      	ldr	r6, [pc, #180]	; (80a169c <_GLOBAL__sub_I_leds+0xd0>)
 80a15e8:	4b2d      	ldr	r3, [pc, #180]	; (80a16a0 <_GLOBAL__sub_I_leds+0xd4>)
 80a15ea:	4d2e      	ldr	r5, [pc, #184]	; (80a16a4 <_GLOBAL__sub_I_leds+0xd8>)
 80a15ec:	701c      	strb	r4, [r3, #0]
 80a15ee:	705c      	strb	r4, [r3, #1]
 80a15f0:	709c      	strb	r4, [r3, #2]
 80a15f2:	f240 725b 	movw	r2, #1883	; 0x75b
 80a15f6:	4b2c      	ldr	r3, [pc, #176]	; (80a16a8 <_GLOBAL__sub_I_leds+0xdc>)
 80a15f8:	492c      	ldr	r1, [pc, #176]	; (80a16ac <_GLOBAL__sub_I_leds+0xe0>)
 80a15fa:	4630      	mov	r0, r6
 80a15fc:	f001 fc0c 	bl	80a2e18 <_ZN4MQTTC1EPctPFvS0_PhjE>
 80a1600:	462a      	mov	r2, r5
 80a1602:	492b      	ldr	r1, [pc, #172]	; (80a16b0 <_GLOBAL__sub_I_leds+0xe4>)
 80a1604:	4630      	mov	r0, r6
 80a1606:	f003 fdc1 	bl	80a518c <__aeabi_atexit>
Timer PublisherTimer(5000, publishState);
 80a160a:	f8df 90cc 	ldr.w	r9, [pc, #204]	; 80a16d8 <_GLOBAL__sub_I_leds+0x10c>
	  { return true; }

      private:
	static void
	_M_init_functor(_Any_data& __functor, _Functor&& __f, true_type)
	{ new (__functor._M_access()) _Functor(std::move(__f)); }
 80a160e:	4b29      	ldr	r3, [pc, #164]	; (80a16b4 <_GLOBAL__sub_I_leds+0xe8>)
	typedef _Function_handler<_Signature_type, _Functor> _My_handler;

	if (_My_handler::_M_not_empty_function(__f))
	  {
	    _My_handler::_M_init_functor(_M_functor, std::move(__f));
	    _M_invoker = &_My_handler::_M_invoke;
 80a1610:	f8df 80c8 	ldr.w	r8, [pc, #200]	; 80a16dc <_GLOBAL__sub_I_leds+0x110>
	    _M_manager = &_My_handler::_M_manager;
 80a1614:	4e28      	ldr	r6, [pc, #160]	; (80a16b8 <_GLOBAL__sub_I_leds+0xec>)
 80a1616:	466a      	mov	r2, sp
	  { return true; }

      private:
	static void
	_M_init_functor(_Any_data& __functor, _Functor&& __f, true_type)
	{ new (__functor._M_access()) _Functor(std::move(__f)); }
 80a1618:	9300      	str	r3, [sp, #0]
 80a161a:	f241 3188 	movw	r1, #5000	; 0x1388
 80a161e:	4623      	mov	r3, r4
 80a1620:	4f26      	ldr	r7, [pc, #152]	; (80a16bc <_GLOBAL__sub_I_leds+0xf0>)
 80a1622:	4648      	mov	r0, r9

	if (_My_handler::_M_not_empty_function(__f))
	  {
	    _My_handler::_M_init_functor(_M_functor, std::move(__f));
	    _M_invoker = &_My_handler::_M_invoke;
	    _M_manager = &_My_handler::_M_manager;
 80a1624:	9602      	str	r6, [sp, #8]
	typedef _Function_handler<_Signature_type, _Functor> _My_handler;

	if (_My_handler::_M_not_empty_function(__f))
	  {
	    _My_handler::_M_init_functor(_M_functor, std::move(__f));
	    _M_invoker = &_My_handler::_M_invoke;
 80a1626:	f8cd 800c 	str.w	r8, [sp, #12]
 80a162a:	f7fe ffc9 	bl	80a05c0 <_ZN5TimerC1EjSt8functionIFvvEEb>
   *  @ingroup functors
   *
   *  Polymorphic function wrapper.
   */
  template<typename _Res, typename... _ArgTypes>
    class function<_Res(_ArgTypes...)>
 80a162e:	4668      	mov	r0, sp
 80a1630:	f7fe ff30 	bl	80a0494 <_ZNSt14_Function_baseD1Ev>
 80a1634:	462a      	mov	r2, r5
 80a1636:	4639      	mov	r1, r7
 80a1638:	4648      	mov	r0, r9
 80a163a:	f003 fda7 	bl	80a518c <__aeabi_atexit>

	if (_My_handler::_M_not_empty_function(__f))
	  {
	    _My_handler::_M_init_functor(_M_functor, std::move(__f));
	    _M_invoker = &_My_handler::_M_invoke;
	    _M_manager = &_My_handler::_M_manager;
 80a163e:	9602      	str	r6, [sp, #8]
	  { return true; }

      private:
	static void
	_M_init_functor(_Any_data& __functor, _Functor&& __f, true_type)
	{ new (__functor._M_access()) _Functor(std::move(__f)); }
 80a1640:	4b1f      	ldr	r3, [pc, #124]	; (80a16c0 <_GLOBAL__sub_I_leds+0xf4>)
Timer DistanceSonarTimer(500, setBrightnessByDistance);
 80a1642:	4e20      	ldr	r6, [pc, #128]	; (80a16c4 <_GLOBAL__sub_I_leds+0xf8>)
 80a1644:	466a      	mov	r2, sp
 80a1646:	9300      	str	r3, [sp, #0]
 80a1648:	f44f 71fa 	mov.w	r1, #500	; 0x1f4
 80a164c:	4623      	mov	r3, r4
 80a164e:	4630      	mov	r0, r6

ApplicationWatchdog wd(60000, System.reset);
 80a1650:	4c1d      	ldr	r4, [pc, #116]	; (80a16c8 <_GLOBAL__sub_I_leds+0xfc>)
	typedef _Function_handler<_Signature_type, _Functor> _My_handler;

	if (_My_handler::_M_not_empty_function(__f))
	  {
	    _My_handler::_M_init_functor(_M_functor, std::move(__f));
	    _M_invoker = &_My_handler::_M_invoke;
 80a1652:	f8cd 800c 	str.w	r8, [sp, #12]
void publishState();
void setBrightnessByDistance();

MQTT client(MQTT_HOST, 1883, mqtt_callback);
Timer PublisherTimer(5000, publishState);
Timer DistanceSonarTimer(500, setBrightnessByDistance);
 80a1656:	f7fe ffb3 	bl	80a05c0 <_ZN5TimerC1EjSt8functionIFvvEEb>
   *  @ingroup functors
   *
   *  Polymorphic function wrapper.
   */
  template<typename _Res, typename... _ArgTypes>
    class function<_Res(_ArgTypes...)>
 80a165a:	4668      	mov	r0, sp
 80a165c:	f7fe ff1a 	bl	80a0494 <_ZNSt14_Function_baseD1Ev>
 80a1660:	462a      	mov	r2, r5
 80a1662:	4639      	mov	r1, r7
 80a1664:	4630      	mov	r0, r6
 80a1666:	f003 fd91 	bl	80a518c <__aeabi_atexit>

ApplicationWatchdog wd(60000, System.reset);
 80a166a:	f44f 7300 	mov.w	r3, #512	; 0x200
 80a166e:	4a17      	ldr	r2, [pc, #92]	; (80a16cc <_GLOBAL__sub_I_leds+0x100>)
 80a1670:	f64e 2160 	movw	r1, #60000	; 0xea60
 80a1674:	4620      	mov	r0, r4
 80a1676:	f7fe ff49 	bl	80a050c <_ZN19ApplicationWatchdogC1EjPFvvEj>
 80a167a:	462a      	mov	r2, r5
 80a167c:	4914      	ldr	r1, [pc, #80]	; (80a16d0 <_GLOBAL__sub_I_leds+0x104>)
 80a167e:	4620      	mov	r0, r4
 80a1680:	f003 fd84 	bl	80a518c <__aeabi_atexit>
#endif

#include "timer_hal.h"
#include "delay_hal.h"

inline system_tick_t millis(void) { return HAL_Timer_Get_Milli_Seconds(); }
 80a1684:	f002 f92c 	bl	80a38e0 <HAL_Timer_Get_Milli_Seconds>
int getDisplayMode(String command);
int setFgColor(String command);
int setBgColor(String command);

#define ONE_DAY_MILLIS (24 * 60 * 60 * 1000)
unsigned long lastSync = millis();
 80a1688:	4b12      	ldr	r3, [pc, #72]	; (80a16d4 <_GLOBAL__sub_I_leds+0x108>)
 80a168a:	6018      	str	r0, [r3, #0]
    delay(10);

    if (client.isConnected()) {
        client.loop();
    }
}
 80a168c:	b005      	add	sp, #20
 80a168e:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 80a1692:	bf00      	nop
 80a1694:	200004fb 	.word	0x200004fb
 80a1698:	20000590 	.word	0x20000590
 80a169c:	200004fc 	.word	0x200004fc
 80a16a0:	200004f8 	.word	0x200004f8
 80a16a4:	20000380 	.word	0x20000380
 80a16a8:	080a0d21 	.word	0x080a0d21
 80a16ac:	080a6676 	.word	0x080a6676
 80a16b0:	080a359d 	.word	0x080a359d
 80a16b4:	080a0709 	.word	0x080a0709
 80a16b8:	080a040d 	.word	0x080a040d
 80a16bc:	080a066d 	.word	0x080a066d
 80a16c0:	080a0bb5 	.word	0x080a0bb5
 80a16c4:	20000598 	.word	0x20000598
 80a16c8:	20000554 	.word	0x20000554
 80a16cc:	080a4ccd 	.word	0x080a4ccd
 80a16d0:	080a04c9 	.word	0x080a04c9
 80a16d4:	2000056c 	.word	0x2000056c
 80a16d8:	20000574 	.word	0x20000574
 80a16dc:	080a0409 	.word	0x080a0409

080a16e0 <_Z15loopSingleColorv>:
        leds[i] = fg_color;
    }
}

void loopSingleColor()
{
 80a16e0:	b530      	push	{r4, r5, lr}
    }

    // allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
 80a16e2:	4b07      	ldr	r3, [pc, #28]	; (80a1700 <_Z15loopSingleColorv+0x20>)
 80a16e4:	4907      	ldr	r1, [pc, #28]	; (80a1704 <_Z15loopSingleColorv+0x24>)
 80a16e6:	781d      	ldrb	r5, [r3, #0]
        g = rhs.g;
 80a16e8:	785c      	ldrb	r4, [r3, #1]
        b = rhs.b;
 80a16ea:	7898      	ldrb	r0, [r3, #2]
 80a16ec:	2300      	movs	r3, #0
    }

    // allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
 80a16ee:	185a      	adds	r2, r3, r1
 80a16f0:	545d      	strb	r5, [r3, r1]
 80a16f2:	3303      	adds	r3, #3
    uint16_t i = 0;

    for (i = 0; i < NUM_LEDS; i++) {
 80a16f4:	f5b3 7fa2 	cmp.w	r3, #324	; 0x144
        g = rhs.g;
 80a16f8:	7054      	strb	r4, [r2, #1]
        b = rhs.b;
 80a16fa:	7090      	strb	r0, [r2, #2]
 80a16fc:	d1f7      	bne.n	80a16ee <_Z15loopSingleColorv+0xe>
        leds[i] = fg_color;
    }
}
 80a16fe:	bd30      	pop	{r4, r5, pc}
 80a1700:	20000590 	.word	0x20000590
 80a1704:	200003b4 	.word	0x200003b4

080a1708 <_Z16setupSingleColorv>:
 80a1708:	f7ff bfea 	b.w	80a16e0 <_Z15loopSingleColorv>

080a170c <_GLOBAL__sub_I__Z16setupSingleColorv>:
 80a170c:	f002 b928 	b.w	80a3960 <HAL_Pin_Map>

080a1710 <_ZN9NSFastLEDL7random8Ev>:
extern uint16_t rand16seed;// = RAND16_SEED;


LIB8STATIC uint8_t random8()
{
    rand16seed = (rand16seed * RAND16_2053) + RAND16_13849;
 80a1710:	4a07      	ldr	r2, [pc, #28]	; (80a1730 <_ZN9NSFastLEDL7random8Ev+0x20>)
 80a1712:	8813      	ldrh	r3, [r2, #0]
 80a1714:	eb03 2043 	add.w	r0, r3, r3, lsl #9
 80a1718:	eb03 0080 	add.w	r0, r3, r0, lsl #2
 80a171c:	f500 5058 	add.w	r0, r0, #13824	; 0x3600
 80a1720:	3019      	adds	r0, #25
 80a1722:	b280      	uxth	r0, r0
 80a1724:	8010      	strh	r0, [r2, #0]
    // return the sum of the high and low bytes, for better
    //  mixing and non-sequential correlation
    return (uint8_t)(((uint8_t)(rand16seed & 0xFF)) +
                     ((uint8_t)(rand16seed >> 8)));
 80a1726:	eb00 2010 	add.w	r0, r0, r0, lsr #8
}
 80a172a:	b2c0      	uxtb	r0, r0
 80a172c:	4770      	bx	lr
 80a172e:	bf00      	nop
 80a1730:	20000310 	.word	0x20000310

080a1734 <_ZN9NSFastLED13CRGBPalette16aSERA16_Km>:
    {
        for( uint8_t i = 0; i < 16; i++) {
            entries[i] =  pgm_read_dword_near( rhs + i);
        }
    }
    CRGBPalette16& operator=( const TProgmemRGBPalette16& rhs)
 80a1734:	4603      	mov	r3, r0
 80a1736:	b530      	push	{r4, r5, lr}
 80a1738:	3904      	subs	r1, #4
 80a173a:	f100 0430 	add.w	r4, r0, #48	; 0x30
    {
        for( uint8_t i = 0; i < 16; i++) {
            entries[i] =  pgm_read_dword_near( rhs + i);
 80a173e:	f851 2f04 	ldr.w	r2, [r1, #4]!
 80a1742:	3303      	adds	r3, #3
    }

    // allow assignment from 32-bit (really 24-bit) 0xRRGGBB color code
	inline CRGB& operator= (const uint32_t colorcode) __attribute__((always_inline))
    {
        r = (colorcode >> 16) & 0xFF;
 80a1744:	0c15      	lsrs	r5, r2, #16
 80a1746:	f803 5c03 	strb.w	r5, [r3, #-3]
        g = (colorcode >>  8) & 0xFF;
 80a174a:	0a15      	lsrs	r5, r2, #8
 80a174c:	f803 5c02 	strb.w	r5, [r3, #-2]
        b = (colorcode >>  0) & 0xFF;
 80a1750:	f803 2c01 	strb.w	r2, [r3, #-1]
            entries[i] =  pgm_read_dword_near( rhs + i);
        }
    }
    CRGBPalette16& operator=( const TProgmemRGBPalette16& rhs)
    {
        for( uint8_t i = 0; i < 16; i++) {
 80a1754:	42a3      	cmp	r3, r4
 80a1756:	d1f2      	bne.n	80a173e <_ZN9NSFastLED13CRGBPalette16aSERA16_Km+0xa>
            entries[i] =  pgm_read_dword_near( rhs + i);
        }
        return *this;
    }
 80a1758:	bd30      	pop	{r4, r5, pc}
	...

080a175c <_Z26mapNoiseToLEDsUsingPalettev>:

CRGBPalette16 currentPalette(PartyColors_p);
uint8_t       colorLoop = 1;

void mapNoiseToLEDsUsingPalette()
{
 80a175c:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80a1760:	4f23      	ldr	r7, [pc, #140]	; (80a17f0 <_Z26mapNoiseToLEDsUsingPalettev+0x94>)
 80a1762:	b085      	sub	sp, #20
 80a1764:	46b8      	mov	r8, r7
    static uint8_t ihue = 0;

    for (int i = 0; i < kMatrixHeight; i++) {
 80a1766:	2400      	movs	r4, #0
 80a1768:	261b      	movs	r6, #27
 80a176a:	fb06 7904 	mla	r9, r6, r4, r7

            uint8_t index = noise[j][i];
            uint8_t bri =   noise[i][j];

            // if this palette is a 'loop', add a slowly-changing base value
            if (colorLoop) {
 80a176e:	f8df a090 	ldr.w	sl, [pc, #144]	; 80a1800 <_Z26mapNoiseToLEDsUsingPalettev+0xa4>
                index += ihue;
 80a1772:	f8df b088 	ldr.w	fp, [pc, #136]	; 80a17fc <_Z26mapNoiseToLEDsUsingPalettev+0xa0>

void mapNoiseToLEDsUsingPalette()
{
    static uint8_t ihue = 0;

    for (int i = 0; i < kMatrixHeight; i++) {
 80a1776:	2500      	movs	r5, #0
        for (int j = 0; j < kMatrixWidth; j++) {
            // We use the value at the (i,j) coordinate in the noise
            // array for our brightness, and the flipped value from (j,i)
            // for our pixel's index into the color palette.

            uint8_t index = noise[j][i];
 80a1778:	fb06 f205 	mul.w	r2, r6, r5
            uint8_t bri =   noise[i][j];

            // if this palette is a 'loop', add a slowly-changing base value
            if (colorLoop) {
 80a177c:	f89a 1000 	ldrb.w	r1, [sl]
        for (int j = 0; j < kMatrixWidth; j++) {
            // We use the value at the (i,j) coordinate in the noise
            // array for our brightness, and the flipped value from (j,i)
            // for our pixel's index into the color palette.

            uint8_t index = noise[j][i];
 80a1780:	eb08 0304 	add.w	r3, r8, r4
 80a1784:	5c9a      	ldrb	r2, [r3, r2]
            uint8_t bri =   noise[i][j];
 80a1786:	f819 3005 	ldrb.w	r3, [r9, r5]

            // if this palette is a 'loop', add a slowly-changing base value
            if (colorLoop) {
 80a178a:	b119      	cbz	r1, 80a1794 <_Z26mapNoiseToLEDsUsingPalettev+0x38>
                index += ihue;
 80a178c:	f89b 1000 	ldrb.w	r1, [fp]
 80a1790:	440a      	add	r2, r1
 80a1792:	b2d2      	uxtb	r2, r2
            }

            // brighten up, as the color palette itself often contains the
            // light/dark dynamic range desired
            if (bri > 127) {
 80a1794:	0619      	lsls	r1, r3, #24
//         In other words, it computes i * (scale / 256)
//         4 clocks AVR with MUL, 2 clocks ARM
LIB8STATIC uint8_t scale8( uint8_t i, fract8 scale)
{
#if SCALE8_C == 1
    return ((uint16_t)i * (uint16_t)(scale) ) >> 8;
 80a1796:	bf5e      	ittt	pl
 80a1798:	005b      	lslpl	r3, r3, #1
 80a179a:	b2db      	uxtbpl	r3, r3
 80a179c:	435b      	mulpl	r3, r3
                bri = 255;
            } else {
                bri = dim8_raw(bri * 2);
            }

            CRGB color = ColorFromPalette(currentPalette, index, bri);
 80a179e:	f04f 0101 	mov.w	r1, #1
 80a17a2:	bf54      	ite	pl
 80a17a4:	f3c3 2307 	ubfxpl	r3, r3, #8, #8
            }

            // brighten up, as the color palette itself often contains the
            // light/dark dynamic range desired
            if (bri > 127) {
                bri = 255;
 80a17a8:	23ff      	movmi	r3, #255	; 0xff
            } else {
                bri = dim8_raw(bri * 2);
            }

            CRGB color = ColorFromPalette(currentPalette, index, bri);
 80a17aa:	9100      	str	r1, [sp, #0]
 80a17ac:	a803      	add	r0, sp, #12
 80a17ae:	4911      	ldr	r1, [pc, #68]	; (80a17f4 <_Z26mapNoiseToLEDsUsingPalettev+0x98>)
 80a17b0:	f000 fff4 	bl	80a279c <_ZN9NSFastLED16ColorFromPaletteERKNS_13CRGBPalette16EhhNS_10TBlendTypeE>
            leds[XY(i, j)] = color;
 80a17b4:	b2e9      	uxtb	r1, r5
 80a17b6:	b2e0      	uxtb	r0, r4
 80a17b8:	f000 fe2a 	bl	80a2410 <_Z2XYhh>
    }

    // allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
 80a17bc:	4a0e      	ldr	r2, [pc, #56]	; (80a17f8 <_Z26mapNoiseToLEDsUsingPalettev+0x9c>)
 80a17be:	f89d 100c 	ldrb.w	r1, [sp, #12]
 80a17c2:	eb00 0040 	add.w	r0, r0, r0, lsl #1
 80a17c6:	1813      	adds	r3, r2, r0
 80a17c8:	5411      	strb	r1, [r2, r0]
        g = rhs.g;
 80a17ca:	f89d 200d 	ldrb.w	r2, [sp, #13]
void mapNoiseToLEDsUsingPalette()
{
    static uint8_t ihue = 0;

    for (int i = 0; i < kMatrixHeight; i++) {
        for (int j = 0; j < kMatrixWidth; j++) {
 80a17ce:	3501      	adds	r5, #1
 80a17d0:	705a      	strb	r2, [r3, #1]
        b = rhs.b;
 80a17d2:	f89d 200e 	ldrb.w	r2, [sp, #14]
 80a17d6:	2d04      	cmp	r5, #4
 80a17d8:	709a      	strb	r2, [r3, #2]
 80a17da:	d1cd      	bne.n	80a1778 <_Z26mapNoiseToLEDsUsingPalettev+0x1c>

void mapNoiseToLEDsUsingPalette()
{
    static uint8_t ihue = 0;

    for (int i = 0; i < kMatrixHeight; i++) {
 80a17dc:	3401      	adds	r4, #1
 80a17de:	2c1b      	cmp	r4, #27
 80a17e0:	d1c3      	bne.n	80a176a <_Z26mapNoiseToLEDsUsingPalettev+0xe>
            CRGB color = ColorFromPalette(currentPalette, index, bri);
            leds[XY(i, j)] = color;
        }
    }

    ihue += 1;
 80a17e2:	4a06      	ldr	r2, [pc, #24]	; (80a17fc <_Z26mapNoiseToLEDsUsingPalettev+0xa0>)
 80a17e4:	7813      	ldrb	r3, [r2, #0]
 80a17e6:	3301      	adds	r3, #1
 80a17e8:	7013      	strb	r3, [r2, #0]
}
 80a17ea:	b005      	add	sp, #20
 80a17ec:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80a17f0:	20000610 	.word	0x20000610
 80a17f4:	200005b4 	.word	0x200005b4
 80a17f8:	200003b4 	.word	0x200003b4
 80a17fc:	200005e4 	.word	0x200005e4
 80a1800:	20000306 	.word	0x20000306

080a1804 <_Z26SetupPurpleAndGreenPalettev>:
// etc
#define HOLD_PALETTES_X_TIMES_AS_LONG 20

// This function sets up a palette of purple and green stripes.
void SetupPurpleAndGreenPalette()
{
 80a1804:	b570      	push	{r4, r5, r6, lr}
 80a1806:	b08e      	sub	sp, #56	; 0x38
    {
    }

    // allow construction from H, S, V
    inline CHSV( uint8_t ih, uint8_t is, uint8_t iv) __attribute__((always_inline))
        : h(ih), s(is), v(iv)
 80a1808:	24ff      	movs	r4, #255	; 0xff
 80a180a:	23c0      	movs	r3, #192	; 0xc0
    }

    // allow construction from HSV color
	inline CRGB(const CHSV& rhs) __attribute__((always_inline))
    {
        hsv2rgb_rainbow( rhs, *this);
 80a180c:	4669      	mov	r1, sp
 80a180e:	a802      	add	r0, sp, #8
    {
    }

    // allow construction from H, S, V
    inline CHSV( uint8_t ih, uint8_t is, uint8_t iv) __attribute__((always_inline))
        : h(ih), s(is), v(iv)
 80a1810:	f88d 3008 	strb.w	r3, [sp, #8]
 80a1814:	f88d 4009 	strb.w	r4, [sp, #9]
 80a1818:	f88d 400a 	strb.w	r4, [sp, #10]
    }

    // allow construction from HSV color
	inline CRGB(const CHSV& rhs) __attribute__((always_inline))
    {
        hsv2rgb_rainbow( rhs, *this);
 80a181c:	f000 fee8 	bl	80a25f0 <_ZN9NSFastLED15hsv2rgb_rainbowERKNS_4CHSVERNS_4CRGBE>
    {
    }

    // allow construction from H, S, V
    inline CHSV( uint8_t ih, uint8_t is, uint8_t iv) __attribute__((always_inline))
        : h(ih), s(is), v(iv)
 80a1820:	2360      	movs	r3, #96	; 0x60
    }

    // allow construction from HSV color
	inline CRGB(const CHSV& rhs) __attribute__((always_inline))
    {
        hsv2rgb_rainbow( rhs, *this);
 80a1822:	a901      	add	r1, sp, #4
 80a1824:	a802      	add	r0, sp, #8
    {
    }

    // allow construction from H, S, V
    inline CHSV( uint8_t ih, uint8_t is, uint8_t iv) __attribute__((always_inline))
        : h(ih), s(is), v(iv)
 80a1826:	f88d 3008 	strb.w	r3, [sp, #8]
 80a182a:	f88d 4009 	strb.w	r4, [sp, #9]
 80a182e:	f88d 400a 	strb.w	r4, [sp, #10]
    }

    // allow construction from HSV color
	inline CRGB(const CHSV& rhs) __attribute__((always_inline))
    {
        hsv2rgb_rainbow( rhs, *this);
 80a1832:	f000 fedd 	bl	80a25f0 <_ZN9NSFastLED15hsv2rgb_rainbowERKNS_4CHSVERNS_4CRGBE>

    // allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
        g = rhs.g;
 80a1836:	f89d 5005 	ldrb.w	r5, [sp, #5]
    }

    // allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
 80a183a:	f89d 6004 	ldrb.w	r6, [sp, #4]
        g = rhs.g;
        b = rhs.b;
 80a183e:	f89d 4006 	ldrb.w	r4, [sp, #6]
    }

    // allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
 80a1842:	f89d 0000 	ldrb.w	r0, [sp]
        g = rhs.g;
 80a1846:	f89d 1001 	ldrb.w	r1, [sp, #1]
        b = rhs.b;
 80a184a:	f89d 2002 	ldrb.w	r2, [sp, #2]
    }

    // allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
 80a184e:	2300      	movs	r3, #0
        g = rhs.g;
 80a1850:	f88d 5009 	strb.w	r5, [sp, #9]
        b = rhs.b;
 80a1854:	f88d 400a 	strb.w	r4, [sp, #10]

    // allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
        g = rhs.g;
 80a1858:	f88d 500c 	strb.w	r5, [sp, #12]
        b = rhs.b;
 80a185c:	f88d 400d 	strb.w	r4, [sp, #13]
    }

    // allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
 80a1860:	f88d 300e 	strb.w	r3, [sp, #14]
        g = rhs.g;
 80a1864:	f88d 300f 	strb.w	r3, [sp, #15]
        b = rhs.b;
 80a1868:	f88d 3010 	strb.w	r3, [sp, #16]
    }

    // allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
 80a186c:	f88d 3011 	strb.w	r3, [sp, #17]
        g = rhs.g;
 80a1870:	f88d 3012 	strb.w	r3, [sp, #18]
        b = rhs.b;
 80a1874:	f88d 3013 	strb.w	r3, [sp, #19]
    }

    // allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
 80a1878:	f88d 301a 	strb.w	r3, [sp, #26]
        g = rhs.g;
 80a187c:	f88d 301b 	strb.w	r3, [sp, #27]
        b = rhs.b;
 80a1880:	f88d 301c 	strb.w	r3, [sp, #28]
    }

    // allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
 80a1884:	f88d 301d 	strb.w	r3, [sp, #29]
        g = rhs.g;
 80a1888:	f88d 301e 	strb.w	r3, [sp, #30]
        b = rhs.b;
 80a188c:	f88d 301f 	strb.w	r3, [sp, #31]

    // allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
        g = rhs.g;
 80a1890:	f88d 5021 	strb.w	r5, [sp, #33]	; 0x21
    }

    // allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
 80a1894:	f88d 6008 	strb.w	r6, [sp, #8]
 80a1898:	f88d 600b 	strb.w	r6, [sp, #11]
 80a189c:	f88d 0014 	strb.w	r0, [sp, #20]
        g = rhs.g;
 80a18a0:	f88d 1015 	strb.w	r1, [sp, #21]
        b = rhs.b;
 80a18a4:	f88d 2016 	strb.w	r2, [sp, #22]
    }

    // allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
 80a18a8:	f88d 0017 	strb.w	r0, [sp, #23]
        g = rhs.g;
 80a18ac:	f88d 1018 	strb.w	r1, [sp, #24]
        b = rhs.b;
 80a18b0:	f88d 2019 	strb.w	r2, [sp, #25]
    }

    // allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
 80a18b4:	f88d 6020 	strb.w	r6, [sp, #32]
        g = rhs.g;
        b = rhs.b;
 80a18b8:	f88d 4022 	strb.w	r4, [sp, #34]	; 0x22
 80a18bc:	f88d 4025 	strb.w	r4, [sp, #37]	; 0x25
    {
        memmove8( &(entries[0]), &(rhs.entries[0]), sizeof( entries));
    }
    CRGBPalette16& operator=( const CRGBPalette16& rhs)
    {
        memmove8( &(entries[0]), &(rhs.entries[0]), sizeof( entries));
 80a18c0:	4c1a      	ldr	r4, [pc, #104]	; (80a192c <_Z26SetupPurpleAndGreenPalettev+0x128>)

    // allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
        g = rhs.g;
 80a18c2:	f88d 5024 	strb.w	r5, [sp, #36]	; 0x24
    }

    // allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
 80a18c6:	f88d 3026 	strb.w	r3, [sp, #38]	; 0x26
        g = rhs.g;
 80a18ca:	f88d 3027 	strb.w	r3, [sp, #39]	; 0x27
        b = rhs.b;
 80a18ce:	f88d 3028 	strb.w	r3, [sp, #40]	; 0x28
    }

    // allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
 80a18d2:	f88d 3029 	strb.w	r3, [sp, #41]	; 0x29
        g = rhs.g;
 80a18d6:	f88d 302a 	strb.w	r3, [sp, #42]	; 0x2a
        b = rhs.b;
 80a18da:	f88d 302b 	strb.w	r3, [sp, #43]	; 0x2b
    }

    // allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
 80a18de:	f88d 3032 	strb.w	r3, [sp, #50]	; 0x32
        g = rhs.g;
 80a18e2:	f88d 3033 	strb.w	r3, [sp, #51]	; 0x33
        b = rhs.b;
 80a18e6:	f88d 3034 	strb.w	r3, [sp, #52]	; 0x34
    }

    // allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
 80a18ea:	f88d 3035 	strb.w	r3, [sp, #53]	; 0x35
        g = rhs.g;
 80a18ee:	f88d 3036 	strb.w	r3, [sp, #54]	; 0x36
        b = rhs.b;
 80a18f2:	f88d 3037 	strb.w	r3, [sp, #55]	; 0x37
    }

    // allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
 80a18f6:	f88d 6023 	strb.w	r6, [sp, #35]	; 0x23
 80a18fa:	f88d 002c 	strb.w	r0, [sp, #44]	; 0x2c
        g = rhs.g;
 80a18fe:	f88d 102d 	strb.w	r1, [sp, #45]	; 0x2d
        b = rhs.b;
 80a1902:	f88d 202e 	strb.w	r2, [sp, #46]	; 0x2e
    }

    // allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
 80a1906:	f88d 002f 	strb.w	r0, [sp, #47]	; 0x2f
        g = rhs.g;
 80a190a:	f88d 1030 	strb.w	r1, [sp, #48]	; 0x30
        b = rhs.b;
 80a190e:	f88d 2031 	strb.w	r2, [sp, #49]	; 0x31
 80a1912:	ab02      	add	r3, sp, #8
 80a1914:	ad0e      	add	r5, sp, #56	; 0x38
 80a1916:	461a      	mov	r2, r3
 80a1918:	ca03      	ldmia	r2!, {r0, r1}
 80a191a:	42aa      	cmp	r2, r5
 80a191c:	6020      	str	r0, [r4, #0]
 80a191e:	6061      	str	r1, [r4, #4]
 80a1920:	4613      	mov	r3, r2
 80a1922:	f104 0408 	add.w	r4, r4, #8
 80a1926:	d1f6      	bne.n	80a1916 <_Z26SetupPurpleAndGreenPalettev+0x112>
    currentPalette = CRGBPalette16(
                         green,  green,  black,  black,
                         purple, purple, black,  black,
                         green,  green,  black,  black,
                         purple, purple, black,  black);
}
 80a1928:	b00e      	add	sp, #56	; 0x38
 80a192a:	bd70      	pop	{r4, r5, r6, pc}
 80a192c:	200005b4 	.word	0x200005b4

080a1930 <_Z32SetupBlackAndWhiteStripedPalettev>:
// This function sets up a palette of black and white stripes,
// using code.  Since the palette is effectively an array of
// sixteen CRGB colors, the various fill_* functions can be used
// to set them up.
void SetupBlackAndWhiteStripedPalette()
{
 80a1930:	b513      	push	{r0, r1, r4, lr}
    // 'black out' all 16 palette entries...
    fill_solid(currentPalette, 16, CRGB::Black);
 80a1932:	4c0f      	ldr	r4, [pc, #60]	; (80a1970 <_Z32SetupBlackAndWhiteStripedPalettev+0x40>)
    {
    }

    // allow construction from 32-bit (really 24-bit) bit 0xRRGGBB color code
    inline CRGB( uint32_t colorcode)  __attribute__((always_inline))
    : r((colorcode >> 16) & 0xFF), g((colorcode >> 8) & 0xFF), b((colorcode >> 0) & 0xFF)
 80a1934:	2300      	movs	r3, #0
 80a1936:	aa01      	add	r2, sp, #4
 80a1938:	2110      	movs	r1, #16
 80a193a:	4620      	mov	r0, r4
 80a193c:	f88d 3004 	strb.w	r3, [sp, #4]
 80a1940:	f88d 3005 	strb.w	r3, [sp, #5]
 80a1944:	f88d 3006 	strb.w	r3, [sp, #6]
 80a1948:	f000 ff16 	bl	80a2778 <_ZN9NSFastLED10fill_solidEPNS_4CRGBEiRKS0_>
    }

    // allow assignment from 32-bit (really 24-bit) 0xRRGGBB color code
	inline CRGB& operator= (const uint32_t colorcode) __attribute__((always_inline))
    {
        r = (colorcode >> 16) & 0xFF;
 80a194c:	23ff      	movs	r3, #255	; 0xff
 80a194e:	7023      	strb	r3, [r4, #0]
        g = (colorcode >>  8) & 0xFF;
 80a1950:	7063      	strb	r3, [r4, #1]
        b = (colorcode >>  0) & 0xFF;
 80a1952:	70a3      	strb	r3, [r4, #2]
    }

    // allow assignment from 32-bit (really 24-bit) 0xRRGGBB color code
	inline CRGB& operator= (const uint32_t colorcode) __attribute__((always_inline))
    {
        r = (colorcode >> 16) & 0xFF;
 80a1954:	7323      	strb	r3, [r4, #12]
        g = (colorcode >>  8) & 0xFF;
 80a1956:	7363      	strb	r3, [r4, #13]
        b = (colorcode >>  0) & 0xFF;
 80a1958:	73a3      	strb	r3, [r4, #14]
    }

    // allow assignment from 32-bit (really 24-bit) 0xRRGGBB color code
	inline CRGB& operator= (const uint32_t colorcode) __attribute__((always_inline))
    {
        r = (colorcode >> 16) & 0xFF;
 80a195a:	7623      	strb	r3, [r4, #24]
        g = (colorcode >>  8) & 0xFF;
 80a195c:	7663      	strb	r3, [r4, #25]
        b = (colorcode >>  0) & 0xFF;
 80a195e:	76a3      	strb	r3, [r4, #26]
    }

    // allow assignment from 32-bit (really 24-bit) 0xRRGGBB color code
	inline CRGB& operator= (const uint32_t colorcode) __attribute__((always_inline))
    {
        r = (colorcode >> 16) & 0xFF;
 80a1960:	f884 3024 	strb.w	r3, [r4, #36]	; 0x24
        g = (colorcode >>  8) & 0xFF;
 80a1964:	f884 3025 	strb.w	r3, [r4, #37]	; 0x25
        b = (colorcode >>  0) & 0xFF;
 80a1968:	f884 3026 	strb.w	r3, [r4, #38]	; 0x26
    currentPalette[0] = CRGB::White;
    currentPalette[4] = CRGB::White;
    currentPalette[8] = CRGB::White;
    currentPalette[12] = CRGB::White;

}
 80a196c:	b002      	add	sp, #8
 80a196e:	bd10      	pop	{r4, pc}
 80a1970:	200005b4 	.word	0x200005b4

080a1974 <_Z21setupNoisePlusPalettev>:
}

void setupNoisePlusPalette()
{

    speed = 3;
 80a1974:	4b0d      	ldr	r3, [pc, #52]	; (80a19ac <_Z21setupNoisePlusPalettev+0x38>)
 80a1976:	2203      	movs	r2, #3
 80a1978:	801a      	strh	r2, [r3, #0]
    scale = 311;
 80a197a:	f240 1237 	movw	r2, #311	; 0x137
                     ((uint8_t)(rand16seed >> 8)));
}

LIB8STATIC uint16_t random16()
{
    rand16seed = (rand16seed * RAND16_2053) + RAND16_13849;
 80a197e:	f243 6119 	movw	r1, #13849	; 0x3619
 80a1982:	4b0b      	ldr	r3, [pc, #44]	; (80a19b0 <_Z21setupNoisePlusPalettev+0x3c>)
 80a1984:	480b      	ldr	r0, [pc, #44]	; (80a19b4 <_Z21setupNoisePlusPalettev+0x40>)
 80a1986:	801a      	strh	r2, [r3, #0]
 80a1988:	8803      	ldrh	r3, [r0, #0]
 80a198a:	eb03 2243 	add.w	r2, r3, r3, lsl #9
 80a198e:	eb03 0282 	add.w	r2, r3, r2, lsl #2
 80a1992:	440a      	add	r2, r1
 80a1994:	eb02 2342 	add.w	r3, r2, r2, lsl #9
 80a1998:	eb02 0283 	add.w	r2, r2, r3, lsl #2
 80a199c:	188b      	adds	r3, r1, r2
 80a199e:	eb03 2243 	add.w	r2, r3, r3, lsl #9
 80a19a2:	eb03 0382 	add.w	r3, r3, r2, lsl #2
 80a19a6:	440b      	add	r3, r1
 80a19a8:	8003      	strh	r3, [r0, #0]
 80a19aa:	4770      	bx	lr
 80a19ac:	2000030e 	.word	0x2000030e
 80a19b0:	2000030c 	.word	0x2000030c
 80a19b4:	20000310 	.word	0x20000310

080a19b8 <_ZN9NSFastLED13fill_gradientINS_4CRGBEEEvPT_tNS_4CHSVEtS4_NS_22TGradientDirectionCodeE>:
///
///   In the case of writing into a CRGB array, the gradient is
///   computed in HSV space, and then HSV values are converted to RGB
///   as they're written into the RGB array.
template <typename T>
void fill_gradient( T* targetArray,
 80a19b8:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80a19bc:	461f      	mov	r7, r3
 80a19be:	b085      	sub	sp, #20
                    uint16_t startpos, CHSV startcolor,
                    uint16_t endpos,   CHSV endcolor,
                    TGradientDirectionCode directionCode  = SHORTEST_HUES )
{
    // if the points are in the wrong order, straighten them
    if( endpos < startpos ) {
 80a19c0:	428f      	cmp	r7, r1
///
///   In the case of writing into a CRGB array, the gradient is
///   computed in HSV space, and then HSV values are converted to RGB
///   as they're written into the RGB array.
template <typename T>
void fill_gradient( T* targetArray,
 80a19c2:	4606      	mov	r6, r0
 80a19c4:	460d      	mov	r5, r1
 80a19c6:	9b0e      	ldr	r3, [sp, #56]	; 0x38
 80a19c8:	f89d 403c 	ldrb.w	r4, [sp, #60]	; 0x3c
                    uint16_t startpos, CHSV startcolor,
                    uint16_t endpos,   CHSV endcolor,
                    TGradientDirectionCode directionCode  = SHORTEST_HUES )
{
    // if the points are in the wrong order, straighten them
    if( endpos < startpos ) {
 80a19cc:	d216      	bcs.n	80a19fc <_ZN9NSFastLED13fill_gradientINS_4CRGBEEEvPT_tNS_4CHSVEtS4_NS_22TGradientDirectionCodeE+0x44>
        v = rhs.v;
    }

    inline CHSV& operator= (const CHSV& rhs) __attribute__((always_inline))
    {
        h = rhs.h;
 80a19ce:	f892 c000 	ldrb.w	ip, [r2]
    // allow copy construction
    inline CHSV(const CHSV& rhs) __attribute__((always_inline))
    {
        h = rhs.h;
        s = rhs.s;
        v = rhs.v;
 80a19d2:	7899      	ldrb	r1, [r3, #2]
    }

    // allow copy construction
    inline CHSV(const CHSV& rhs) __attribute__((always_inline))
    {
        h = rhs.h;
 80a19d4:	f893 e000 	ldrb.w	lr, [r3]
        v = rhs.v;
    }

    inline CHSV& operator= (const CHSV& rhs) __attribute__((always_inline))
    {
        h = rhs.h;
 80a19d8:	f883 c000 	strb.w	ip, [r3]
        s = rhs.s;
 80a19dc:	f892 c001 	ldrb.w	ip, [r2, #1]

    // allow copy construction
    inline CHSV(const CHSV& rhs) __attribute__((always_inline))
    {
        h = rhs.h;
        s = rhs.s;
 80a19e0:	7858      	ldrb	r0, [r3, #1]
    }

    inline CHSV& operator= (const CHSV& rhs) __attribute__((always_inline))
    {
        h = rhs.h;
        s = rhs.s;
 80a19e2:	f883 c001 	strb.w	ip, [r3, #1]
        v = rhs.v;
 80a19e6:	f892 c002 	ldrb.w	ip, [r2, #2]
 80a19ea:	7091      	strb	r1, [r2, #2]
 80a19ec:	4629      	mov	r1, r5
 80a19ee:	463d      	mov	r5, r7
 80a19f0:	460f      	mov	r7, r1
 80a19f2:	f883 c002 	strb.w	ip, [r3, #2]
        v = rhs.v;
    }

    inline CHSV& operator= (const CHSV& rhs) __attribute__((always_inline))
    {
        h = rhs.h;
 80a19f6:	f882 e000 	strb.w	lr, [r2]
        s = rhs.s;
 80a19fa:	7050      	strb	r0, [r2, #1]

    // If we're fading toward black (val=0) or white (sat=0),
    // then set the endhue to the starthue.
    // This lets us ramp smoothly to black or white, regardless
    // of what 'hue' was set in the endcolor (since it doesn't matter)
    if( endcolor.value == 0 || endcolor.saturation == 0) {
 80a19fc:	7898      	ldrb	r0, [r3, #2]
 80a19fe:	b108      	cbz	r0, 80a1a04 <_ZN9NSFastLED13fill_gradientINS_4CRGBEEEvPT_tNS_4CHSVEtS4_NS_22TGradientDirectionCodeE+0x4c>
 80a1a00:	7859      	ldrb	r1, [r3, #1]
 80a1a02:	b909      	cbnz	r1, 80a1a08 <_ZN9NSFastLED13fill_gradientINS_4CRGBEEEvPT_tNS_4CHSVEtS4_NS_22TGradientDirectionCodeE+0x50>
        endcolor.hue = startcolor.hue;
 80a1a04:	7811      	ldrb	r1, [r2, #0]
 80a1a06:	7019      	strb	r1, [r3, #0]

    // Similarly, if we're fading in from black (val=0) or white (sat=0)
    // then set the starthue to the endhue.
    // This lets us ramp smoothly up from black or white, regardless
    // of what 'hue' was set in the startcolor (since it doesn't matter)
    if( startcolor.value == 0 || startcolor.saturation == 0) {
 80a1a08:	f892 e002 	ldrb.w	lr, [r2, #2]
 80a1a0c:	7819      	ldrb	r1, [r3, #0]
 80a1a0e:	f1be 0f00 	cmp.w	lr, #0
 80a1a12:	d004      	beq.n	80a1a1e <_ZN9NSFastLED13fill_gradientINS_4CRGBEEEvPT_tNS_4CHSVEtS4_NS_22TGradientDirectionCodeE+0x66>
 80a1a14:	f892 c001 	ldrb.w	ip, [r2, #1]
 80a1a18:	f1bc 0f00 	cmp.w	ip, #0
 80a1a1c:	d100      	bne.n	80a1a20 <_ZN9NSFastLED13fill_gradientINS_4CRGBEEEvPT_tNS_4CHSVEtS4_NS_22TGradientDirectionCodeE+0x68>
        startcolor.hue = endcolor.hue;
 80a1a1e:	7011      	strb	r1, [r2, #0]

    saccum87 huedistance87;
    saccum87 satdistance87;
    saccum87 valdistance87;

    satdistance87 = (endcolor.sat - startcolor.sat) << 7;
 80a1a20:	f892 c001 	ldrb.w	ip, [r2, #1]
 80a1a24:	785b      	ldrb	r3, [r3, #1]
    valdistance87 = (endcolor.val - startcolor.val) << 7;

    uint8_t huedelta8 = endcolor.hue - startcolor.hue;
 80a1a26:	f892 8000 	ldrb.w	r8, [r2]

    saccum87 huedistance87;
    saccum87 satdistance87;
    saccum87 valdistance87;

    satdistance87 = (endcolor.sat - startcolor.sat) << 7;
 80a1a2a:	ebcc 0303 	rsb	r3, ip, r3
    valdistance87 = (endcolor.val - startcolor.val) << 7;
 80a1a2e:	ebce 0000 	rsb	r0, lr, r0

    uint8_t huedelta8 = endcolor.hue - startcolor.hue;
 80a1a32:	ebc8 0201 	rsb	r2, r8, r1

    if( directionCode == SHORTEST_HUES ) {
 80a1a36:	2c02      	cmp	r4, #2

    saccum87 huedistance87;
    saccum87 satdistance87;
    saccum87 valdistance87;

    satdistance87 = (endcolor.sat - startcolor.sat) << 7;
 80a1a38:	ea4f 13c3 	mov.w	r3, r3, lsl #7
    valdistance87 = (endcolor.val - startcolor.val) << 7;
 80a1a3c:	ea4f 10c0 	mov.w	r0, r0, lsl #7

    uint8_t huedelta8 = endcolor.hue - startcolor.hue;
 80a1a40:	b2d2      	uxtb	r2, r2

    if( directionCode == SHORTEST_HUES ) {
 80a1a42:	d101      	bne.n	80a1a48 <_ZN9NSFastLED13fill_gradientINS_4CRGBEEEvPT_tNS_4CHSVEtS4_NS_22TGradientDirectionCodeE+0x90>
        directionCode = FORWARD_HUES;
 80a1a44:	09d4      	lsrs	r4, r2, #7
 80a1a46:	e004      	b.n	80a1a52 <_ZN9NSFastLED13fill_gradientINS_4CRGBEEEvPT_tNS_4CHSVEtS4_NS_22TGradientDirectionCodeE+0x9a>
        if( huedelta8 > 127) {
            directionCode = BACKWARD_HUES;
        }
    }

    if( directionCode == LONGEST_HUES ) {
 80a1a48:	2c03      	cmp	r4, #3
 80a1a4a:	d102      	bne.n	80a1a52 <_ZN9NSFastLED13fill_gradientINS_4CRGBEEEvPT_tNS_4CHSVEtS4_NS_22TGradientDirectionCodeE+0x9a>
        directionCode = FORWARD_HUES;
        if( huedelta8 < 128) {
 80a1a4c:	0611      	lsls	r1, r2, #24
 80a1a4e:	d503      	bpl.n	80a1a58 <_ZN9NSFastLED13fill_gradientINS_4CRGBEEEvPT_tNS_4CHSVEtS4_NS_22TGradientDirectionCodeE+0xa0>
 80a1a50:	e000      	b.n	80a1a54 <_ZN9NSFastLED13fill_gradientINS_4CRGBEEEvPT_tNS_4CHSVEtS4_NS_22TGradientDirectionCodeE+0x9c>
            directionCode = BACKWARD_HUES;
        }
    }

    if( directionCode == FORWARD_HUES) {
 80a1a52:	b90c      	cbnz	r4, 80a1a58 <_ZN9NSFastLED13fill_gradientINS_4CRGBEEEvPT_tNS_4CHSVEtS4_NS_22TGradientDirectionCodeE+0xa0>
        huedistance87 = huedelta8 << 7;
 80a1a54:	01d2      	lsls	r2, r2, #7
 80a1a56:	e004      	b.n	80a1a62 <_ZN9NSFastLED13fill_gradientINS_4CRGBEEEvPT_tNS_4CHSVEtS4_NS_22TGradientDirectionCodeE+0xaa>
    }
    else /* directionCode == BACKWARD_HUES */
    {
        huedistance87 = (uint8_t)(256 - huedelta8) << 7;
        huedistance87 = -huedistance87;
 80a1a58:	4252      	negs	r2, r2
 80a1a5a:	b2d2      	uxtb	r2, r2
 80a1a5c:	01d2      	lsls	r2, r2, #7
 80a1a5e:	4252      	negs	r2, r2
 80a1a60:	b212      	sxth	r2, r2
    }

    uint16_t pixeldistance = endpos - startpos;
 80a1a62:	1b79      	subs	r1, r7, r5
 80a1a64:	b289      	uxth	r1, r1
    int16_t divisor = pixeldistance ? pixeldistance : 1;
 80a1a66:	b109      	cbz	r1, 80a1a6c <_ZN9NSFastLED13fill_gradientINS_4CRGBEEEvPT_tNS_4CHSVEtS4_NS_22TGradientDirectionCodeE+0xb4>
 80a1a68:	b209      	sxth	r1, r1
 80a1a6a:	e000      	b.n	80a1a6e <_ZN9NSFastLED13fill_gradientINS_4CRGBEEEvPT_tNS_4CHSVEtS4_NS_22TGradientDirectionCodeE+0xb6>
 80a1a6c:	2101      	movs	r1, #1
    saccum87 huedelta87 = huedistance87 / divisor;
    saccum87 satdelta87 = satdistance87 / divisor;
    saccum87 valdelta87 = valdistance87 / divisor;

    huedelta87 *= 2;
    satdelta87 *= 2;
 80a1a6e:	fb93 f9f1 	sdiv	r9, r3, r1

    saccum87 huedelta87 = huedistance87 / divisor;
    saccum87 satdelta87 = satdistance87 / divisor;
    saccum87 valdelta87 = valdistance87 / divisor;

    huedelta87 *= 2;
 80a1a72:	fb92 f2f1 	sdiv	r2, r2, r1
    satdelta87 *= 2;
    valdelta87 *= 2;
 80a1a76:	fb90 faf1 	sdiv	sl, r0, r1

    saccum87 huedelta87 = huedistance87 / divisor;
    saccum87 satdelta87 = satdistance87 / divisor;
    saccum87 valdelta87 = valdistance87 / divisor;

    huedelta87 *= 2;
 80a1a7a:	0054      	lsls	r4, r2, #1
    satdelta87 *= 2;
 80a1a7c:	ea4f 0949 	mov.w	r9, r9, lsl #1
    valdelta87 *= 2;
 80a1a80:	ea4f 0a4a 	mov.w	sl, sl, lsl #1

    saccum87 huedelta87 = huedistance87 / divisor;
    saccum87 satdelta87 = satdistance87 / divisor;
    saccum87 valdelta87 = valdistance87 / divisor;

    huedelta87 *= 2;
 80a1a84:	b2a4      	uxth	r4, r4
    satdelta87 *= 2;
 80a1a86:	fa1f f989 	uxth.w	r9, r9
    valdelta87 *= 2;
 80a1a8a:	fa1f fa8a 	uxth.w	sl, sl

    accum88 hue88 = startcolor.hue << 8;
 80a1a8e:	ea4f 2808 	mov.w	r8, r8, lsl #8
    accum88 sat88 = startcolor.sat << 8;
 80a1a92:	ea4f 230c 	mov.w	r3, ip, lsl #8
    accum88 val88 = startcolor.val << 8;
 80a1a96:	ea4f 2b0e 	mov.w	fp, lr, lsl #8
    for( uint16_t i = startpos; i <= endpos; i++) {
 80a1a9a:	42af      	cmp	r7, r5
 80a1a9c:	d320      	bcc.n	80a1ae0 <_ZN9NSFastLED13fill_gradientINS_4CRGBEEEvPT_tNS_4CHSVEtS4_NS_22TGradientDirectionCodeE+0x128>
    {
    }

    // allow construction from H, S, V
    inline CHSV( uint8_t ih, uint8_t is, uint8_t iv) __attribute__((always_inline))
        : h(ih), s(is), v(iv)
 80a1a9e:	ea4f 2228 	mov.w	r2, r8, asr #8
 80a1aa2:	f88d 200c 	strb.w	r2, [sp, #12]
    }

    // allow assignment from HSV color
	inline CRGB& operator= (const CHSV& rhs) __attribute__((always_inline))
    {
        hsv2rgb_rainbow( rhs, *this);
 80a1aa6:	eb05 0145 	add.w	r1, r5, r5, lsl #1
    {
    }

    // allow construction from H, S, V
    inline CHSV( uint8_t ih, uint8_t is, uint8_t iv) __attribute__((always_inline))
        : h(ih), s(is), v(iv)
 80a1aaa:	121a      	asrs	r2, r3, #8
 80a1aac:	f88d 200d 	strb.w	r2, [sp, #13]
    }

    // allow assignment from HSV color
	inline CRGB& operator= (const CHSV& rhs) __attribute__((always_inline))
    {
        hsv2rgb_rainbow( rhs, *this);
 80a1ab0:	4431      	add	r1, r6
    {
    }

    // allow construction from H, S, V
    inline CHSV( uint8_t ih, uint8_t is, uint8_t iv) __attribute__((always_inline))
        : h(ih), s(is), v(iv)
 80a1ab2:	ea4f 222b 	mov.w	r2, fp, asr #8
    }

    // allow assignment from HSV color
	inline CRGB& operator= (const CHSV& rhs) __attribute__((always_inline))
    {
        hsv2rgb_rainbow( rhs, *this);
 80a1ab6:	a803      	add	r0, sp, #12
    {
    }

    // allow construction from H, S, V
    inline CHSV( uint8_t ih, uint8_t is, uint8_t iv) __attribute__((always_inline))
        : h(ih), s(is), v(iv)
 80a1ab8:	9301      	str	r3, [sp, #4]
 80a1aba:	f88d 200e 	strb.w	r2, [sp, #14]
    }

    // allow assignment from HSV color
	inline CRGB& operator= (const CHSV& rhs) __attribute__((always_inline))
    {
        hsv2rgb_rainbow( rhs, *this);
 80a1abe:	f000 fd97 	bl	80a25f0 <_ZN9NSFastLED15hsv2rgb_rainbowERKNS_4CHSVERNS_4CRGBE>
        targetArray[i] = CHSV( hue88 >> 8, sat88 >> 8, val88 >> 8);
        hue88 += huedelta87;
        sat88 += satdelta87;
 80a1ac2:	9b01      	ldr	r3, [sp, #4]
    accum88 hue88 = startcolor.hue << 8;
    accum88 sat88 = startcolor.sat << 8;
    accum88 val88 = startcolor.val << 8;
    for( uint16_t i = startpos; i <= endpos; i++) {
        targetArray[i] = CHSV( hue88 >> 8, sat88 >> 8, val88 >> 8);
        hue88 += huedelta87;
 80a1ac4:	44a0      	add	r8, r4
        sat88 += satdelta87;
 80a1ac6:	eb03 0c09 	add.w	ip, r3, r9
        val88 += valdelta87;
 80a1aca:	eb0b 0e0a 	add.w	lr, fp, sl
    valdelta87 *= 2;

    accum88 hue88 = startcolor.hue << 8;
    accum88 sat88 = startcolor.sat << 8;
    accum88 val88 = startcolor.val << 8;
    for( uint16_t i = startpos; i <= endpos; i++) {
 80a1ace:	3501      	adds	r5, #1
        targetArray[i] = CHSV( hue88 >> 8, sat88 >> 8, val88 >> 8);
        hue88 += huedelta87;
 80a1ad0:	fa1f f888 	uxth.w	r8, r8
        sat88 += satdelta87;
 80a1ad4:	fa1f f38c 	uxth.w	r3, ip
        val88 += valdelta87;
 80a1ad8:	fa1f fb8e 	uxth.w	fp, lr
    valdelta87 *= 2;

    accum88 hue88 = startcolor.hue << 8;
    accum88 sat88 = startcolor.sat << 8;
    accum88 val88 = startcolor.val << 8;
    for( uint16_t i = startpos; i <= endpos; i++) {
 80a1adc:	b2ad      	uxth	r5, r5
 80a1ade:	e7dc      	b.n	80a1a9a <_ZN9NSFastLED13fill_gradientINS_4CRGBEEEvPT_tNS_4CHSVEtS4_NS_22TGradientDirectionCodeE+0xe2>
        targetArray[i] = CHSV( hue88 >> 8, sat88 >> 8, val88 >> 8);
        hue88 += huedelta87;
        sat88 += satdelta87;
        val88 += valdelta87;
    }
}
 80a1ae0:	b005      	add	sp, #20
 80a1ae2:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
	...

080a1ae8 <_Z18SetupRandomPalettev>:
// between four different colors.  The first is a dim hue, the second is
// a bright hue, the third is a bright pastel, and the last is
// another bright hue.  This gives some visual bright/dark variation
// which is more interesting than just a gradient of different hues.
void SetupRandomPalette()
{
 80a1ae8:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 80a1aec:	b091      	sub	sp, #68	; 0x44
    currentPalette = CRGBPalette16(
 80a1aee:	f7ff fe0f 	bl	80a1710 <_ZN9NSFastLEDL7random8Ev>
 80a1af2:	4601      	mov	r1, r0
 80a1af4:	f7ff fe0c 	bl	80a1710 <_ZN9NSFastLEDL7random8Ev>
 80a1af8:	4607      	mov	r7, r0
 80a1afa:	f7ff fe09 	bl	80a1710 <_ZN9NSFastLEDL7random8Ev>
 80a1afe:	4680      	mov	r8, r0
 80a1b00:	f7ff fe06 	bl	80a1710 <_ZN9NSFastLEDL7random8Ev>
 80a1b04:	4681      	mov	r9, r0
					TGradientDirectionCode directionCode = SHORTEST_HUES )
{
    uint16_t onethird = (numLeds / 3);
    uint16_t twothirds = ((numLeds * 2) / 3);
    uint16_t last = numLeds - 1;
    fill_gradient( targetArray,         0, c1,  onethird, c2, directionCode);
 80a1b06:	ad02      	add	r5, sp, #8
 80a1b08:	2602      	movs	r6, #2
    // allow copy construction
    inline CHSV(const CHSV& rhs) __attribute__((always_inline))
    {
        h = rhs.h;
        s = rhs.s;
        v = rhs.v;
 80a1b0a:	2320      	movs	r3, #32

    // allow copy construction
    inline CHSV(const CHSV& rhs) __attribute__((always_inline))
    {
        h = rhs.h;
        s = rhs.s;
 80a1b0c:	24ff      	movs	r4, #255	; 0xff
    }

    // allow copy construction
    inline CHSV(const CHSV& rhs) __attribute__((always_inline))
    {
        h = rhs.h;
 80a1b0e:	f88d 100c 	strb.w	r1, [sp, #12]
        s = rhs.s;
        v = rhs.v;
 80a1b12:	f88d 300e 	strb.w	r3, [sp, #14]
 80a1b16:	9500      	str	r5, [sp, #0]
 80a1b18:	2305      	movs	r3, #5
 80a1b1a:	aa03      	add	r2, sp, #12
 80a1b1c:	2100      	movs	r1, #0
 80a1b1e:	a804      	add	r0, sp, #16
 80a1b20:	9601      	str	r6, [sp, #4]

    // allow copy construction
    inline CHSV(const CHSV& rhs) __attribute__((always_inline))
    {
        h = rhs.h;
        s = rhs.s;
 80a1b22:	f88d 400d 	strb.w	r4, [sp, #13]
    }

    // allow copy construction
    inline CHSV(const CHSV& rhs) __attribute__((always_inline))
    {
        h = rhs.h;
 80a1b26:	f88d 7008 	strb.w	r7, [sp, #8]
        s = rhs.s;
 80a1b2a:	f88d 4009 	strb.w	r4, [sp, #9]
        v = rhs.v;
 80a1b2e:	f88d 400a 	strb.w	r4, [sp, #10]
 80a1b32:	f7ff ff41 	bl	80a19b8 <_ZN9NSFastLED13fill_gradientINS_4CRGBEEEvPT_tNS_4CHSVEtS4_NS_22TGradientDirectionCodeE>
    }

    // allow copy construction
    inline CHSV(const CHSV& rhs) __attribute__((always_inline))
    {
        h = rhs.h;
 80a1b36:	f88d 700c 	strb.w	r7, [sp, #12]
    fill_gradient( targetArray,  onethird, c2, twothirds, c3, directionCode);
 80a1b3a:	e88d 0060 	stmia.w	sp, {r5, r6}
        s = rhs.s;
 80a1b3e:	2780      	movs	r7, #128	; 0x80
 80a1b40:	230a      	movs	r3, #10
 80a1b42:	aa03      	add	r2, sp, #12
 80a1b44:	2105      	movs	r1, #5
 80a1b46:	a804      	add	r0, sp, #16
 80a1b48:	f88d 400d 	strb.w	r4, [sp, #13]
        v = rhs.v;
 80a1b4c:	f88d 400e 	strb.w	r4, [sp, #14]
 80a1b50:	f88d 400a 	strb.w	r4, [sp, #10]
    }

    // allow copy construction
    inline CHSV(const CHSV& rhs) __attribute__((always_inline))
    {
        h = rhs.h;
 80a1b54:	f88d 8008 	strb.w	r8, [sp, #8]
        s = rhs.s;
 80a1b58:	f88d 7009 	strb.w	r7, [sp, #9]
 80a1b5c:	f7ff ff2c 	bl	80a19b8 <_ZN9NSFastLED13fill_gradientINS_4CRGBEEEvPT_tNS_4CHSVEtS4_NS_22TGradientDirectionCodeE>
        v = rhs.v;
 80a1b60:	f88d 400e 	strb.w	r4, [sp, #14]

    // allow copy construction
    inline CHSV(const CHSV& rhs) __attribute__((always_inline))
    {
        h = rhs.h;
        s = rhs.s;
 80a1b64:	f88d 4009 	strb.w	r4, [sp, #9]
        v = rhs.v;
 80a1b68:	f88d 400a 	strb.w	r4, [sp, #10]
    fill_gradient( targetArray, twothirds, c3,      last, c4, directionCode);
 80a1b6c:	e88d 0060 	stmia.w	sp, {r5, r6}
 80a1b70:	230f      	movs	r3, #15
 80a1b72:	aa03      	add	r2, sp, #12
 80a1b74:	210a      	movs	r1, #10
 80a1b76:	a804      	add	r0, sp, #16
    {
        memmove8( &(entries[0]), &(rhs.entries[0]), sizeof( entries));
    }
    CRGBPalette16& operator=( const CRGBPalette16& rhs)
    {
        memmove8( &(entries[0]), &(rhs.entries[0]), sizeof( entries));
 80a1b78:	4c0b      	ldr	r4, [pc, #44]	; (80a1ba8 <_Z18SetupRandomPalettev+0xc0>)
    }

    // allow copy construction
    inline CHSV(const CHSV& rhs) __attribute__((always_inline))
    {
        h = rhs.h;
 80a1b7a:	f88d 800c 	strb.w	r8, [sp, #12]
        s = rhs.s;
 80a1b7e:	f88d 700d 	strb.w	r7, [sp, #13]
    }

    // allow copy construction
    inline CHSV(const CHSV& rhs) __attribute__((always_inline))
    {
        h = rhs.h;
 80a1b82:	f88d 9008 	strb.w	r9, [sp, #8]
 80a1b86:	ad10      	add	r5, sp, #64	; 0x40
    uint16_t onethird = (numLeds / 3);
    uint16_t twothirds = ((numLeds * 2) / 3);
    uint16_t last = numLeds - 1;
    fill_gradient( targetArray,         0, c1,  onethird, c2, directionCode);
    fill_gradient( targetArray,  onethird, c2, twothirds, c3, directionCode);
    fill_gradient( targetArray, twothirds, c3,      last, c4, directionCode);
 80a1b88:	f7ff ff16 	bl	80a19b8 <_ZN9NSFastLED13fill_gradientINS_4CRGBEEEvPT_tNS_4CHSVEtS4_NS_22TGradientDirectionCodeE>
    {
        memmove8( &(entries[0]), &(rhs.entries[0]), sizeof( entries));
    }
    CRGBPalette16& operator=( const CRGBPalette16& rhs)
    {
        memmove8( &(entries[0]), &(rhs.entries[0]), sizeof( entries));
 80a1b8c:	ab04      	add	r3, sp, #16
 80a1b8e:	461a      	mov	r2, r3
 80a1b90:	ca03      	ldmia	r2!, {r0, r1}
 80a1b92:	42aa      	cmp	r2, r5
 80a1b94:	6020      	str	r0, [r4, #0]
 80a1b96:	6061      	str	r1, [r4, #4]
 80a1b98:	4613      	mov	r3, r2
 80a1b9a:	f104 0408 	add.w	r4, r4, #8
 80a1b9e:	d1f6      	bne.n	80a1b8e <_Z18SetupRandomPalettev+0xa6>
                         CHSV(random8(), 255, 32),
                         CHSV(random8(), 255, 255),
                         CHSV(random8(), 128, 255),
                         CHSV(random8(), 255, 255));
}
 80a1ba0:	b011      	add	sp, #68	; 0x44
 80a1ba2:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 80a1ba6:	bf00      	nop
 80a1ba8:	200005b4 	.word	0x200005b4

080a1bac <_Z36ChangePaletteAndSettingsPeriodicallyv>:

void ChangePaletteAndSettingsPeriodically()
{
 80a1bac:	b508      	push	{r3, lr}
 80a1bae:	f001 fe97 	bl	80a38e0 <HAL_Timer_Get_Milli_Seconds>
    uint8_t secondHand = ((millis() / 1000) / HOLD_PALETTES_X_TIMES_AS_LONG) % 60;
 80a1bb2:	f644 6320 	movw	r3, #20000	; 0x4e20
 80a1bb6:	fbb0 f0f3 	udiv	r0, r0, r3
 80a1bba:	223c      	movs	r2, #60	; 0x3c
 80a1bbc:	fbb0 f3f2 	udiv	r3, r0, r2
 80a1bc0:	fb02 0013 	mls	r0, r2, r3, r0
    static uint8_t lastSecond = 99;

    if (lastSecond != secondHand) {
 80a1bc4:	4b3b      	ldr	r3, [pc, #236]	; (80a1cb4 <_Z36ChangePaletteAndSettingsPeriodicallyv+0x108>)
                         CHSV(random8(), 255, 255));
}

void ChangePaletteAndSettingsPeriodically()
{
    uint8_t secondHand = ((millis() / 1000) / HOLD_PALETTES_X_TIMES_AS_LONG) % 60;
 80a1bc6:	b2c0      	uxtb	r0, r0
    static uint8_t lastSecond = 99;

    if (lastSecond != secondHand) {
 80a1bc8:	781a      	ldrb	r2, [r3, #0]
 80a1bca:	4282      	cmp	r2, r0
 80a1bcc:	d070      	beq.n	80a1cb0 <_Z36ChangePaletteAndSettingsPeriodicallyv+0x104>
        lastSecond = secondHand;
 80a1bce:	7018      	strb	r0, [r3, #0]
        if (secondHand ==  0)  {
 80a1bd0:	b908      	cbnz	r0, 80a1bd6 <_Z36ChangePaletteAndSettingsPeriodicallyv+0x2a>
            currentPalette = RainbowColors_p;
 80a1bd2:	4939      	ldr	r1, [pc, #228]	; (80a1cb8 <_Z36ChangePaletteAndSettingsPeriodicallyv+0x10c>)
 80a1bd4:	e03c      	b.n	80a1c50 <_Z36ChangePaletteAndSettingsPeriodicallyv+0xa4>
            speed = 4;
            scale = 30;
            colorLoop = 1;
        }
        if (secondHand ==  5)  {
 80a1bd6:	2805      	cmp	r0, #5
 80a1bd8:	d103      	bne.n	80a1be2 <_Z36ChangePaletteAndSettingsPeriodicallyv+0x36>
            SetupPurpleAndGreenPalette();
 80a1bda:	f7ff fe13 	bl	80a1804 <_Z26SetupPurpleAndGreenPalettev>
            speed = 2;
 80a1bde:	2202      	movs	r2, #2
 80a1be0:	e049      	b.n	80a1c76 <_Z36ChangePaletteAndSettingsPeriodicallyv+0xca>
            scale = 50;
            colorLoop = 1;
        }
        if (secondHand == 10)  {
 80a1be2:	280a      	cmp	r0, #10
 80a1be4:	d102      	bne.n	80a1bec <_Z36ChangePaletteAndSettingsPeriodicallyv+0x40>
            SetupBlackAndWhiteStripedPalette();
 80a1be6:	f7ff fea3 	bl	80a1930 <_Z32SetupBlackAndWhiteStripedPalettev>
 80a1bea:	e034      	b.n	80a1c56 <_Z36ChangePaletteAndSettingsPeriodicallyv+0xaa>
            speed = 4;
            scale = 30;
            colorLoop = 1;
        }
        if (secondHand == 15)  {
 80a1bec:	280f      	cmp	r0, #15
 80a1bee:	d108      	bne.n	80a1c02 <_Z36ChangePaletteAndSettingsPeriodicallyv+0x56>
            currentPalette = ForestColors_p;
 80a1bf0:	4932      	ldr	r1, [pc, #200]	; (80a1cbc <_Z36ChangePaletteAndSettingsPeriodicallyv+0x110>)
 80a1bf2:	4833      	ldr	r0, [pc, #204]	; (80a1cc0 <_Z36ChangePaletteAndSettingsPeriodicallyv+0x114>)
 80a1bf4:	f7ff fd9e 	bl	80a1734 <_ZN9NSFastLED13CRGBPalette16aSERA16_Km>
            speed =  8;
 80a1bf8:	4b32      	ldr	r3, [pc, #200]	; (80a1cc4 <_Z36ChangePaletteAndSettingsPeriodicallyv+0x118>)
 80a1bfa:	2208      	movs	r2, #8
 80a1bfc:	801a      	strh	r2, [r3, #0]
            scale = 120;
 80a1bfe:	2278      	movs	r2, #120	; 0x78
 80a1c00:	e01f      	b.n	80a1c42 <_Z36ChangePaletteAndSettingsPeriodicallyv+0x96>
            colorLoop = 0;
        }
        if (secondHand == 20)  {
 80a1c02:	2814      	cmp	r0, #20
 80a1c04:	d108      	bne.n	80a1c18 <_Z36ChangePaletteAndSettingsPeriodicallyv+0x6c>
            currentPalette = CloudColors_p;
 80a1c06:	4930      	ldr	r1, [pc, #192]	; (80a1cc8 <_Z36ChangePaletteAndSettingsPeriodicallyv+0x11c>)
 80a1c08:	482d      	ldr	r0, [pc, #180]	; (80a1cc0 <_Z36ChangePaletteAndSettingsPeriodicallyv+0x114>)
 80a1c0a:	f7ff fd93 	bl	80a1734 <_ZN9NSFastLED13CRGBPalette16aSERA16_Km>
            speed =  4;
 80a1c0e:	4b2d      	ldr	r3, [pc, #180]	; (80a1cc4 <_Z36ChangePaletteAndSettingsPeriodicallyv+0x118>)
 80a1c10:	2204      	movs	r2, #4
 80a1c12:	801a      	strh	r2, [r3, #0]
            scale = 30;
 80a1c14:	221e      	movs	r2, #30
 80a1c16:	e014      	b.n	80a1c42 <_Z36ChangePaletteAndSettingsPeriodicallyv+0x96>
            colorLoop = 0;
        }
        if (secondHand == 25)  {
 80a1c18:	2819      	cmp	r0, #25
 80a1c1a:	d108      	bne.n	80a1c2e <_Z36ChangePaletteAndSettingsPeriodicallyv+0x82>
            currentPalette = LavaColors_p;
 80a1c1c:	492b      	ldr	r1, [pc, #172]	; (80a1ccc <_Z36ChangePaletteAndSettingsPeriodicallyv+0x120>)
 80a1c1e:	4828      	ldr	r0, [pc, #160]	; (80a1cc0 <_Z36ChangePaletteAndSettingsPeriodicallyv+0x114>)
 80a1c20:	f7ff fd88 	bl	80a1734 <_ZN9NSFastLED13CRGBPalette16aSERA16_Km>
            speed =  8;
 80a1c24:	4b27      	ldr	r3, [pc, #156]	; (80a1cc4 <_Z36ChangePaletteAndSettingsPeriodicallyv+0x118>)
 80a1c26:	2208      	movs	r2, #8
 80a1c28:	801a      	strh	r2, [r3, #0]
            scale = 50;
 80a1c2a:	2232      	movs	r2, #50	; 0x32
 80a1c2c:	e009      	b.n	80a1c42 <_Z36ChangePaletteAndSettingsPeriodicallyv+0x96>
            colorLoop = 0;
        }
        if (secondHand == 30)  {
 80a1c2e:	281e      	cmp	r0, #30
 80a1c30:	d10b      	bne.n	80a1c4a <_Z36ChangePaletteAndSettingsPeriodicallyv+0x9e>
            currentPalette = OceanColors_p;
 80a1c32:	4927      	ldr	r1, [pc, #156]	; (80a1cd0 <_Z36ChangePaletteAndSettingsPeriodicallyv+0x124>)
 80a1c34:	4822      	ldr	r0, [pc, #136]	; (80a1cc0 <_Z36ChangePaletteAndSettingsPeriodicallyv+0x114>)
 80a1c36:	f7ff fd7d 	bl	80a1734 <_ZN9NSFastLED13CRGBPalette16aSERA16_Km>
            speed = 4;
 80a1c3a:	4b22      	ldr	r3, [pc, #136]	; (80a1cc4 <_Z36ChangePaletteAndSettingsPeriodicallyv+0x118>)
 80a1c3c:	2204      	movs	r2, #4
 80a1c3e:	801a      	strh	r2, [r3, #0]
            scale = 90;
 80a1c40:	225a      	movs	r2, #90	; 0x5a
 80a1c42:	4b24      	ldr	r3, [pc, #144]	; (80a1cd4 <_Z36ChangePaletteAndSettingsPeriodicallyv+0x128>)
 80a1c44:	801a      	strh	r2, [r3, #0]
            colorLoop = 0;
 80a1c46:	2200      	movs	r2, #0
 80a1c48:	e030      	b.n	80a1cac <_Z36ChangePaletteAndSettingsPeriodicallyv+0x100>
        }
        if (secondHand == 35)  {
 80a1c4a:	2823      	cmp	r0, #35	; 0x23
 80a1c4c:	d108      	bne.n	80a1c60 <_Z36ChangePaletteAndSettingsPeriodicallyv+0xb4>
            currentPalette = PartyColors_p;
 80a1c4e:	4922      	ldr	r1, [pc, #136]	; (80a1cd8 <_Z36ChangePaletteAndSettingsPeriodicallyv+0x12c>)
 80a1c50:	481b      	ldr	r0, [pc, #108]	; (80a1cc0 <_Z36ChangePaletteAndSettingsPeriodicallyv+0x114>)
 80a1c52:	f7ff fd6f 	bl	80a1734 <_ZN9NSFastLED13CRGBPalette16aSERA16_Km>
            speed = 4;
 80a1c56:	4b1b      	ldr	r3, [pc, #108]	; (80a1cc4 <_Z36ChangePaletteAndSettingsPeriodicallyv+0x118>)
 80a1c58:	2204      	movs	r2, #4
 80a1c5a:	801a      	strh	r2, [r3, #0]
            scale = 30;
 80a1c5c:	221e      	movs	r2, #30
 80a1c5e:	e022      	b.n	80a1ca6 <_Z36ChangePaletteAndSettingsPeriodicallyv+0xfa>
            colorLoop = 1;
        }
        if (secondHand == 40)  {
 80a1c60:	2828      	cmp	r0, #40	; 0x28
 80a1c62:	d103      	bne.n	80a1c6c <_Z36ChangePaletteAndSettingsPeriodicallyv+0xc0>
            SetupRandomPalette();
 80a1c64:	f7ff ff40 	bl	80a1ae8 <_Z18SetupRandomPalettev>
            speed = 4;
 80a1c68:	2204      	movs	r2, #4
 80a1c6a:	e019      	b.n	80a1ca0 <_Z36ChangePaletteAndSettingsPeriodicallyv+0xf4>
            scale = 20;
            colorLoop = 1;
        }
        if (secondHand == 45)  {
 80a1c6c:	282d      	cmp	r0, #45	; 0x2d
 80a1c6e:	d106      	bne.n	80a1c7e <_Z36ChangePaletteAndSettingsPeriodicallyv+0xd2>
            SetupRandomPalette();
 80a1c70:	f7ff ff3a 	bl	80a1ae8 <_Z18SetupRandomPalettev>
            speed = 10;
 80a1c74:	220a      	movs	r2, #10
 80a1c76:	4b13      	ldr	r3, [pc, #76]	; (80a1cc4 <_Z36ChangePaletteAndSettingsPeriodicallyv+0x118>)
 80a1c78:	801a      	strh	r2, [r3, #0]
            scale = 50;
 80a1c7a:	2232      	movs	r2, #50	; 0x32
 80a1c7c:	e013      	b.n	80a1ca6 <_Z36ChangePaletteAndSettingsPeriodicallyv+0xfa>
            colorLoop = 1;
        }
        if (secondHand == 50)  {
 80a1c7e:	2832      	cmp	r0, #50	; 0x32
 80a1c80:	d107      	bne.n	80a1c92 <_Z36ChangePaletteAndSettingsPeriodicallyv+0xe6>
            SetupRandomPalette();
 80a1c82:	f7ff ff31 	bl	80a1ae8 <_Z18SetupRandomPalettev>
            speed = 90;
 80a1c86:	4a0f      	ldr	r2, [pc, #60]	; (80a1cc4 <_Z36ChangePaletteAndSettingsPeriodicallyv+0x118>)
 80a1c88:	235a      	movs	r3, #90	; 0x5a
 80a1c8a:	8013      	strh	r3, [r2, #0]
            scale = 90;
 80a1c8c:	4a11      	ldr	r2, [pc, #68]	; (80a1cd4 <_Z36ChangePaletteAndSettingsPeriodicallyv+0x128>)
 80a1c8e:	8013      	strh	r3, [r2, #0]
 80a1c90:	e00b      	b.n	80a1caa <_Z36ChangePaletteAndSettingsPeriodicallyv+0xfe>
            colorLoop = 1;
        }
        if (secondHand == 55)  {
 80a1c92:	2837      	cmp	r0, #55	; 0x37
 80a1c94:	d10c      	bne.n	80a1cb0 <_Z36ChangePaletteAndSettingsPeriodicallyv+0x104>
            currentPalette = RainbowStripeColors_p;
 80a1c96:	4911      	ldr	r1, [pc, #68]	; (80a1cdc <_Z36ChangePaletteAndSettingsPeriodicallyv+0x130>)
 80a1c98:	4809      	ldr	r0, [pc, #36]	; (80a1cc0 <_Z36ChangePaletteAndSettingsPeriodicallyv+0x114>)
 80a1c9a:	f7ff fd4b 	bl	80a1734 <_ZN9NSFastLED13CRGBPalette16aSERA16_Km>
            speed = 6;
 80a1c9e:	2206      	movs	r2, #6
 80a1ca0:	4b08      	ldr	r3, [pc, #32]	; (80a1cc4 <_Z36ChangePaletteAndSettingsPeriodicallyv+0x118>)
 80a1ca2:	801a      	strh	r2, [r3, #0]
            scale = 20;
 80a1ca4:	2214      	movs	r2, #20
 80a1ca6:	4b0b      	ldr	r3, [pc, #44]	; (80a1cd4 <_Z36ChangePaletteAndSettingsPeriodicallyv+0x128>)
 80a1ca8:	801a      	strh	r2, [r3, #0]
            colorLoop = 1;
 80a1caa:	2201      	movs	r2, #1
 80a1cac:	4b0c      	ldr	r3, [pc, #48]	; (80a1ce0 <_Z36ChangePaletteAndSettingsPeriodicallyv+0x134>)
 80a1cae:	701a      	strb	r2, [r3, #0]
 80a1cb0:	bd08      	pop	{r3, pc}
 80a1cb2:	bf00      	nop
 80a1cb4:	20000307 	.word	0x20000307
 80a1cb8:	080a66dc 	.word	0x080a66dc
 80a1cbc:	080a679c 	.word	0x080a679c
 80a1cc0:	200005b4 	.word	0x200005b4
 80a1cc4:	2000030e 	.word	0x2000030e
 80a1cc8:	080a675c 	.word	0x080a675c
 80a1ccc:	080a669c 	.word	0x080a669c
 80a1cd0:	080a681c 	.word	0x080a681c
 80a1cd4:	2000030c 	.word	0x2000030c
 80a1cd8:	080a671c 	.word	0x080a671c
 80a1cdc:	080a67dc 	.word	0x080a67dc
 80a1ce0:	20000306 	.word	0x20000306

080a1ce4 <_Z20loopNoisePlusPalettev>:
    y = random16();
    z = random16();
}

void loopNoisePlusPalette()
{
 80a1ce4:	b508      	push	{r3, lr}
    // Periodically choose a new palette, speed, and scale
    ChangePaletteAndSettingsPeriodically();
 80a1ce6:	f7ff ff61 	bl	80a1bac <_Z36ChangePaletteAndSettingsPeriodicallyv>

    // generate noise data
    fillnoise8();
 80a1cea:	f000 fbbd 	bl	80a2468 <_Z10fillnoise8v>

    // convert the noise data to colors in the LED array
    // using the current palette
    mapNoiseToLEDsUsingPalette();
}
 80a1cee:	e8bd 4008 	ldmia.w	sp!, {r3, lr}
    // generate noise data
    fillnoise8();

    // convert the noise data to colors in the LED array
    // using the current palette
    mapNoiseToLEDsUsingPalette();
 80a1cf2:	f7ff bd33 	b.w	80a175c <_Z26mapNoiseToLEDsUsingPalettev>
	...

080a1cf8 <_GLOBAL__sub_I_currentPalette>:
}
 80a1cf8:	b510      	push	{r4, lr}
 80a1cfa:	f001 fe31 	bl	80a3960 <HAL_Pin_Map>
    }

    CRGBPalette16( const TProgmemRGBPalette16& rhs)
    {
        for( uint8_t i = 0; i < 16; i++) {
            entries[i] =  pgm_read_dword_near( rhs + i);
 80a1cfe:	4c09      	ldr	r4, [pc, #36]	; (80a1d24 <_GLOBAL__sub_I_currentPalette+0x2c>)
 80a1d00:	4b09      	ldr	r3, [pc, #36]	; (80a1d28 <_GLOBAL__sub_I_currentPalette+0x30>)
 80a1d02:	2200      	movs	r2, #0
 80a1d04:	f854 1022 	ldr.w	r1, [r4, r2, lsl #2]
 80a1d08:	3201      	adds	r2, #1
    }

    // allow assignment from 32-bit (really 24-bit) 0xRRGGBB color code
	inline CRGB& operator= (const uint32_t colorcode) __attribute__((always_inline))
    {
        r = (colorcode >> 16) & 0xFF;
 80a1d0a:	0c08      	lsrs	r0, r1, #16
 80a1d0c:	f803 0c01 	strb.w	r0, [r3, #-1]
        return *this;
    }

    CRGBPalette16( const TProgmemRGBPalette16& rhs)
    {
        for( uint8_t i = 0; i < 16; i++) {
 80a1d10:	2a10      	cmp	r2, #16
        g = (colorcode >>  8) & 0xFF;
 80a1d12:	ea4f 2011 	mov.w	r0, r1, lsr #8
 80a1d16:	7018      	strb	r0, [r3, #0]
        b = (colorcode >>  0) & 0xFF;
 80a1d18:	7059      	strb	r1, [r3, #1]
 80a1d1a:	f103 0303 	add.w	r3, r3, #3
 80a1d1e:	d1f1      	bne.n	80a1d04 <_GLOBAL__sub_I_currentPalette+0xc>
 80a1d20:	bd10      	pop	{r4, pc}
 80a1d22:	bf00      	nop
 80a1d24:	080a671c 	.word	0x080a671c
 80a1d28:	200005b5 	.word	0x200005b5

080a1d2c <_Z10setupNoisev>:
static uint16_t z;

void setupNoise()
{

    speed = 3;
 80a1d2c:	4b0d      	ldr	r3, [pc, #52]	; (80a1d64 <_Z10setupNoisev+0x38>)
 80a1d2e:	2203      	movs	r2, #3
 80a1d30:	801a      	strh	r2, [r3, #0]
    scale = 311;
 80a1d32:	f240 1237 	movw	r2, #311	; 0x137
 80a1d36:	f243 6119 	movw	r1, #13849	; 0x3619
 80a1d3a:	4b0b      	ldr	r3, [pc, #44]	; (80a1d68 <_Z10setupNoisev+0x3c>)
 80a1d3c:	480b      	ldr	r0, [pc, #44]	; (80a1d6c <_Z10setupNoisev+0x40>)
 80a1d3e:	801a      	strh	r2, [r3, #0]
 80a1d40:	8803      	ldrh	r3, [r0, #0]
 80a1d42:	eb03 2243 	add.w	r2, r3, r3, lsl #9
 80a1d46:	eb03 0282 	add.w	r2, r3, r2, lsl #2
 80a1d4a:	440a      	add	r2, r1
 80a1d4c:	eb02 2342 	add.w	r3, r2, r2, lsl #9
 80a1d50:	eb02 0283 	add.w	r2, r2, r3, lsl #2
 80a1d54:	188b      	adds	r3, r1, r2
 80a1d56:	eb03 2243 	add.w	r2, r3, r3, lsl #9
 80a1d5a:	eb03 0382 	add.w	r3, r3, r2, lsl #2
 80a1d5e:	440b      	add	r3, r1
 80a1d60:	8003      	strh	r3, [r0, #0]
 80a1d62:	4770      	bx	lr
 80a1d64:	2000030e 	.word	0x2000030e
 80a1d68:	2000030c 	.word	0x2000030c
 80a1d6c:	20000310 	.word	0x20000310

080a1d70 <_Z9loopNoisev>:
    z = random16();
    y = random16();
}

void loopNoise()
{
 80a1d70:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80a1d74:	4f18      	ldr	r7, [pc, #96]	; (80a1dd8 <_Z9loopNoisev+0x68>)
    static uint8_t ihue = 0;

    fillnoise8();
 80a1d76:	f000 fb77 	bl	80a2468 <_Z10fillnoise8v>
 80a1d7a:	46b8      	mov	r8, r7

    for (int i = 0; i < kMatrixHeight; i++) {
 80a1d7c:	2400      	movs	r4, #0
 80a1d7e:	261b      	movs	r6, #27
 80a1d80:	fb06 7b04 	mla	fp, r6, r4, r7
 80a1d84:	2500      	movs	r5, #0
        for (int j = 0; j < kMatrixWidth; j++) {
            leds[XY(i, j)] = CHSV(noise[j][i], 255, noise[i][j]);
 80a1d86:	fa5f f984 	uxtb.w	r9, r4
 80a1d8a:	eb08 0a04 	add.w	sl, r8, r4
 80a1d8e:	b2e9      	uxtb	r1, r5
 80a1d90:	4648      	mov	r0, r9
 80a1d92:	f000 fb3d 	bl	80a2410 <_Z2XYhh>
 80a1d96:	fb06 f105 	mul.w	r1, r6, r5
    {
    }

    // allow construction from H, S, V
    inline CHSV( uint8_t ih, uint8_t is, uint8_t iv) __attribute__((always_inline))
        : h(ih), s(is), v(iv)
 80a1d9a:	f81a 1001 	ldrb.w	r1, [sl, r1]
    }

    // allow assignment from HSV color
	inline CRGB& operator= (const CHSV& rhs) __attribute__((always_inline))
    {
        hsv2rgb_rainbow( rhs, *this);
 80a1d9e:	4b0f      	ldr	r3, [pc, #60]	; (80a1ddc <_Z9loopNoisev+0x6c>)
 80a1da0:	f81b 2005 	ldrb.w	r2, [fp, r5]
    {
    }

    // allow construction from H, S, V
    inline CHSV( uint8_t ih, uint8_t is, uint8_t iv) __attribute__((always_inline))
        : h(ih), s(is), v(iv)
 80a1da4:	f88d 1004 	strb.w	r1, [sp, #4]
 80a1da8:	eb00 0040 	add.w	r0, r0, r0, lsl #1
 80a1dac:	21ff      	movs	r1, #255	; 0xff
 80a1dae:	f88d 1005 	strb.w	r1, [sp, #5]
    static uint8_t ihue = 0;

    fillnoise8();

    for (int i = 0; i < kMatrixHeight; i++) {
        for (int j = 0; j < kMatrixWidth; j++) {
 80a1db2:	3501      	adds	r5, #1
    }

    // allow assignment from HSV color
	inline CRGB& operator= (const CHSV& rhs) __attribute__((always_inline))
    {
        hsv2rgb_rainbow( rhs, *this);
 80a1db4:	1819      	adds	r1, r3, r0
 80a1db6:	a801      	add	r0, sp, #4
    {
    }

    // allow construction from H, S, V
    inline CHSV( uint8_t ih, uint8_t is, uint8_t iv) __attribute__((always_inline))
        : h(ih), s(is), v(iv)
 80a1db8:	f88d 2006 	strb.w	r2, [sp, #6]
    }

    // allow assignment from HSV color
	inline CRGB& operator= (const CHSV& rhs) __attribute__((always_inline))
    {
        hsv2rgb_rainbow( rhs, *this);
 80a1dbc:	f000 fc18 	bl	80a25f0 <_ZN9NSFastLED15hsv2rgb_rainbowERKNS_4CHSVERNS_4CRGBE>
 80a1dc0:	2d04      	cmp	r5, #4
 80a1dc2:	d1e4      	bne.n	80a1d8e <_Z9loopNoisev+0x1e>
{
    static uint8_t ihue = 0;

    fillnoise8();

    for (int i = 0; i < kMatrixHeight; i++) {
 80a1dc4:	3401      	adds	r4, #1
 80a1dc6:	2c1b      	cmp	r4, #27
 80a1dc8:	d1da      	bne.n	80a1d80 <_Z9loopNoisev+0x10>
        for (int j = 0; j < kMatrixWidth; j++) {
            leds[XY(i, j)] = CHSV(noise[j][i], 255, noise[i][j]);
        }
    }

    ihue += 1;
 80a1dca:	4a05      	ldr	r2, [pc, #20]	; (80a1de0 <_Z9loopNoisev+0x70>)
 80a1dcc:	7813      	ldrb	r3, [r2, #0]
 80a1dce:	3301      	adds	r3, #1
 80a1dd0:	7013      	strb	r3, [r2, #0]
}
 80a1dd2:	b003      	add	sp, #12
 80a1dd4:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80a1dd8:	20000610 	.word	0x20000610
 80a1ddc:	200003b4 	.word	0x200003b4
 80a1de0:	200005e5 	.word	0x200005e5

080a1de4 <_GLOBAL__sub_I__Z10setupNoisev>:
 80a1de4:	f001 bdbc 	b.w	80a3960 <HAL_Pin_Map>

080a1de8 <_Z9setupFirev>:

extern CRGB leds[NUM_LEDS];

static byte heat[kMatrixHeight];

void setupFire() {
 80a1de8:	2300      	movs	r3, #0
    }

    // allow assignment from 32-bit (really 24-bit) 0xRRGGBB color code
	inline CRGB& operator= (const uint32_t colorcode) __attribute__((always_inline))
    {
        r = (colorcode >> 16) & 0xFF;
 80a1dea:	461a      	mov	r2, r3
 80a1dec:	4804      	ldr	r0, [pc, #16]	; (80a1e00 <_Z9setupFirev+0x18>)
 80a1dee:	1819      	adds	r1, r3, r0
 80a1df0:	541a      	strb	r2, [r3, r0]
 80a1df2:	3303      	adds	r3, #3
    for (int i = 0; i < NUM_LEDS; i++) {
 80a1df4:	f5b3 7fa2 	cmp.w	r3, #324	; 0x144
        g = (colorcode >>  8) & 0xFF;
 80a1df8:	704a      	strb	r2, [r1, #1]
        b = (colorcode >>  0) & 0xFF;
 80a1dfa:	708a      	strb	r2, [r1, #2]
 80a1dfc:	d1f7      	bne.n	80a1dee <_Z9setupFirev+0x6>
        leds[i] = 0;
    }
}
 80a1dfe:	4770      	bx	lr
 80a1e00:	200003b4 	.word	0x200003b4
 80a1e04:	00000000 	.word	0x00000000

080a1e08 <_Z8loopFirev>:

void loopFire() {
 80a1e08:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
 80a1e0c:	4c84      	ldr	r4, [pc, #528]	; (80a2020 <_Z8loopFirev+0x218>)
    int Sparking = 120;
    int cooldown = 0;

    // Step 1.  Cool down every cell a little
    for (int i = 0; i < kMatrixHeight; i++) {
            cooldown = random(0, ((Cooling * 10) / kMatrixHeight) + 2);
 80a1e0e:	2600      	movs	r6, #0
 80a1e10:	f104 051b 	add.w	r5, r4, #27
 80a1e14:	2116      	movs	r1, #22
 80a1e16:	2000      	movs	r0, #0
 80a1e18:	f001 fea3 	bl	80a3b62 <_Z6randomii>

            if (cooldown > heat[i]) {
 80a1e1c:	f814 3f01 	ldrb.w	r3, [r4, #1]!
 80a1e20:	4298      	cmp	r0, r3
                heat[i] = 0;
            } else {
                heat[i] = heat[i] - cooldown;
 80a1e22:	bfd6      	itet	le
 80a1e24:	1a1b      	suble	r3, r3, r0
    // Step 1.  Cool down every cell a little
    for (int i = 0; i < kMatrixHeight; i++) {
            cooldown = random(0, ((Cooling * 10) / kMatrixHeight) + 2);

            if (cooldown > heat[i]) {
                heat[i] = 0;
 80a1e26:	7026      	strbgt	r6, [r4, #0]
            } else {
                heat[i] = heat[i] - cooldown;
 80a1e28:	7023      	strble	r3, [r4, #0]
    int Cooling = 55;
    int Sparking = 120;
    int cooldown = 0;

    // Step 1.  Cool down every cell a little
    for (int i = 0; i < kMatrixHeight; i++) {
 80a1e2a:	42a5      	cmp	r5, r4
 80a1e2c:	d1f2      	bne.n	80a1e14 <_Z8loopFirev+0xc>
 80a1e2e:	4b7d      	ldr	r3, [pc, #500]	; (80a2024 <_Z8loopFirev+0x21c>)
        }
    }

    // Step 2.  Heat from each cell drifts 'up' and diffuses a little
    for (int i = 2; i < kMatrixHeight; i++) {
            heat[i] = (heat[i - 1] + heat[i - 2] + heat[i - 2]) / 3;
 80a1e30:	2103      	movs	r1, #3
 80a1e32:	f813 2b01 	ldrb.w	r2, [r3], #1
 80a1e36:	f813 0c02 	ldrb.w	r0, [r3, #-2]
                heat[i] = heat[i] - cooldown;
        }
    }

    // Step 2.  Heat from each cell drifts 'up' and diffuses a little
    for (int i = 2; i < kMatrixHeight; i++) {
 80a1e3a:	42ab      	cmp	r3, r5
            heat[i] = (heat[i - 1] + heat[i - 2] + heat[i - 2]) / 3;
 80a1e3c:	eb02 0240 	add.w	r2, r2, r0, lsl #1
 80a1e40:	fb92 f2f1 	sdiv	r2, r2, r1
 80a1e44:	701a      	strb	r2, [r3, #0]
                heat[i] = heat[i] - cooldown;
        }
    }

    // Step 2.  Heat from each cell drifts 'up' and diffuses a little
    for (int i = 2; i < kMatrixHeight; i++) {
 80a1e46:	d1f4      	bne.n	80a1e32 <_Z8loopFirev+0x2a>
    // Step 3.  Randomly ignite new 'sparks' near the bottom
    for (int i = 0; i < kMatrixHeight; i++) {
        int y = 0;
        if (random(255) < Sparking) {
            y = random(7);
            heat[y] = heat[y] + random(160, 255);
 80a1e48:	4d77      	ldr	r5, [pc, #476]	; (80a2028 <_Z8loopFirev+0x220>)
 80a1e4a:	271b      	movs	r7, #27
    }

    // Step 3.  Randomly ignite new 'sparks' near the bottom
    for (int i = 0; i < kMatrixHeight; i++) {
        int y = 0;
        if (random(255) < Sparking) {
 80a1e4c:	20ff      	movs	r0, #255	; 0xff
 80a1e4e:	f001 fe7d 	bl	80a3b4c <_Z6randomi>
 80a1e52:	2877      	cmp	r0, #119	; 0x77
 80a1e54:	dc0a      	bgt.n	80a1e6c <_Z8loopFirev+0x64>
            y = random(7);
 80a1e56:	2007      	movs	r0, #7
 80a1e58:	f001 fe78 	bl	80a3b4c <_Z6randomi>
            heat[y] = heat[y] + random(160, 255);
 80a1e5c:	21ff      	movs	r1, #255	; 0xff
 80a1e5e:	5c2c      	ldrb	r4, [r5, r0]

    // Step 3.  Randomly ignite new 'sparks' near the bottom
    for (int i = 0; i < kMatrixHeight; i++) {
        int y = 0;
        if (random(255) < Sparking) {
            y = random(7);
 80a1e60:	4606      	mov	r6, r0
            heat[y] = heat[y] + random(160, 255);
 80a1e62:	20a0      	movs	r0, #160	; 0xa0
 80a1e64:	f001 fe7d 	bl	80a3b62 <_Z6randomii>
 80a1e68:	4420      	add	r0, r4
 80a1e6a:	55a8      	strb	r0, [r5, r6]
    for (int i = 2; i < kMatrixHeight; i++) {
            heat[i] = (heat[i - 1] + heat[i - 2] + heat[i - 2]) / 3;
    }

    // Step 3.  Randomly ignite new 'sparks' near the bottom
    for (int i = 0; i < kMatrixHeight; i++) {
 80a1e6c:	3f01      	subs	r7, #1
 80a1e6e:	d1ed      	bne.n	80a1e4c <_Z8loopFirev+0x44>
    byte t192 = 0;
    byte heatramp = 0;

    for (int i = 0; i < kMatrixHeight; i++) {
            // Scale 'heat' down from 0-255 to 0-191
            t192 = round((heat[i] / 255.0)*191);
 80a1e70:	4b6d      	ldr	r3, [pc, #436]	; (80a2028 <_Z8loopFirev+0x220>)
 80a1e72:	5dd8      	ldrb	r0, [r3, r7]
 80a1e74:	f003 fc44 	bl	80a5700 <__aeabi_i2d>
 80a1e78:	a365      	add	r3, pc, #404	; (adr r3, 80a2010 <_Z8loopFirev+0x208>)
 80a1e7a:	e9d3 2300 	ldrd	r2, r3, [r3]
 80a1e7e:	f003 fdcf 	bl	80a5a20 <__aeabi_ddiv>
 80a1e82:	a365      	add	r3, pc, #404	; (adr r3, 80a2018 <_Z8loopFirev+0x210>)
 80a1e84:	e9d3 2300 	ldrd	r2, r3, [r3]
 80a1e88:	f003 fca0 	bl	80a57cc <__aeabi_dmul>
static inline
T constrain (T amt, U low, V high) { return ((amt)<(low)?(low):((amt)>(high)?(high):(amt))); }

template <typename T>
static inline
T round (T x) { return ((x)>=0?(long)((x)+0.5):(long)((x)-0.5)); }
 80a1e8c:	2200      	movs	r2, #0
 80a1e8e:	2300      	movs	r3, #0
 80a1e90:	4604      	mov	r4, r0
 80a1e92:	460d      	mov	r5, r1
 80a1e94:	f003 ff20 	bl	80a5cd8 <__aeabi_dcmpge>
 80a1e98:	2200      	movs	r2, #0
 80a1e9a:	4b64      	ldr	r3, [pc, #400]	; (80a202c <_Z8loopFirev+0x224>)
 80a1e9c:	b120      	cbz	r0, 80a1ea8 <_Z8loopFirev+0xa0>
 80a1e9e:	4620      	mov	r0, r4
 80a1ea0:	4629      	mov	r1, r5
 80a1ea2:	f003 fae1 	bl	80a5468 <__adddf3>
 80a1ea6:	e003      	b.n	80a1eb0 <_Z8loopFirev+0xa8>
 80a1ea8:	4620      	mov	r0, r4
 80a1eaa:	4629      	mov	r1, r5
 80a1eac:	f003 fada 	bl	80a5464 <__aeabi_dsub>
 80a1eb0:	f003 ff26 	bl	80a5d00 <__aeabi_d2iz>
 80a1eb4:	f003 fc24 	bl	80a5700 <__aeabi_i2d>
 80a1eb8:	f003 ff4a 	bl	80a5d50 <__aeabi_d2uiz>
 80a1ebc:	b2c0      	uxtb	r0, r0
 80a1ebe:	0085      	lsls	r5, r0, #2
            // calculate ramp up from
            heatramp = t192 & 0x3F; // 0..63
            heatramp <<= 2; // scale up to 0..252

            // figure out which third of the spectrum we're in:
            if (t192 > 0x80) { // hottest
 80a1ec0:	2880      	cmp	r0, #128	; 0x80
 80a1ec2:	b2ed      	uxtb	r5, r5
                leds[XY(i, 0)] = CRGB(255, 255, heatramp);
 80a1ec4:	f04f 0100 	mov.w	r1, #0
 80a1ec8:	b2fe      	uxtb	r6, r7
 80a1eca:	4c59      	ldr	r4, [pc, #356]	; (80a2030 <_Z8loopFirev+0x228>)
            // calculate ramp up from
            heatramp = t192 & 0x3F; // 0..63
            heatramp <<= 2; // scale up to 0..252

            // figure out which third of the spectrum we're in:
            if (t192 > 0x80) { // hottest
 80a1ecc:	d931      	bls.n	80a1f32 <_Z8loopFirev+0x12a>
                leds[XY(i, 0)] = CRGB(255, 255, heatramp);
 80a1ece:	4630      	mov	r0, r6
 80a1ed0:	f000 fa9e 	bl	80a2410 <_Z2XYhh>
    }

    // allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
 80a1ed4:	eb00 0040 	add.w	r0, r0, r0, lsl #1
 80a1ed8:	f04f 08ff 	mov.w	r8, #255	; 0xff
 80a1edc:	1823      	adds	r3, r4, r0
 80a1ede:	f804 8000 	strb.w	r8, [r4, r0]
                leds[XY(i, 1)] = CRGB(255, 255, heatramp);
 80a1ee2:	2101      	movs	r1, #1
        g = rhs.g;
 80a1ee4:	f883 8001 	strb.w	r8, [r3, #1]
        b = rhs.b;
 80a1ee8:	709d      	strb	r5, [r3, #2]
 80a1eea:	4630      	mov	r0, r6
 80a1eec:	f000 fa90 	bl	80a2410 <_Z2XYhh>
    }

    // allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
 80a1ef0:	eb00 0040 	add.w	r0, r0, r0, lsl #1
 80a1ef4:	1823      	adds	r3, r4, r0
 80a1ef6:	f804 8000 	strb.w	r8, [r4, r0]
                leds[XY(i, 2)] = CRGB(255, 255, heatramp);
 80a1efa:	2102      	movs	r1, #2
        g = rhs.g;
 80a1efc:	f883 8001 	strb.w	r8, [r3, #1]
        b = rhs.b;
 80a1f00:	709d      	strb	r5, [r3, #2]
 80a1f02:	4630      	mov	r0, r6
 80a1f04:	f000 fa84 	bl	80a2410 <_Z2XYhh>
    }

    // allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
 80a1f08:	eb00 0040 	add.w	r0, r0, r0, lsl #1
 80a1f0c:	1823      	adds	r3, r4, r0
 80a1f0e:	f804 8000 	strb.w	r8, [r4, r0]
                leds[XY(i, 3)] = CRGB(255, 255, heatramp);
 80a1f12:	2103      	movs	r1, #3
        g = rhs.g;
 80a1f14:	f883 8001 	strb.w	r8, [r3, #1]
        b = rhs.b;
 80a1f18:	709d      	strb	r5, [r3, #2]
 80a1f1a:	4630      	mov	r0, r6
 80a1f1c:	f000 fa78 	bl	80a2410 <_Z2XYhh>
    }

    // allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
 80a1f20:	eb00 0040 	add.w	r0, r0, r0, lsl #1
 80a1f24:	1823      	adds	r3, r4, r0
 80a1f26:	f804 8000 	strb.w	r8, [r4, r0]
        g = rhs.g;
 80a1f2a:	f883 8001 	strb.w	r8, [r3, #1]
        b = rhs.b;
 80a1f2e:	709d      	strb	r5, [r3, #2]
 80a1f30:	e063      	b.n	80a1ffa <_Z8loopFirev+0x1f2>
            } else if (t192 > 0x40) { // middle
 80a1f32:	2840      	cmp	r0, #64	; 0x40
                leds[XY(i, 0)] = CRGB(heatramp, 255, 0);
 80a1f34:	4630      	mov	r0, r6
            if (t192 > 0x80) { // hottest
                leds[XY(i, 0)] = CRGB(255, 255, heatramp);
                leds[XY(i, 1)] = CRGB(255, 255, heatramp);
                leds[XY(i, 2)] = CRGB(255, 255, heatramp);
                leds[XY(i, 3)] = CRGB(255, 255, heatramp);
            } else if (t192 > 0x40) { // middle
 80a1f36:	d930      	bls.n	80a1f9a <_Z8loopFirev+0x192>
                leds[XY(i, 0)] = CRGB(heatramp, 255, 0);
 80a1f38:	f000 fa6a 	bl	80a2410 <_Z2XYhh>
    }

    // allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
 80a1f3c:	eb00 0040 	add.w	r0, r0, r0, lsl #1
 80a1f40:	1823      	adds	r3, r4, r0
        g = rhs.g;
 80a1f42:	f04f 09ff 	mov.w	r9, #255	; 0xff
        b = rhs.b;
 80a1f46:	f04f 0800 	mov.w	r8, #0
    }

    // allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
 80a1f4a:	5425      	strb	r5, [r4, r0]
                leds[XY(i, 1)] = CRGB(heatramp, 255, 0);
 80a1f4c:	2101      	movs	r1, #1
        g = rhs.g;
 80a1f4e:	f883 9001 	strb.w	r9, [r3, #1]
        b = rhs.b;
 80a1f52:	f883 8002 	strb.w	r8, [r3, #2]
 80a1f56:	4630      	mov	r0, r6
 80a1f58:	f000 fa5a 	bl	80a2410 <_Z2XYhh>
    }

    // allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
 80a1f5c:	eb00 0040 	add.w	r0, r0, r0, lsl #1
 80a1f60:	1823      	adds	r3, r4, r0
 80a1f62:	5425      	strb	r5, [r4, r0]
                leds[XY(i, 2)] = CRGB(heatramp, 255, 0);
 80a1f64:	2102      	movs	r1, #2
        g = rhs.g;
 80a1f66:	f883 9001 	strb.w	r9, [r3, #1]
        b = rhs.b;
 80a1f6a:	f883 8002 	strb.w	r8, [r3, #2]
 80a1f6e:	4630      	mov	r0, r6
 80a1f70:	f000 fa4e 	bl	80a2410 <_Z2XYhh>
    }

    // allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
 80a1f74:	eb00 0040 	add.w	r0, r0, r0, lsl #1
 80a1f78:	1823      	adds	r3, r4, r0
 80a1f7a:	5425      	strb	r5, [r4, r0]
                leds[XY(i, 3)] = CRGB(heatramp, 255, 0);
 80a1f7c:	2103      	movs	r1, #3
        g = rhs.g;
 80a1f7e:	f883 9001 	strb.w	r9, [r3, #1]
        b = rhs.b;
 80a1f82:	f883 8002 	strb.w	r8, [r3, #2]
 80a1f86:	4630      	mov	r0, r6
 80a1f88:	f000 fa42 	bl	80a2410 <_Z2XYhh>
    }

    // allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
 80a1f8c:	eb00 0040 	add.w	r0, r0, r0, lsl #1
 80a1f90:	1823      	adds	r3, r4, r0
 80a1f92:	5425      	strb	r5, [r4, r0]
        g = rhs.g;
 80a1f94:	f883 9001 	strb.w	r9, [r3, #1]
 80a1f98:	e02d      	b.n	80a1ff6 <_Z8loopFirev+0x1ee>
            } else { // coolest
                leds[XY(i, 0)] = CRGB(0, heatramp, 0);
 80a1f9a:	f000 fa39 	bl	80a2410 <_Z2XYhh>
    }

    // allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
 80a1f9e:	eb00 0040 	add.w	r0, r0, r0, lsl #1
 80a1fa2:	f04f 0800 	mov.w	r8, #0
 80a1fa6:	1823      	adds	r3, r4, r0
 80a1fa8:	f804 8000 	strb.w	r8, [r4, r0]
                leds[XY(i, 1)] = CRGB(0, heatramp, 0);
 80a1fac:	2101      	movs	r1, #1
        g = rhs.g;
 80a1fae:	705d      	strb	r5, [r3, #1]
        b = rhs.b;
 80a1fb0:	f883 8002 	strb.w	r8, [r3, #2]
 80a1fb4:	4630      	mov	r0, r6
 80a1fb6:	f000 fa2b 	bl	80a2410 <_Z2XYhh>
    }

    // allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
 80a1fba:	eb00 0040 	add.w	r0, r0, r0, lsl #1
 80a1fbe:	1823      	adds	r3, r4, r0
 80a1fc0:	f804 8000 	strb.w	r8, [r4, r0]
                leds[XY(i, 2)] = CRGB(0, heatramp, 0);
 80a1fc4:	2102      	movs	r1, #2
        g = rhs.g;
 80a1fc6:	705d      	strb	r5, [r3, #1]
        b = rhs.b;
 80a1fc8:	f883 8002 	strb.w	r8, [r3, #2]
 80a1fcc:	4630      	mov	r0, r6
 80a1fce:	f000 fa1f 	bl	80a2410 <_Z2XYhh>
    }

    // allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
 80a1fd2:	eb00 0040 	add.w	r0, r0, r0, lsl #1
 80a1fd6:	1823      	adds	r3, r4, r0
 80a1fd8:	f804 8000 	strb.w	r8, [r4, r0]
                leds[XY(i, 3)] = CRGB(0, heatramp, 0);
 80a1fdc:	2103      	movs	r1, #3
        g = rhs.g;
 80a1fde:	705d      	strb	r5, [r3, #1]
        b = rhs.b;
 80a1fe0:	f883 8002 	strb.w	r8, [r3, #2]
 80a1fe4:	4630      	mov	r0, r6
 80a1fe6:	f000 fa13 	bl	80a2410 <_Z2XYhh>
    }

    // allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
 80a1fea:	eb00 0040 	add.w	r0, r0, r0, lsl #1
 80a1fee:	1823      	adds	r3, r4, r0
 80a1ff0:	f804 8000 	strb.w	r8, [r4, r0]
        g = rhs.g;
 80a1ff4:	705d      	strb	r5, [r3, #1]
        b = rhs.b;
 80a1ff6:	f883 8002 	strb.w	r8, [r3, #2]
    // Step 4.  Convert heat to LED colors
    // Scale 'heat' down from 0-255 to 0-191
    byte t192 = 0;
    byte heatramp = 0;

    for (int i = 0; i < kMatrixHeight; i++) {
 80a1ffa:	3701      	adds	r7, #1
 80a1ffc:	2f1b      	cmp	r7, #27
 80a1ffe:	f47f af37 	bne.w	80a1e70 <_Z8loopFirev+0x68>
                leds[XY(i, 2)] = CRGB(0, heatramp, 0);
                leds[XY(i, 3)] = CRGB(0, heatramp, 0);
            }
    }

    delay(120);
 80a2002:	2078      	movs	r0, #120	; 0x78
}
 80a2004:	e8bd 43f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
                leds[XY(i, 2)] = CRGB(0, heatramp, 0);
                leds[XY(i, 3)] = CRGB(0, heatramp, 0);
            }
    }

    delay(120);
 80a2008:	f002 b9be 	b.w	80a4388 <delay>
 80a200c:	f3af 8000 	nop.w
 80a2010:	00000000 	.word	0x00000000
 80a2014:	406fe000 	.word	0x406fe000
 80a2018:	00000000 	.word	0x00000000
 80a201c:	4067e000 	.word	0x4067e000
 80a2020:	200005e5 	.word	0x200005e5
 80a2024:	200005e7 	.word	0x200005e7
 80a2028:	200005e6 	.word	0x200005e6
 80a202c:	3fe00000 	.word	0x3fe00000
 80a2030:	200003b4 	.word	0x200003b4

080a2034 <_GLOBAL__sub_I__Z9setupFirev>:
 80a2034:	f001 bc94 	b.w	80a3960 <HAL_Pin_Map>

080a2038 <_Z11setupSpiralv>:

int direction = 1;
uint8_t cur_x = 0;
uint8_t cur_y = 0;

void setupSpiral() {
 80a2038:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
    }

    // allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
 80a203c:	4f11      	ldr	r7, [pc, #68]	; (80a2084 <_Z11setupSpiralv+0x4c>)
 80a203e:	4e12      	ldr	r6, [pc, #72]	; (80a2088 <_Z11setupSpiralv+0x50>)
    for (int i = 0; i < kMatrixHeight; i++) {
 80a2040:	2400      	movs	r4, #0
 80a2042:	2500      	movs	r5, #0
        for (int j = 0; j < kMatrixWidth; j++) {
            leds[XY(i, j)] = bg_color;
 80a2044:	fa5f f884 	uxtb.w	r8, r4
 80a2048:	b2e9      	uxtb	r1, r5
 80a204a:	4640      	mov	r0, r8
 80a204c:	f000 f9e0 	bl	80a2410 <_Z2XYhh>
 80a2050:	7832      	ldrb	r2, [r6, #0]
 80a2052:	eb00 0040 	add.w	r0, r0, r0, lsl #1
 80a2056:	543a      	strb	r2, [r7, r0]
        g = rhs.g;
 80a2058:	7872      	ldrb	r2, [r6, #1]
    }

    // allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
 80a205a:	183b      	adds	r3, r7, r0
        g = rhs.g;
 80a205c:	705a      	strb	r2, [r3, #1]
uint8_t cur_x = 0;
uint8_t cur_y = 0;

void setupSpiral() {
    for (int i = 0; i < kMatrixHeight; i++) {
        for (int j = 0; j < kMatrixWidth; j++) {
 80a205e:	3501      	adds	r5, #1
        b = rhs.b;
 80a2060:	78b2      	ldrb	r2, [r6, #2]
 80a2062:	2d04      	cmp	r5, #4
 80a2064:	709a      	strb	r2, [r3, #2]
 80a2066:	d1ef      	bne.n	80a2048 <_Z11setupSpiralv+0x10>
int direction = 1;
uint8_t cur_x = 0;
uint8_t cur_y = 0;

void setupSpiral() {
    for (int i = 0; i < kMatrixHeight; i++) {
 80a2068:	3401      	adds	r4, #1
 80a206a:	2c1b      	cmp	r4, #27
 80a206c:	d1e9      	bne.n	80a2042 <_Z11setupSpiralv+0xa>
        for (int j = 0; j < kMatrixWidth; j++) {
            leds[XY(i, j)] = bg_color;
        }
    }

    direction = 1;
 80a206e:	4b07      	ldr	r3, [pc, #28]	; (80a208c <_Z11setupSpiralv+0x54>)
 80a2070:	2201      	movs	r2, #1
 80a2072:	601a      	str	r2, [r3, #0]
    cur_x = 0;
 80a2074:	4a06      	ldr	r2, [pc, #24]	; (80a2090 <_Z11setupSpiralv+0x58>)
 80a2076:	2300      	movs	r3, #0
 80a2078:	7013      	strb	r3, [r2, #0]
    cur_y = 0;
 80a207a:	4a06      	ldr	r2, [pc, #24]	; (80a2094 <_Z11setupSpiralv+0x5c>)
 80a207c:	7013      	strb	r3, [r2, #0]
 80a207e:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80a2082:	bf00      	nop
 80a2084:	200003b4 	.word	0x200003b4
 80a2088:	200004f8 	.word	0x200004f8
 80a208c:	20000308 	.word	0x20000308
 80a2090:	20000601 	.word	0x20000601
 80a2094:	20000602 	.word	0x20000602

080a2098 <_Z10loopSpiralv>:
}

void loopSpiral() {
 80a2098:	b5f8      	push	{r3, r4, r5, r6, r7, lr}

    leds[XY(cur_x, cur_y)] = (direction >0) ? fg_color : bg_color;
 80a209a:	4c13      	ldr	r4, [pc, #76]	; (80a20e8 <_Z10loopSpiralv+0x50>)
 80a209c:	4d13      	ldr	r5, [pc, #76]	; (80a20ec <_Z10loopSpiralv+0x54>)
 80a209e:	7821      	ldrb	r1, [r4, #0]
 80a20a0:	7828      	ldrb	r0, [r5, #0]
 80a20a2:	f000 f9b5 	bl	80a2410 <_Z2XYhh>
 80a20a6:	4b12      	ldr	r3, [pc, #72]	; (80a20f0 <_Z10loopSpiralv+0x58>)
 80a20a8:	4912      	ldr	r1, [pc, #72]	; (80a20f4 <_Z10loopSpiralv+0x5c>)
 80a20aa:	681b      	ldr	r3, [r3, #0]
 80a20ac:	4a12      	ldr	r2, [pc, #72]	; (80a20f8 <_Z10loopSpiralv+0x60>)
    }

    // allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
 80a20ae:	4e13      	ldr	r6, [pc, #76]	; (80a20fc <_Z10loopSpiralv+0x64>)
 80a20b0:	2b00      	cmp	r3, #0
 80a20b2:	bfd8      	it	le
 80a20b4:	460a      	movle	r2, r1
 80a20b6:	7817      	ldrb	r7, [r2, #0]
 80a20b8:	eb00 0040 	add.w	r0, r0, r0, lsl #1
 80a20bc:	1831      	adds	r1, r6, r0
 80a20be:	5437      	strb	r7, [r6, r0]
        g = rhs.g;
 80a20c0:	7850      	ldrb	r0, [r2, #1]
        b = rhs.b;
 80a20c2:	7892      	ldrb	r2, [r2, #2]

    cur_x = cur_x + direction;
 80a20c4:	b2db      	uxtb	r3, r3
 80a20c6:	708a      	strb	r2, [r1, #2]
 80a20c8:	782a      	ldrb	r2, [r5, #0]

    // allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
        g = rhs.g;
 80a20ca:	7048      	strb	r0, [r1, #1]
 80a20cc:	441a      	add	r2, r3
 80a20ce:	702a      	strb	r2, [r5, #0]
 80a20d0:	480b      	ldr	r0, [pc, #44]	; (80a2100 <_Z10loopSpiralv+0x68>)
    cur_y = cur_y + direction;
 80a20d2:	7822      	ldrb	r2, [r4, #0]
 80a20d4:	7801      	ldrb	r1, [r0, #0]
 80a20d6:	4413      	add	r3, r2
 80a20d8:	7023      	strb	r3, [r4, #0]
 80a20da:	f000 fe07 	bl	80a2cec <_ZN9NSFastLED8CFastLED4showEh>
    }


	FastLED.show();
	delay(100);
}
 80a20de:	e8bd 40f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, lr}
    } else {
    }


	FastLED.show();
	delay(100);
 80a20e2:	2064      	movs	r0, #100	; 0x64
 80a20e4:	f002 b950 	b.w	80a4388 <delay>
 80a20e8:	20000602 	.word	0x20000602
 80a20ec:	20000601 	.word	0x20000601
 80a20f0:	20000308 	.word	0x20000308
 80a20f4:	200004f8 	.word	0x200004f8
 80a20f8:	20000590 	.word	0x20000590
 80a20fc:	200003b4 	.word	0x200003b4
 80a2100:	200008ec 	.word	0x200008ec

080a2104 <_GLOBAL__sub_I_direction>:
 80a2104:	f001 bc2c 	b.w	80a3960 <HAL_Pin_Map>

080a2108 <_Z17loopVerticalSplitv>:
        }
    }
}

void loopVerticalSplit()
{
 80a2108:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
    }

    // allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
 80a210a:	4f21      	ldr	r7, [pc, #132]	; (80a2190 <_Z17loopVerticalSplitv+0x88>)
 80a210c:	4c21      	ldr	r4, [pc, #132]	; (80a2194 <_Z17loopVerticalSplitv+0x8c>)
 80a210e:	2500      	movs	r5, #0
    uint16_t i = 0;
    uint16_t j = 0;

    for (i = 0; i < kMatrixHeight; i++) {
        for (j = 0; j < round(kMatrixWidth/2); j++) {
            leds[XY(i, j)] = fg_color;
 80a2110:	b2ee      	uxtb	r6, r5
 80a2112:	2100      	movs	r1, #0
 80a2114:	4630      	mov	r0, r6
 80a2116:	f000 f97b 	bl	80a2410 <_Z2XYhh>
 80a211a:	7822      	ldrb	r2, [r4, #0]
 80a211c:	eb00 0040 	add.w	r0, r0, r0, lsl #1
 80a2120:	543a      	strb	r2, [r7, r0]
        g = rhs.g;
 80a2122:	7862      	ldrb	r2, [r4, #1]
    }

    // allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
 80a2124:	183b      	adds	r3, r7, r0
        g = rhs.g;
 80a2126:	705a      	strb	r2, [r3, #1]
        b = rhs.b;
 80a2128:	78a2      	ldrb	r2, [r4, #2]
 80a212a:	4630      	mov	r0, r6
 80a212c:	709a      	strb	r2, [r3, #2]
 80a212e:	2101      	movs	r1, #1
 80a2130:	f000 f96e 	bl	80a2410 <_Z2XYhh>
    }

    // allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
 80a2134:	7822      	ldrb	r2, [r4, #0]
 80a2136:	eb00 0040 	add.w	r0, r0, r0, lsl #1
 80a213a:	543a      	strb	r2, [r7, r0]
        g = rhs.g;
 80a213c:	7862      	ldrb	r2, [r4, #1]
    }

    // allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
 80a213e:	183b      	adds	r3, r7, r0
        g = rhs.g;
 80a2140:	705a      	strb	r2, [r3, #1]
 80a2142:	3501      	adds	r5, #1
        b = rhs.b;
 80a2144:	78a2      	ldrb	r2, [r4, #2]
void loopVerticalSplit()
{
    uint16_t i = 0;
    uint16_t j = 0;

    for (i = 0; i < kMatrixHeight; i++) {
 80a2146:	2d1b      	cmp	r5, #27
 80a2148:	709a      	strb	r2, [r3, #2]
 80a214a:	4e11      	ldr	r6, [pc, #68]	; (80a2190 <_Z17loopVerticalSplitv+0x88>)
 80a214c:	d1e0      	bne.n	80a2110 <_Z17loopVerticalSplitv+0x8>
    }

    // allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
 80a214e:	4c12      	ldr	r4, [pc, #72]	; (80a2198 <_Z17loopVerticalSplitv+0x90>)
 80a2150:	2500      	movs	r5, #0
            leds[XY(i, j)] = fg_color;
        }
    }
    for (i = 0; i < kMatrixHeight; i++) {
        for (j = round(kMatrixWidth/2); j < kMatrixWidth; j++) {
            leds[XY(i, j)] = bg_color;
 80a2152:	b2ef      	uxtb	r7, r5
 80a2154:	2102      	movs	r1, #2
 80a2156:	4638      	mov	r0, r7
 80a2158:	f000 f95a 	bl	80a2410 <_Z2XYhh>
 80a215c:	7822      	ldrb	r2, [r4, #0]
 80a215e:	eb00 0040 	add.w	r0, r0, r0, lsl #1
 80a2162:	5432      	strb	r2, [r6, r0]
        g = rhs.g;
 80a2164:	7862      	ldrb	r2, [r4, #1]
    }

    // allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
 80a2166:	1833      	adds	r3, r6, r0
        g = rhs.g;
 80a2168:	705a      	strb	r2, [r3, #1]
        b = rhs.b;
 80a216a:	78a2      	ldrb	r2, [r4, #2]
 80a216c:	2103      	movs	r1, #3
 80a216e:	709a      	strb	r2, [r3, #2]
 80a2170:	4638      	mov	r0, r7
 80a2172:	f000 f94d 	bl	80a2410 <_Z2XYhh>
    }

    // allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
 80a2176:	7822      	ldrb	r2, [r4, #0]
 80a2178:	eb00 0040 	add.w	r0, r0, r0, lsl #1
 80a217c:	5432      	strb	r2, [r6, r0]
        g = rhs.g;
 80a217e:	7862      	ldrb	r2, [r4, #1]
    }

    // allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
 80a2180:	1833      	adds	r3, r6, r0
        g = rhs.g;
 80a2182:	705a      	strb	r2, [r3, #1]
 80a2184:	3501      	adds	r5, #1
        b = rhs.b;
 80a2186:	78a2      	ldrb	r2, [r4, #2]
    for (i = 0; i < kMatrixHeight; i++) {
        for (j = 0; j < round(kMatrixWidth/2); j++) {
            leds[XY(i, j)] = fg_color;
        }
    }
    for (i = 0; i < kMatrixHeight; i++) {
 80a2188:	2d1b      	cmp	r5, #27
 80a218a:	709a      	strb	r2, [r3, #2]
 80a218c:	d1e1      	bne.n	80a2152 <_Z17loopVerticalSplitv+0x4a>
        for (j = round(kMatrixWidth/2); j < kMatrixWidth; j++) {
            leds[XY(i, j)] = bg_color;
        }
    }
}
 80a218e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80a2190:	200003b4 	.word	0x200003b4
 80a2194:	20000590 	.word	0x20000590
 80a2198:	200004f8 	.word	0x200004f8

080a219c <_Z18setupVerticalSplitv>:
 80a219c:	f7ff bfb4 	b.w	80a2108 <_Z17loopVerticalSplitv>

080a21a0 <_GLOBAL__sub_I__Z18setupVerticalSplitv>:
 80a21a0:	f001 bbde 	b.w	80a3960 <HAL_Pin_Map>

080a21a4 <_Z25loopHorizontalDoubleSplitv>:
        }
    }
}

void loopHorizontalDoubleSplit()
{
 80a21a4:	e92d 43f8 	stmdb	sp!, {r3, r4, r5, r6, r7, r8, r9, lr}
    }

    // allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
 80a21a8:	f8df 90a8 	ldr.w	r9, [pc, #168]	; 80a2254 <_Z25loopHorizontalDoubleSplitv+0xb0>
 80a21ac:	f8df 80a8 	ldr.w	r8, [pc, #168]	; 80a2258 <_Z25loopHorizontalDoubleSplitv+0xb4>
    uint16_t i = 0;
    uint16_t j = 0;

    for (i = 0; i < round(kMatrixHeight/3); i++) {
 80a21b0:	2400      	movs	r4, #0
 80a21b2:	2600      	movs	r6, #0
        for (j = 0; j < kMatrixWidth; j++) {
            leds[XY(i, j)] = fg_color;
 80a21b4:	b2f1      	uxtb	r1, r6
 80a21b6:	b2e0      	uxtb	r0, r4
 80a21b8:	f000 f92a 	bl	80a2410 <_Z2XYhh>
 80a21bc:	f898 2000 	ldrb.w	r2, [r8]
 80a21c0:	eb00 0040 	add.w	r0, r0, r0, lsl #1
 80a21c4:	f809 2000 	strb.w	r2, [r9, r0]
        g = rhs.g;
 80a21c8:	f898 2001 	ldrb.w	r2, [r8, #1]
    }

    // allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
 80a21cc:	eb09 0300 	add.w	r3, r9, r0
        g = rhs.g;
 80a21d0:	705a      	strb	r2, [r3, #1]
 80a21d2:	3601      	adds	r6, #1
        b = rhs.b;
 80a21d4:	f898 2002 	ldrb.w	r2, [r8, #2]
{
    uint16_t i = 0;
    uint16_t j = 0;

    for (i = 0; i < round(kMatrixHeight/3); i++) {
        for (j = 0; j < kMatrixWidth; j++) {
 80a21d8:	2e04      	cmp	r6, #4
 80a21da:	709a      	strb	r2, [r3, #2]
 80a21dc:	4d1d      	ldr	r5, [pc, #116]	; (80a2254 <_Z25loopHorizontalDoubleSplitv+0xb0>)
 80a21de:	4f1e      	ldr	r7, [pc, #120]	; (80a2258 <_Z25loopHorizontalDoubleSplitv+0xb4>)
 80a21e0:	d1e8      	bne.n	80a21b4 <_Z25loopHorizontalDoubleSplitv+0x10>
void loopHorizontalDoubleSplit()
{
    uint16_t i = 0;
    uint16_t j = 0;

    for (i = 0; i < round(kMatrixHeight/3); i++) {
 80a21e2:	3401      	adds	r4, #1
 80a21e4:	b2a4      	uxth	r4, r4
 80a21e6:	2c09      	cmp	r4, #9
 80a21e8:	d1e3      	bne.n	80a21b2 <_Z25loopHorizontalDoubleSplitv+0xe>
    }

    // allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
 80a21ea:	f8df 8070 	ldr.w	r8, [pc, #112]	; 80a225c <_Z25loopHorizontalDoubleSplitv+0xb8>
 80a21ee:	2600      	movs	r6, #0
            leds[XY(i, j)] = fg_color;
        }
    }
    for (i = round(kMatrixHeight/3); i < round(2*kMatrixHeight/3); i++) {
        for (j = 0; j < kMatrixWidth; j++) {
            leds[XY(i, j)] = bg_color;
 80a21f0:	fa5f f984 	uxtb.w	r9, r4
 80a21f4:	b2f1      	uxtb	r1, r6
 80a21f6:	4648      	mov	r0, r9
 80a21f8:	f000 f90a 	bl	80a2410 <_Z2XYhh>
 80a21fc:	f898 2000 	ldrb.w	r2, [r8]
 80a2200:	eb00 0040 	add.w	r0, r0, r0, lsl #1
 80a2204:	542a      	strb	r2, [r5, r0]
        g = rhs.g;
 80a2206:	f898 2001 	ldrb.w	r2, [r8, #1]
    }

    // allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
 80a220a:	182b      	adds	r3, r5, r0
        g = rhs.g;
 80a220c:	705a      	strb	r2, [r3, #1]
 80a220e:	3601      	adds	r6, #1
        b = rhs.b;
 80a2210:	f898 2002 	ldrb.w	r2, [r8, #2]
        for (j = 0; j < kMatrixWidth; j++) {
            leds[XY(i, j)] = fg_color;
        }
    }
    for (i = round(kMatrixHeight/3); i < round(2*kMatrixHeight/3); i++) {
        for (j = 0; j < kMatrixWidth; j++) {
 80a2214:	2e04      	cmp	r6, #4
 80a2216:	709a      	strb	r2, [r3, #2]
 80a2218:	d1ec      	bne.n	80a21f4 <_Z25loopHorizontalDoubleSplitv+0x50>
    for (i = 0; i < round(kMatrixHeight/3); i++) {
        for (j = 0; j < kMatrixWidth; j++) {
            leds[XY(i, j)] = fg_color;
        }
    }
    for (i = round(kMatrixHeight/3); i < round(2*kMatrixHeight/3); i++) {
 80a221a:	3401      	adds	r4, #1
 80a221c:	b2a4      	uxth	r4, r4
 80a221e:	2c12      	cmp	r4, #18
 80a2220:	d1e5      	bne.n	80a21ee <_Z25loopHorizontalDoubleSplitv+0x4a>
void loopHorizontalDoubleSplit()
{
    uint16_t i = 0;
    uint16_t j = 0;

    for (i = 0; i < round(kMatrixHeight/3); i++) {
 80a2222:	2600      	movs	r6, #0
            leds[XY(i, j)] = bg_color;
        }
    }
    for (i = round(2*kMatrixHeight/3); i < kMatrixHeight; i++) {
        for (j = 0; j < kMatrixWidth; j++) {
            leds[XY(i, j)] = fg_color;
 80a2224:	fa5f f884 	uxtb.w	r8, r4
 80a2228:	b2f1      	uxtb	r1, r6
 80a222a:	4640      	mov	r0, r8
 80a222c:	f000 f8f0 	bl	80a2410 <_Z2XYhh>
    }

    // allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
 80a2230:	783a      	ldrb	r2, [r7, #0]
 80a2232:	eb00 0040 	add.w	r0, r0, r0, lsl #1
 80a2236:	542a      	strb	r2, [r5, r0]
        g = rhs.g;
 80a2238:	787a      	ldrb	r2, [r7, #1]
    }

    // allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
 80a223a:	182b      	adds	r3, r5, r0
        g = rhs.g;
 80a223c:	705a      	strb	r2, [r3, #1]
 80a223e:	3601      	adds	r6, #1
        b = rhs.b;
 80a2240:	78ba      	ldrb	r2, [r7, #2]
        for (j = 0; j < kMatrixWidth; j++) {
            leds[XY(i, j)] = bg_color;
        }
    }
    for (i = round(2*kMatrixHeight/3); i < kMatrixHeight; i++) {
        for (j = 0; j < kMatrixWidth; j++) {
 80a2242:	2e04      	cmp	r6, #4
 80a2244:	709a      	strb	r2, [r3, #2]
 80a2246:	d1ef      	bne.n	80a2228 <_Z25loopHorizontalDoubleSplitv+0x84>
    for (i = round(kMatrixHeight/3); i < round(2*kMatrixHeight/3); i++) {
        for (j = 0; j < kMatrixWidth; j++) {
            leds[XY(i, j)] = bg_color;
        }
    }
    for (i = round(2*kMatrixHeight/3); i < kMatrixHeight; i++) {
 80a2248:	3401      	adds	r4, #1
 80a224a:	b2a4      	uxth	r4, r4
 80a224c:	2c1b      	cmp	r4, #27
 80a224e:	d1e8      	bne.n	80a2222 <_Z25loopHorizontalDoubleSplitv+0x7e>
        for (j = 0; j < kMatrixWidth; j++) {
            leds[XY(i, j)] = fg_color;
        }
    }
}
 80a2250:	e8bd 83f8 	ldmia.w	sp!, {r3, r4, r5, r6, r7, r8, r9, pc}
 80a2254:	200003b4 	.word	0x200003b4
 80a2258:	20000590 	.word	0x20000590
 80a225c:	200004f8 	.word	0x200004f8

080a2260 <_Z26setupHorizontalDoubleSplitv>:
 80a2260:	f7ff bfa0 	b.w	80a21a4 <_Z25loopHorizontalDoubleSplitv>

080a2264 <_GLOBAL__sub_I__Z26setupHorizontalDoubleSplitv>:
 80a2264:	f001 bb7c 	b.w	80a3960 <HAL_Pin_Map>

080a2268 <_Z13setupRainSnowv>:
extern CRGB fg_color;
extern CRGB bg_color;

uint16_t count = 0;

void setupRainSnow() {
 80a2268:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}

    uint16_t i = 0;
    uint16_t j = 0;

    randomSeed(analogRead(A0));
 80a226c:	200a      	movs	r0, #10
 80a226e:	f002 ff74 	bl	80a515a <analogRead>

    for (i = 0; i < kMatrixHeight; i++) {
 80a2272:	2400      	movs	r4, #0
void setupRainSnow() {

    uint16_t i = 0;
    uint16_t j = 0;

    randomSeed(analogRead(A0));
 80a2274:	f001 fc7f 	bl	80a3b76 <_Z10randomSeedj>
    }

    // allow assignment from 32-bit (really 24-bit) 0xRRGGBB color code
	inline CRGB& operator= (const uint32_t colorcode) __attribute__((always_inline))
    {
        r = (colorcode >> 16) & 0xFF;
 80a2278:	4626      	mov	r6, r4
 80a227a:	4f0d      	ldr	r7, [pc, #52]	; (80a22b0 <_Z13setupRainSnowv+0x48>)

    for (i = 0; i < kMatrixHeight; i++) {
 80a227c:	2500      	movs	r5, #0
        for (j = 0; j < kMatrixWidth; j++) {
            leds[XY(i, j)] = 0;
 80a227e:	fa5f f884 	uxtb.w	r8, r4
 80a2282:	b2e9      	uxtb	r1, r5
 80a2284:	4640      	mov	r0, r8
 80a2286:	f000 f8c3 	bl	80a2410 <_Z2XYhh>
 80a228a:	3501      	adds	r5, #1
 80a228c:	eb00 0040 	add.w	r0, r0, r0, lsl #1
 80a2290:	183b      	adds	r3, r7, r0
    uint16_t j = 0;

    randomSeed(analogRead(A0));

    for (i = 0; i < kMatrixHeight; i++) {
        for (j = 0; j < kMatrixWidth; j++) {
 80a2292:	2d04      	cmp	r5, #4
 80a2294:	543e      	strb	r6, [r7, r0]
        g = (colorcode >>  8) & 0xFF;
 80a2296:	705e      	strb	r6, [r3, #1]
        b = (colorcode >>  0) & 0xFF;
 80a2298:	709e      	strb	r6, [r3, #2]
 80a229a:	d1f2      	bne.n	80a2282 <_Z13setupRainSnowv+0x1a>
    uint16_t i = 0;
    uint16_t j = 0;

    randomSeed(analogRead(A0));

    for (i = 0; i < kMatrixHeight; i++) {
 80a229c:	3401      	adds	r4, #1
 80a229e:	b2a4      	uxth	r4, r4
 80a22a0:	2c1b      	cmp	r4, #27
 80a22a2:	d1eb      	bne.n	80a227c <_Z13setupRainSnowv+0x14>
 80a22a4:	4803      	ldr	r0, [pc, #12]	; (80a22b4 <_Z13setupRainSnowv+0x4c>)
        for (j = 0; j < kMatrixWidth; j++) {
            leds[XY(i, j)] = 0;
        }
    }
    LEDS.show();
}
 80a22a6:	e8bd 41f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, lr}
 80a22aa:	7801      	ldrb	r1, [r0, #0]
 80a22ac:	f000 bd1e 	b.w	80a2cec <_ZN9NSFastLED8CFastLED4showEh>
 80a22b0:	200003b4 	.word	0x200003b4
 80a22b4:	200008ec 	.word	0x200008ec

080a22b8 <_Z12loopRainSnowv>:

void loopRainSnow() {
 80a22b8:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}

    uint16_t i = 0;
    uint16_t j = 0;
    uint16_t rand = 0;

    for (i = 0; i < kMatrixHeight; i++) {
 80a22bc:	2500      	movs	r5, #0
 80a22be:	462f      	mov	r7, r5
 80a22c0:	4c50      	ldr	r4, [pc, #320]	; (80a2404 <_Z12loopRainSnowv+0x14c>)
                        leds[XY(i, j)] = CRGB::White;
                    } else {
                        leds[XY(i, j)] = CRGB::Black;
                    }
                } else {
                    if (count > 5) {
 80a22c2:	f8df 8144 	ldr.w	r8, [pc, #324]	; 80a2408 <_Z12loopRainSnowv+0x150>
                                break;
                        }
                    }
                }
            } else {
                leds[XY(i, j)] = leds[XY(i + 1, j)];
 80a22c6:	fa5f fb85 	uxtb.w	fp, r5
 80a22ca:	f10b 0a01 	add.w	sl, fp, #1

    uint16_t i = 0;
    uint16_t j = 0;
    uint16_t rand = 0;

    for (i = 0; i < kMatrixHeight; i++) {
 80a22ce:	f04f 0900 	mov.w	r9, #0
                                break;
                        }
                    }
                }
            } else {
                leds[XY(i, j)] = leds[XY(i + 1, j)];
 80a22d2:	fa5f fa8a 	uxtb.w	sl, sl
 80a22d6:	fa5f f689 	uxtb.w	r6, r9
    uint16_t j = 0;
    uint16_t rand = 0;

    for (i = 0; i < kMatrixHeight; i++) {
        for (j = 0; j < kMatrixWidth; j++) {
            if (i == kMatrixHeight - 1) {
 80a22da:	2d1a      	cmp	r5, #26
                if (leds[XY(i, j)] == CRGB(CRGB::Black)) {
 80a22dc:	4631      	mov	r1, r6
    uint16_t j = 0;
    uint16_t rand = 0;

    for (i = 0; i < kMatrixHeight; i++) {
        for (j = 0; j < kMatrixWidth; j++) {
            if (i == kMatrixHeight - 1) {
 80a22de:	d10d      	bne.n	80a22fc <_Z12loopRainSnowv+0x44>
                if (leds[XY(i, j)] == CRGB(CRGB::Black)) {
 80a22e0:	4628      	mov	r0, r5
 80a22e2:	f000 f895 	bl	80a2410 <_Z2XYhh>
};


inline __attribute__((always_inline)) bool operator== (const CRGB& lhs, const CRGB& rhs)
{
    return (lhs.r == rhs.r) && (lhs.g == rhs.g) && (lhs.b == rhs.b);
 80a22e6:	eb00 0040 	add.w	r0, r0, r0, lsl #1
 80a22ea:	5c22      	ldrb	r2, [r4, r0]
 80a22ec:	1823      	adds	r3, r4, r0
 80a22ee:	bb5a      	cbnz	r2, 80a2348 <_Z12loopRainSnowv+0x90>
 80a22f0:	785a      	ldrb	r2, [r3, #1]
 80a22f2:	bb4a      	cbnz	r2, 80a2348 <_Z12loopRainSnowv+0x90>
 80a22f4:	789b      	ldrb	r3, [r3, #2]
 80a22f6:	2b00      	cmp	r3, #0
 80a22f8:	d064      	beq.n	80a23c4 <_Z12loopRainSnowv+0x10c>
 80a22fa:	e025      	b.n	80a2348 <_Z12loopRainSnowv+0x90>
                                break;
                        }
                    }
                }
            } else {
                leds[XY(i, j)] = leds[XY(i + 1, j)];
 80a22fc:	4658      	mov	r0, fp
 80a22fe:	f000 f887 	bl	80a2410 <_Z2XYhh>
 80a2302:	4631      	mov	r1, r6
 80a2304:	9001      	str	r0, [sp, #4]
 80a2306:	4650      	mov	r0, sl
 80a2308:	f000 f882 	bl	80a2410 <_Z2XYhh>
    }

    // allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
 80a230c:	9b01      	ldr	r3, [sp, #4]
 80a230e:	eb00 0040 	add.w	r0, r0, r0, lsl #1
 80a2312:	1821      	adds	r1, r4, r0
 80a2314:	5c20      	ldrb	r0, [r4, r0]
 80a2316:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 80a231a:	54e0      	strb	r0, [r4, r3]
 80a231c:	18e2      	adds	r2, r4, r3
        g = rhs.g;
 80a231e:	784b      	ldrb	r3, [r1, #1]
 80a2320:	7053      	strb	r3, [r2, #1]
        b = rhs.b;
 80a2322:	788b      	ldrb	r3, [r1, #2]
 80a2324:	7093      	strb	r3, [r2, #2]
    uint16_t i = 0;
    uint16_t j = 0;
    uint16_t rand = 0;

    for (i = 0; i < kMatrixHeight; i++) {
        for (j = 0; j < kMatrixWidth; j++) {
 80a2326:	f109 0901 	add.w	r9, r9, #1
 80a232a:	fa1f f989 	uxth.w	r9, r9
 80a232e:	f1b9 0f04 	cmp.w	r9, #4
 80a2332:	d1d0      	bne.n	80a22d6 <_Z12loopRainSnowv+0x1e>

    uint16_t i = 0;
    uint16_t j = 0;
    uint16_t rand = 0;

    for (i = 0; i < kMatrixHeight; i++) {
 80a2334:	3501      	adds	r5, #1
 80a2336:	b2ad      	uxth	r5, r5
 80a2338:	2d1b      	cmp	r5, #27
 80a233a:	d1c4      	bne.n	80a22c6 <_Z12loopRainSnowv+0xe>
            } else {
                leds[XY(i, j)] = leds[XY(i + 1, j)];
            }
        }
    }
    delay(50);
 80a233c:	2032      	movs	r0, #50	; 0x32
}
 80a233e:	b003      	add	sp, #12
 80a2340:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
            } else {
                leds[XY(i, j)] = leds[XY(i + 1, j)];
            }
        }
    }
    delay(50);
 80a2344:	f002 b820 	b.w	80a4388 <delay>
                        leds[XY(i, j)] = CRGB::White;
                    } else {
                        leds[XY(i, j)] = CRGB::Black;
                    }
                } else {
                    if (count > 5) {
 80a2348:	f8b8 3000 	ldrh.w	r3, [r8]
 80a234c:	2b05      	cmp	r3, #5
 80a234e:	d90c      	bls.n	80a236a <_Z12loopRainSnowv+0xb2>
                        leds[XY(i, j)] = CRGB::Black;
 80a2350:	4631      	mov	r1, r6
 80a2352:	201a      	movs	r0, #26
 80a2354:	f000 f85c 	bl	80a2410 <_Z2XYhh>
    }

    // allow assignment from 32-bit (really 24-bit) 0xRRGGBB color code
	inline CRGB& operator= (const uint32_t colorcode) __attribute__((always_inline))
    {
        r = (colorcode >> 16) & 0xFF;
 80a2358:	eb00 0040 	add.w	r0, r0, r0, lsl #1
 80a235c:	1823      	adds	r3, r4, r0
 80a235e:	5427      	strb	r7, [r4, r0]
                        count = 0;
 80a2360:	f8a8 7000 	strh.w	r7, [r8]
        g = (colorcode >>  8) & 0xFF;
 80a2364:	705f      	strb	r7, [r3, #1]
        b = (colorcode >>  0) & 0xFF;
 80a2366:	709f      	strb	r7, [r3, #2]
 80a2368:	e7dd      	b.n	80a2326 <_Z12loopRainSnowv+0x6e>
                    } else {
                        switch (count) {
 80a236a:	3b03      	subs	r3, #3
 80a236c:	2b01      	cmp	r3, #1
                            case 3:
                                leds[XY(i, j)] = leds[XY(i, j)] / 2;
                                count++;
                                break;
                            default:
                                leds[XY(i, j)] = CRGB::White;
 80a236e:	4631      	mov	r1, r6
 80a2370:	f04f 001a 	mov.w	r0, #26
                } else {
                    if (count > 5) {
                        leds[XY(i, j)] = CRGB::Black;
                        count = 0;
                    } else {
                        switch (count) {
 80a2374:	d817      	bhi.n	80a23a6 <_Z12loopRainSnowv+0xee>
                            case 4:
                            case 3:
                                leds[XY(i, j)] = leds[XY(i, j)] / 2;
 80a2376:	f000 f84b 	bl	80a2410 <_Z2XYhh>
 80a237a:	4631      	mov	r1, r6
 80a237c:	9001      	str	r0, [sp, #4]
 80a237e:	201a      	movs	r0, #26
 80a2380:	f000 f846 	bl	80a2410 <_Z2XYhh>
}

__attribute__((always_inline))
inline CRGB operator/( const CRGB& p1, uint8_t d)
{
    return CRGB( p1.r/d, p1.g/d, p1.b/d);
 80a2384:	eb00 0040 	add.w	r0, r0, r0, lsl #1
 80a2388:	1822      	adds	r2, r4, r0
    }

    // allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
 80a238a:	9b01      	ldr	r3, [sp, #4]
}

__attribute__((always_inline))
inline CRGB operator/( const CRGB& p1, uint8_t d)
{
    return CRGB( p1.r/d, p1.g/d, p1.b/d);
 80a238c:	7851      	ldrb	r1, [r2, #1]
    }

    // allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
 80a238e:	5c20      	ldrb	r0, [r4, r0]
}

__attribute__((always_inline))
inline CRGB operator/( const CRGB& p1, uint8_t d)
{
    return CRGB( p1.r/d, p1.g/d, p1.b/d);
 80a2390:	7892      	ldrb	r2, [r2, #2]
    }

    // allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
 80a2392:	eb03 0343 	add.w	r3, r3, r3, lsl #1
 80a2396:	18e6      	adds	r6, r4, r3
}

__attribute__((always_inline))
inline CRGB operator/( const CRGB& p1, uint8_t d)
{
    return CRGB( p1.r/d, p1.g/d, p1.b/d);
 80a2398:	0849      	lsrs	r1, r1, #1
 80a239a:	0852      	lsrs	r2, r2, #1
    }

    // allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
 80a239c:	0840      	lsrs	r0, r0, #1
 80a239e:	54e0      	strb	r0, [r4, r3]
        g = rhs.g;
 80a23a0:	7071      	strb	r1, [r6, #1]
        b = rhs.b;
 80a23a2:	70b2      	strb	r2, [r6, #2]
 80a23a4:	e008      	b.n	80a23b8 <_Z12loopRainSnowv+0x100>
                                count++;
                                break;
                            default:
                                leds[XY(i, j)] = CRGB::White;
 80a23a6:	f000 f833 	bl	80a2410 <_Z2XYhh>
    }

    // allow assignment from 32-bit (really 24-bit) 0xRRGGBB color code
	inline CRGB& operator= (const uint32_t colorcode) __attribute__((always_inline))
    {
        r = (colorcode >> 16) & 0xFF;
 80a23aa:	eb00 0040 	add.w	r0, r0, r0, lsl #1
 80a23ae:	23ff      	movs	r3, #255	; 0xff
 80a23b0:	1822      	adds	r2, r4, r0
 80a23b2:	5423      	strb	r3, [r4, r0]
        g = (colorcode >>  8) & 0xFF;
 80a23b4:	7053      	strb	r3, [r2, #1]
        b = (colorcode >>  0) & 0xFF;
 80a23b6:	7093      	strb	r3, [r2, #2]
                                count++;
 80a23b8:	f8b8 3000 	ldrh.w	r3, [r8]
 80a23bc:	3301      	adds	r3, #1
 80a23be:	f8a8 3000 	strh.w	r3, [r8]
                                break;
 80a23c2:	e7b0      	b.n	80a2326 <_Z12loopRainSnowv+0x6e>

    for (i = 0; i < kMatrixHeight; i++) {
        for (j = 0; j < kMatrixWidth; j++) {
            if (i == kMatrixHeight - 1) {
                if (leds[XY(i, j)] == CRGB(CRGB::Black)) {
                    rand = random(100);
 80a23c4:	2064      	movs	r0, #100	; 0x64
 80a23c6:	f001 fbc1 	bl	80a3b4c <_Z6randomi>
                    if ((rand > 94) && (count == 0)) {
 80a23ca:	b280      	uxth	r0, r0
 80a23cc:	285e      	cmp	r0, #94	; 0x5e
 80a23ce:	d90d      	bls.n	80a23ec <_Z12loopRainSnowv+0x134>
 80a23d0:	f8b8 3000 	ldrh.w	r3, [r8]
 80a23d4:	b953      	cbnz	r3, 80a23ec <_Z12loopRainSnowv+0x134>
                        leds[XY(i, j)] = CRGB::White;
 80a23d6:	4631      	mov	r1, r6
 80a23d8:	4628      	mov	r0, r5
 80a23da:	f000 f819 	bl	80a2410 <_Z2XYhh>
    }

    // allow assignment from 32-bit (really 24-bit) 0xRRGGBB color code
	inline CRGB& operator= (const uint32_t colorcode) __attribute__((always_inline))
    {
        r = (colorcode >> 16) & 0xFF;
 80a23de:	eb00 0040 	add.w	r0, r0, r0, lsl #1
 80a23e2:	23ff      	movs	r3, #255	; 0xff
 80a23e4:	1822      	adds	r2, r4, r0
 80a23e6:	5423      	strb	r3, [r4, r0]
        g = (colorcode >>  8) & 0xFF;
 80a23e8:	7053      	strb	r3, [r2, #1]
 80a23ea:	e79b      	b.n	80a2324 <_Z12loopRainSnowv+0x6c>
                    } else {
                        leds[XY(i, j)] = CRGB::Black;
 80a23ec:	4631      	mov	r1, r6
 80a23ee:	201a      	movs	r0, #26
 80a23f0:	f000 f80e 	bl	80a2410 <_Z2XYhh>
    }

    // allow assignment from 32-bit (really 24-bit) 0xRRGGBB color code
	inline CRGB& operator= (const uint32_t colorcode) __attribute__((always_inline))
    {
        r = (colorcode >> 16) & 0xFF;
 80a23f4:	eb00 0040 	add.w	r0, r0, r0, lsl #1
 80a23f8:	1823      	adds	r3, r4, r0
 80a23fa:	5427      	strb	r7, [r4, r0]
        g = (colorcode >>  8) & 0xFF;
 80a23fc:	705f      	strb	r7, [r3, #1]
        b = (colorcode >>  0) & 0xFF;
 80a23fe:	709f      	strb	r7, [r3, #2]
 80a2400:	e791      	b.n	80a2326 <_Z12loopRainSnowv+0x6e>
 80a2402:	bf00      	nop
 80a2404:	200003b4 	.word	0x200003b4
 80a2408:	20000604 	.word	0x20000604

080a240c <_GLOBAL__sub_I_count>:
 80a240c:	f001 baa8 	b.w	80a3960 <HAL_Pin_Map>

080a2410 <_Z2XYhh>:
static uint16_t x;
static uint16_t y;
static uint16_t z;

uint16_t XY(uint8_t x, uint8_t y)
{
 80a2410:	281a      	cmp	r0, #26
 80a2412:	b573      	push	{r0, r1, r4, r5, r6, lr}
 80a2414:	bf28      	it	cs
 80a2416:	201a      	movcs	r0, #26
 80a2418:	2903      	cmp	r1, #3
 80a241a:	bf28      	it	cs
 80a241c:	2103      	movcs	r1, #3
    if (x >= kMatrixHeight) { x = kMatrixHeight - 1; }
    if (x < 0) { x = 0; }
    if (y >= kMatrixWidth) { y = kMatrixWidth - 1; }
    if (y < 0) { y = 0; }

    if (y % 2 == 0) {
 80a241e:	07cb      	lsls	r3, r1, #31
        retcode = (y * kMatrixHeight) + x;
    } else {
        retcode = (y + 1) * kMatrixHeight - x -1;
 80a2420:	bf48      	it	mi
 80a2422:	43c3      	mvnmi	r3, r0
 80a2424:	460e      	mov	r6, r1
 80a2426:	4605      	mov	r5, r0
 80a2428:	bf4b      	itete	mi
 80a242a:	1c4c      	addmi	r4, r1, #1
    if (x < 0) { x = 0; }
    if (y >= kMatrixWidth) { y = kMatrixWidth - 1; }
    if (y < 0) { y = 0; }

    if (y % 2 == 0) {
        retcode = (y * kMatrixHeight) + x;
 80a242c:	eb01 0441 	addpl.w	r4, r1, r1, lsl #1
    } else {
        retcode = (y + 1) * kMatrixHeight - x -1;
 80a2430:	eb04 0444 	addmi.w	r4, r4, r4, lsl #1
    if (x < 0) { x = 0; }
    if (y >= kMatrixWidth) { y = kMatrixWidth - 1; }
    if (y < 0) { y = 0; }

    if (y % 2 == 0) {
        retcode = (y * kMatrixHeight) + x;
 80a2434:	eb04 04c4 	addpl.w	r4, r4, r4, lsl #3
    } else {
        retcode = (y + 1) * kMatrixHeight - x -1;
 80a2438:	bf46      	itte	mi
 80a243a:	eb04 04c4 	addmi.w	r4, r4, r4, lsl #3
 80a243e:	18e4      	addmi	r4, r4, r3
    if (x < 0) { x = 0; }
    if (y >= kMatrixWidth) { y = kMatrixWidth - 1; }
    if (y < 0) { y = 0; }

    if (y % 2 == 0) {
        retcode = (y * kMatrixHeight) + x;
 80a2440:	1824      	addpl	r4, r4, r0
    } else {
        retcode = (y + 1) * kMatrixHeight - x -1;
 80a2442:	b2a4      	uxth	r4, r4
    }
#ifdef DEBUG
    Serial.printf("XY: %d, X: %d, Y: %d", retcode, x, y);
 80a2444:	f001 fc46 	bl	80a3cd4 <_Z16_fetch_usbserialv>
    size_t println(const __FlashStringHelper*);

    template <typename... Args>
    inline size_t printf(const char* format, Args... args)
    {
        return this->printf_impl(false, format, args...);
 80a2448:	4623      	mov	r3, r4
 80a244a:	4a06      	ldr	r2, [pc, #24]	; (80a2464 <_Z2XYhh+0x54>)
 80a244c:	2100      	movs	r1, #0
 80a244e:	e88d 0060 	stmia.w	sp, {r5, r6}
 80a2452:	f002 f8dc 	bl	80a460e <_ZN5Print11printf_implEbPKcz>
    Serial.println();
 80a2456:	f001 fc3d 	bl	80a3cd4 <_Z16_fetch_usbserialv>
 80a245a:	f002 f8a0 	bl	80a459e <_ZN5Print7printlnEv>
#endif
    return retcode;
}
 80a245e:	4620      	mov	r0, r4
 80a2460:	b002      	add	sp, #8
 80a2462:	bd70      	pop	{r4, r5, r6, pc}
 80a2464:	080a6686 	.word	0x080a6686

080a2468 <_Z10fillnoise8v>:
{
    // If we're runing at a low "speed", some 8-bit artifacts become visible
    // from frame-to-frame.  In order to reduce this, we can do some fast data-smoothing.
    // The amount of data smoothing we're doing depends on "speed".
    uint8_t dataSmoothing = 0;
    if (speed < 50) {
 80a2468:	4b2e      	ldr	r3, [pc, #184]	; (80a2524 <_Z10fillnoise8v+0xbc>)
    return retcode;
}

// Fill the x/y array of 8-bit noise values using the inoise8 function.
void fillnoise8()
{
 80a246a:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80a246e:	469a      	mov	sl, r3
    // If we're runing at a low "speed", some 8-bit artifacts become visible
    // from frame-to-frame.  In order to reduce this, we can do some fast data-smoothing.
    // The amount of data smoothing we're doing depends on "speed".
    uint8_t dataSmoothing = 0;
    if (speed < 50) {
 80a2470:	881c      	ldrh	r4, [r3, #0]
 80a2472:	f8df 80c4 	ldr.w	r8, [pc, #196]	; 80a2538 <_Z10fillnoise8v+0xd0>
 80a2476:	2c31      	cmp	r4, #49	; 0x31
        dataSmoothing = 200 - (speed * 4);
 80a2478:	bf9d      	ittte	ls
 80a247a:	f1c4 0432 	rsbls	r4, r4, #50	; 0x32
 80a247e:	00a4      	lslls	r4, r4, #2
 80a2480:	b2e4      	uxtbls	r4, r4
void fillnoise8()
{
    // If we're runing at a low "speed", some 8-bit artifacts become visible
    // from frame-to-frame.  In order to reduce this, we can do some fast data-smoothing.
    // The amount of data smoothing we're doing depends on "speed".
    uint8_t dataSmoothing = 0;
 80a2482:	2400      	movhi	r4, #0
    if (speed < 50) {
        dataSmoothing = 200 - (speed * 4);
    }

    for (int i = 0; i < MAX_DIMENSION; i++) {
 80a2484:	2700      	movs	r7, #0
        int ioffset = scale * i;
 80a2486:	4b28      	ldr	r3, [pc, #160]	; (80a2528 <_Z10fillnoise8v+0xc0>)
        for (int j = 0; j < MAX_DIMENSION; j++) {
 80a2488:	2500      	movs	r5, #0
    if (speed < 50) {
        dataSmoothing = 200 - (speed * 4);
    }

    for (int i = 0; i < MAX_DIMENSION; i++) {
        int ioffset = scale * i;
 80a248a:	f8b3 9000 	ldrh.w	r9, [r3]
 80a248e:	469b      	mov	fp, r3
 80a2490:	fb07 f909 	mul.w	r9, r7, r9
        for (int j = 0; j < MAX_DIMENSION; j++) {
            int joffset = scale * j;

            uint8_t data = inoise8(x + ioffset, y + joffset, z);
 80a2494:	4b25      	ldr	r3, [pc, #148]	; (80a252c <_Z10fillnoise8v+0xc4>)
 80a2496:	f8bb 2000 	ldrh.w	r2, [fp]
 80a249a:	8819      	ldrh	r1, [r3, #0]
 80a249c:	4e24      	ldr	r6, [pc, #144]	; (80a2530 <_Z10fillnoise8v+0xc8>)
 80a249e:	fb05 1102 	mla	r1, r5, r2, r1
 80a24a2:	8830      	ldrh	r0, [r6, #0]
 80a24a4:	9301      	str	r3, [sp, #4]
 80a24a6:	4b23      	ldr	r3, [pc, #140]	; (80a2534 <_Z10fillnoise8v+0xcc>)
 80a24a8:	4448      	add	r0, r9
 80a24aa:	881a      	ldrh	r2, [r3, #0]
 80a24ac:	b289      	uxth	r1, r1
 80a24ae:	b280      	uxth	r0, r0
 80a24b0:	f000 fbc2 	bl	80a2c38 <_ZN9NSFastLED7inoise8Ettt>

// qsub8: subtract one byte from another, saturating at 0x00
LIB8STATIC uint8_t qsub8( uint8_t i, uint8_t j)
{
#if QSUB8_C == 1
    int t = i - j;
 80a24b4:	3810      	subs	r0, #16
 80a24b6:	ea20 70e0 	bic.w	r0, r0, r0, asr #31

// qadd8: add one byte to another, saturating at 0xFF
LIB8STATIC uint8_t qadd8( uint8_t i, uint8_t j)
{
#if QADD8_C == 1
    unsigned int t = i + j;
 80a24ba:	2227      	movs	r2, #39	; 0x27
 80a24bc:	4342      	muls	r2, r0
 80a24be:	eb00 2222 	add.w	r2, r0, r2, asr #8
 80a24c2:	2aff      	cmp	r2, #255	; 0xff
 80a24c4:	481b      	ldr	r0, [pc, #108]	; (80a2534 <_Z10fillnoise8v+0xcc>)
 80a24c6:	4919      	ldr	r1, [pc, #100]	; (80a252c <_Z10fillnoise8v+0xc4>)
 80a24c8:	bfa8      	it	ge
 80a24ca:	22ff      	movge	r2, #255	; 0xff
            // These two operations expand those values out to roughly 0..255
            // You can comment them out if you want the raw noise data.
            data = qsub8(data, 16);
            data = qadd8(data, scale8(data, 39));

            if (dataSmoothing) {
 80a24cc:	9b01      	ldr	r3, [sp, #4]
 80a24ce:	b16c      	cbz	r4, 80a24ec <_Z10fillnoise8v+0x84>
                uint8_t olddata = noise[i][j];
                uint8_t newdata = scale8(olddata, dataSmoothing) + scale8(data, 256 - dataSmoothing);
 80a24d0:	f1c4 0e00 	rsb	lr, r4, #0
 80a24d4:	fa5f fe8e 	uxtb.w	lr, lr
 80a24d8:	fb02 f20e 	mul.w	r2, r2, lr
 80a24dc:	f818 e005 	ldrb.w	lr, [r8, r5]
 80a24e0:	fb04 fe0e 	mul.w	lr, r4, lr
 80a24e4:	ea4f 2e2e 	mov.w	lr, lr, asr #8
 80a24e8:	eb0e 2222 	add.w	r2, lr, r2, asr #8
 80a24ec:	b2d2      	uxtb	r2, r2
                data = newdata;
            }

            noise[i][j] = data;
 80a24ee:	f808 2005 	strb.w	r2, [r8, r5]
        dataSmoothing = 200 - (speed * 4);
    }

    for (int i = 0; i < MAX_DIMENSION; i++) {
        int ioffset = scale * i;
        for (int j = 0; j < MAX_DIMENSION; j++) {
 80a24f2:	3501      	adds	r5, #1
 80a24f4:	2d1b      	cmp	r5, #27
 80a24f6:	d1ce      	bne.n	80a2496 <_Z10fillnoise8v+0x2e>
    uint8_t dataSmoothing = 0;
    if (speed < 50) {
        dataSmoothing = 200 - (speed * 4);
    }

    for (int i = 0; i < MAX_DIMENSION; i++) {
 80a24f8:	3701      	adds	r7, #1
 80a24fa:	2f1b      	cmp	r7, #27
 80a24fc:	f108 081b 	add.w	r8, r8, #27
 80a2500:	d1c1      	bne.n	80a2486 <_Z10fillnoise8v+0x1e>

            noise[i][j] = data;
        }
    }

    z += speed;
 80a2502:	f8ba 2000 	ldrh.w	r2, [sl]
 80a2506:	8803      	ldrh	r3, [r0, #0]
 80a2508:	4413      	add	r3, r2
 80a250a:	8003      	strh	r3, [r0, #0]

    // apply slow drift to X and Y, just for visual variation.
    x += speed / 8;
 80a250c:	8833      	ldrh	r3, [r6, #0]
 80a250e:	eb03 03d2 	add.w	r3, r3, r2, lsr #3
 80a2512:	8033      	strh	r3, [r6, #0]
    y -= speed / 16;
 80a2514:	880b      	ldrh	r3, [r1, #0]
 80a2516:	eba3 1312 	sub.w	r3, r3, r2, lsr #4
 80a251a:	800b      	strh	r3, [r1, #0]
}
 80a251c:	b003      	add	sp, #12
 80a251e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80a2522:	bf00      	nop
 80a2524:	2000030e 	.word	0x2000030e
 80a2528:	2000030c 	.word	0x2000030c
 80a252c:	20000608 	.word	0x20000608
 80a2530:	20000606 	.word	0x20000606
 80a2534:	2000060a 	.word	0x2000060a
 80a2538:	20000610 	.word	0x20000610

080a253c <_Z11getDistancev>:

uint16_t getDistance()
{
 80a253c:	b570      	push	{r4, r5, r6, lr}
    uint32_t duration, cm;

    if (!init) {
 80a253e:	4d18      	ldr	r5, [pc, #96]	; (80a25a0 <_Z11getDistancev+0x64>)
 80a2540:	4c18      	ldr	r4, [pc, #96]	; (80a25a4 <_Z11getDistancev+0x68>)
 80a2542:	782e      	ldrb	r6, [r5, #0]
 80a2544:	b986      	cbnz	r6, 80a2568 <_Z11getDistancev+0x2c>
        pinMode(TRIGGER_PIN, OUTPUT);
 80a2546:	2101      	movs	r1, #1
 80a2548:	2002      	movs	r0, #2
 80a254a:	f002 fdf5 	bl	80a5138 <pinMode>
    PIN_MAP[_pin].gpio_peripheral->BSRRL = PIN_MAP[_pin].gpio_pin;
}

inline void pinResetFast(pin_t _pin)
{
    PIN_MAP[_pin].gpio_peripheral->BSRRH = PIN_MAP[_pin].gpio_pin;
 80a254e:	6823      	ldr	r3, [r4, #0]
        digitalWriteFast(TRIGGER_PIN, LOW);
        pinMode(ECHO_PIN, INPUT);
 80a2550:	4631      	mov	r1, r6
 80a2552:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 80a2554:	8f9b      	ldrh	r3, [r3, #60]	; 0x3c
 80a2556:	2003      	movs	r0, #3
 80a2558:	8353      	strh	r3, [r2, #26]
 80a255a:	f002 fded 	bl	80a5138 <pinMode>
        delay(50);
 80a255e:	2032      	movs	r0, #50	; 0x32
 80a2560:	f001 ff12 	bl	80a4388 <delay>
        init = true;
 80a2564:	2301      	movs	r3, #1
 80a2566:	702b      	strb	r3, [r5, #0]

class AtomicSection {
	int prev;
public:
	AtomicSection() {
		prev = HAL_disable_irq();
 80a2568:	f001 f9da 	bl	80a3920 <HAL_disable_irq>
inline void pinResetFast(pin_t _pin) __attribute__((always_inline));
inline int32_t pinReadFast(pin_t _pin) __attribute__((always_inline));

inline void pinSetFast(pin_t _pin)
{
    PIN_MAP[_pin].gpio_peripheral->BSRRL = PIN_MAP[_pin].gpio_pin;
 80a256c:	6823      	ldr	r3, [r4, #0]
 80a256e:	4605      	mov	r5, r0
 80a2570:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 80a2572:	8f9b      	ldrh	r3, [r3, #60]	; 0x3c
inline unsigned long micros(void) { return HAL_Timer_Get_Micro_Seconds(); }
void delay(unsigned long ms);
inline void delayMicroseconds(unsigned int us) { HAL_Delay_Microseconds(us); }
 80a2574:	200a      	movs	r0, #10
 80a2576:	8313      	strh	r3, [r2, #24]
 80a2578:	f001 f9a2 	bl	80a38c0 <HAL_Delay_Microseconds>
}

inline void pinResetFast(pin_t _pin)
{
    PIN_MAP[_pin].gpio_peripheral->BSRRH = PIN_MAP[_pin].gpio_pin;
 80a257c:	6823      	ldr	r3, [r4, #0]
    ATOMIC_BLOCK() {
        /* Trigger the sensor by sending a HIGH pulse of 10 or more microseconds */
        digitalWriteFast(TRIGGER_PIN, HIGH);
        delayMicroseconds(10);
        digitalWriteFast(TRIGGER_PIN, LOW);
        duration = pulseIn(ECHO_PIN, HIGH);
 80a257e:	2101      	movs	r1, #1
 80a2580:	6b9a      	ldr	r2, [r3, #56]	; 0x38
 80a2582:	8f9b      	ldrh	r3, [r3, #60]	; 0x3c
 80a2584:	2003      	movs	r0, #3
 80a2586:	8353      	strh	r3, [r2, #26]
 80a2588:	f002 fdfe 	bl	80a5188 <pulseIn>
 80a258c:	4604      	mov	r4, r0
	}

	~AtomicSection() {
		HAL_enable_irq(prev);
 80a258e:	4628      	mov	r0, r5
 80a2590:	f001 f9ce 	bl	80a3930 <HAL_enable_irq>
    /* Convert the time into a distance */
    // Sound travels at 340 m/s (29 us/cm), out and back so divide by 2
    // Ref: http://www.parallax.com/dl/docs/prod/acc/28015-PING-v1.3.pdf
    cm = duration / 29 / 2;

    return cm;
 80a2594:	203a      	movs	r0, #58	; 0x3a
 80a2596:	fbb4 f0f0 	udiv	r0, r4, r0
}
 80a259a:	b280      	uxth	r0, r0
 80a259c:	bd70      	pop	{r4, r5, r6, pc}
 80a259e:	bf00      	nop
 80a25a0:	200008e9 	.word	0x200008e9
 80a25a4:	2000060c 	.word	0x2000060c

080a25a8 <_GLOBAL__sub_I_noise>:
 80a25a8:	b508      	push	{r3, lr}
inline int32_t pinReadFast(pin_t _pin)
{
	return ((PIN_MAP[_pin].gpio_peripheral->IDR & PIN_MAP[_pin].gpio_pin) == 0 ? LOW : HIGH);
}
#elif defined(STM32F2XX)
static STM32_Pin_Info* PIN_MAP = HAL_Pin_Map();
 80a25aa:	f001 f9d9 	bl	80a3960 <HAL_Pin_Map>
 80a25ae:	4b01      	ldr	r3, [pc, #4]	; (80a25b4 <_GLOBAL__sub_I_noise+0xc>)
 80a25b0:	6018      	str	r0, [r3, #0]
 80a25b2:	bd08      	pop	{r3, pc}
 80a25b4:	2000060c 	.word	0x2000060c

080a25b8 <_GLOBAL__sub_I__ZN9NSFastLED13CloudColors_pE>:
 80a25b8:	f001 b9d2 	b.w	80a3960 <HAL_Pin_Map>

080a25bc <_ZN9NSFastLEDL15nscale8x3_videoERhS0_S0_h>:
#endif
}


LIB8STATIC void nscale8x3_video( uint8_t& r, uint8_t& g, uint8_t& b, fract8 scale)
{
 80a25bc:	b530      	push	{r4, r5, lr}
#if SCALE8_C == 1
    uint8_t nonzeroscale = (scale != 0) ? 1 : 0;
    r = (r == 0) ? 0 : (((int)r * (int)(scale) ) >> 8) + nonzeroscale;
 80a25be:	7804      	ldrb	r4, [r0, #0]


LIB8STATIC void nscale8x3_video( uint8_t& r, uint8_t& g, uint8_t& b, fract8 scale)
{
#if SCALE8_C == 1
    uint8_t nonzeroscale = (scale != 0) ? 1 : 0;
 80a25c0:	1c1d      	adds	r5, r3, #0
 80a25c2:	bf18      	it	ne
 80a25c4:	2501      	movne	r5, #1
    r = (r == 0) ? 0 : (((int)r * (int)(scale) ) >> 8) + nonzeroscale;
 80a25c6:	b11c      	cbz	r4, 80a25d0 <_ZN9NSFastLEDL15nscale8x3_videoERhS0_S0_h+0x14>
 80a25c8:	435c      	muls	r4, r3
 80a25ca:	eb05 2424 	add.w	r4, r5, r4, asr #8
 80a25ce:	b2e4      	uxtb	r4, r4
 80a25d0:	7004      	strb	r4, [r0, #0]
    g = (g == 0) ? 0 : (((int)g * (int)(scale) ) >> 8) + nonzeroscale;
 80a25d2:	7808      	ldrb	r0, [r1, #0]
 80a25d4:	b118      	cbz	r0, 80a25de <_ZN9NSFastLEDL15nscale8x3_videoERhS0_S0_h+0x22>
 80a25d6:	4358      	muls	r0, r3
 80a25d8:	eb05 2020 	add.w	r0, r5, r0, asr #8
 80a25dc:	b2c0      	uxtb	r0, r0
 80a25de:	7008      	strb	r0, [r1, #0]
    b = (b == 0) ? 0 : (((int)b * (int)(scale) ) >> 8) + nonzeroscale;
 80a25e0:	7811      	ldrb	r1, [r2, #0]
 80a25e2:	b119      	cbz	r1, 80a25ec <_ZN9NSFastLEDL15nscale8x3_videoERhS0_S0_h+0x30>
 80a25e4:	434b      	muls	r3, r1
 80a25e6:	eb05 2323 	add.w	r3, r5, r3, asr #8
 80a25ea:	b2d9      	uxtb	r1, r3
 80a25ec:	7011      	strb	r1, [r2, #0]
 80a25ee:	bd30      	pop	{r4, r5, pc}

080a25f0 <_ZN9NSFastLED15hsv2rgb_rainbowERKNS_4CHSVERNS_4CRGBE>:
#define K255 255
#define K171 171
#define K85  85

void hsv2rgb_rainbow( const CHSV& hsv, CRGB& rgb)
{
 80a25f0:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 80a25f2:	460d      	mov	r5, r1
    // Gscale: what to scale green down by.
    // Depends GREATLY on your particular LEDs
    const uint8_t Gscale = 0;


    uint8_t hue = hsv.hue;
 80a25f4:	7803      	ldrb	r3, [r0, #0]
    uint8_t sat = hsv.sat;
 80a25f6:	7846      	ldrb	r6, [r0, #1]
    uint8_t val = hsv.val;
 80a25f8:	7884      	ldrb	r4, [r0, #2]
//         In other words, it computes i * (scale / 256)
//         4 clocks AVR with MUL, 2 clocks ARM
LIB8STATIC uint8_t scale8( uint8_t i, fract8 scale)
{
#if SCALE8_C == 1
    return ((uint16_t)i * (uint16_t)(scale) ) >> 8;
 80a25fa:	00d8      	lsls	r0, r3, #3
 80a25fc:	b2c0      	uxtb	r0, r0
 80a25fe:	2255      	movs	r2, #85	; 0x55
 80a2600:	4342      	muls	r2, r0
 80a2602:	f003 0140 	and.w	r1, r3, #64	; 0x40

    uint8_t third = scale8( offset8, (256 / 3));

    uint8_t r, g, b;

    if( ! (hue & 0x80) ) {
 80a2606:	f013 0f80 	tst.w	r3, #128	; 0x80
 80a260a:	f3c2 2207 	ubfx	r2, r2, #8, #8
 80a260e:	f003 0320 	and.w	r3, r3, #32
        // 0XX
        if( ! (hue & 0x40) ) {
 80a2612:	f001 07ff 	and.w	r7, r1, #255	; 0xff

    uint8_t third = scale8( offset8, (256 / 3));

    uint8_t r, g, b;

    if( ! (hue & 0x80) ) {
 80a2616:	d128      	bne.n	80a266a <_ZN9NSFastLED15hsv2rgb_rainbowERKNS_4CHSVERNS_4CRGBE+0x7a>
        // 0XX
        if( ! (hue & 0x40) ) {
 80a2618:	b979      	cbnz	r1, 80a263a <_ZN9NSFastLED15hsv2rgb_rainbowERKNS_4CHSVERNS_4CRGBE+0x4a>
            // 00X
            //section 0-1
            if( ! (hue & 0x20) ) {
 80a261a:	f003 01ff 	and.w	r1, r3, #255	; 0xff
 80a261e:	b93b      	cbnz	r3, 80a2630 <_ZN9NSFastLED15hsv2rgb_rainbowERKNS_4CHSVERNS_4CRGBE+0x40>
                // 000
                //case 0: // R -> O
                r = K255 - third;
 80a2620:	43d3      	mvns	r3, r2
                g = third;
 80a2622:	f88d 2006 	strb.w	r2, [sp, #6]
            // 00X
            //section 0-1
            if( ! (hue & 0x20) ) {
                // 000
                //case 0: // R -> O
                r = K255 - third;
 80a2626:	f88d 3005 	strb.w	r3, [sp, #5]
                g = third;
                b = 0;
 80a262a:	f88d 1007 	strb.w	r1, [sp, #7]
                FORCE_REFERENCE(b);
 80a262e:	e04c      	b.n	80a26ca <_ZN9NSFastLED15hsv2rgb_rainbowERKNS_4CHSVERNS_4CRGBE+0xda>
            } else {
                // 001
                //case 1: // O -> Y
                if( Y1 ) {
                    r = K171;
 80a2630:	23ab      	movs	r3, #171	; 0xab
 80a2632:	f88d 3005 	strb.w	r3, [sp, #5]
                    g = K85 + third ;
 80a2636:	3255      	adds	r2, #85	; 0x55
 80a2638:	e00b      	b.n	80a2652 <_ZN9NSFastLED15hsv2rgb_rainbowERKNS_4CHSVERNS_4CRGBE+0x62>
                }
            }
        } else {
            //01X
            // section 2-3
            if( !  (hue & 0x20) ) {
 80a263a:	f003 07ff 	and.w	r7, r3, #255	; 0xff
 80a263e:	b96b      	cbnz	r3, 80a265c <_ZN9NSFastLED15hsv2rgb_rainbowERKNS_4CHSVERNS_4CRGBE+0x6c>
                // 010
                //case 2: // Y -> G
                if( Y1 ) {
                    //uint8_t twothirds = (third << 1);
                    uint8_t twothirds = scale8( offset8, ((256 * 2) / 3));
                    r = K171 - twothirds;
 80a2640:	21aa      	movs	r1, #170	; 0xaa
 80a2642:	fb01 f300 	mul.w	r3, r1, r0
 80a2646:	121b      	asrs	r3, r3, #8
 80a2648:	f1c3 03ab 	rsb	r3, r3, #171	; 0xab
 80a264c:	f88d 3005 	strb.w	r3, [sp, #5]
                    g = K171 + third;
 80a2650:	3a55      	subs	r2, #85	; 0x55
 80a2652:	f88d 2006 	strb.w	r2, [sp, #6]
                    b = 0;
 80a2656:	f88d 7007 	strb.w	r7, [sp, #7]
                    FORCE_REFERENCE(b);
 80a265a:	e036      	b.n	80a26ca <_ZN9NSFastLED15hsv2rgb_rainbowERKNS_4CHSVERNS_4CRGBE+0xda>
                    FORCE_REFERENCE(b);
                }
            } else {
                // 011
                // case 3: // G -> A
                r = 0;
 80a265c:	2300      	movs	r3, #0
 80a265e:	f88d 3005 	strb.w	r3, [sp, #5]
                FORCE_REFERENCE(r);
                g = K255 - third;
 80a2662:	43d3      	mvns	r3, r2
 80a2664:	f88d 3006 	strb.w	r3, [sp, #6]
 80a2668:	e02d      	b.n	80a26c6 <_ZN9NSFastLED15hsv2rgb_rainbowERKNS_4CHSVERNS_4CRGBE+0xd6>
            }
        }
    } else {
        // section 4-7
        // 1XX
        if( ! (hue & 0x40) ) {
 80a266a:	b9b9      	cbnz	r1, 80a269c <_ZN9NSFastLED15hsv2rgb_rainbowERKNS_4CHSVERNS_4CRGBE+0xac>
            // 10X
            if( ! ( hue & 0x20) ) {
 80a266c:	f003 01ff 	and.w	r1, r3, #255	; 0xff
 80a2670:	b973      	cbnz	r3, 80a2690 <_ZN9NSFastLED15hsv2rgb_rainbowERKNS_4CHSVERNS_4CRGBE+0xa0>
                // 100
                //case 4: // A -> B
                r = 0;
 80a2672:	f88d 1005 	strb.w	r1, [sp, #5]
 80a2676:	22aa      	movs	r2, #170	; 0xaa
 80a2678:	fb02 f300 	mul.w	r3, r2, r0
 80a267c:	f3c3 2307 	ubfx	r3, r3, #8, #8
                FORCE_REFERENCE(r);
                //uint8_t twothirds = (third << 1);
                uint8_t twothirds = scale8( offset8, ((256 * 2) / 3));
                g = K171 - twothirds;
 80a2680:	f1c3 02ab 	rsb	r2, r3, #171	; 0xab
                b = K85  + twothirds;
 80a2684:	3355      	adds	r3, #85	; 0x55
                //case 4: // A -> B
                r = 0;
                FORCE_REFERENCE(r);
                //uint8_t twothirds = (third << 1);
                uint8_t twothirds = scale8( offset8, ((256 * 2) / 3));
                g = K171 - twothirds;
 80a2686:	f88d 2006 	strb.w	r2, [sp, #6]
                b = K85  + twothirds;
 80a268a:	f88d 3007 	strb.w	r3, [sp, #7]
 80a268e:	e01c      	b.n	80a26ca <_ZN9NSFastLED15hsv2rgb_rainbowERKNS_4CHSVERNS_4CRGBE+0xda>

            } else {
                // 101
                //case 5: // B -> P
                r = third;
 80a2690:	f88d 2005 	strb.w	r2, [sp, #5]
                g = 0;
 80a2694:	f88d 7006 	strb.w	r7, [sp, #6]
                FORCE_REFERENCE(g);
                b = K255 - third;
 80a2698:	43d2      	mvns	r2, r2
 80a269a:	e014      	b.n	80a26c6 <_ZN9NSFastLED15hsv2rgb_rainbowERKNS_4CHSVERNS_4CRGBE+0xd6>

            }
        } else {
            if( !  (hue & 0x20)  ) {
 80a269c:	f003 01ff 	and.w	r1, r3, #255	; 0xff
 80a26a0:	b943      	cbnz	r3, 80a26b4 <_ZN9NSFastLED15hsv2rgb_rainbowERKNS_4CHSVERNS_4CRGBE+0xc4>
                // 110
                //case 6: // P -- K
                r = K85 + third;
 80a26a2:	f102 0355 	add.w	r3, r2, #85	; 0x55
 80a26a6:	f88d 3005 	strb.w	r3, [sp, #5]
                g = 0;
 80a26aa:	f88d 1006 	strb.w	r1, [sp, #6]
                FORCE_REFERENCE(g);
                b = K171 - third;
 80a26ae:	f1c2 02ab 	rsb	r2, r2, #171	; 0xab
 80a26b2:	e008      	b.n	80a26c6 <_ZN9NSFastLED15hsv2rgb_rainbowERKNS_4CHSVERNS_4CRGBE+0xd6>

            } else {
                // 111
                //case 7: // K -> R
                r = K171 + third;
 80a26b4:	f1a2 0355 	sub.w	r3, r2, #85	; 0x55
 80a26b8:	f88d 3005 	strb.w	r3, [sp, #5]
                g = 0;
 80a26bc:	2300      	movs	r3, #0
 80a26be:	f88d 3006 	strb.w	r3, [sp, #6]
                FORCE_REFERENCE(g);
                b = K85 - third;
 80a26c2:	f1c2 0255 	rsb	r2, r2, #85	; 0x55
 80a26c6:	f88d 2007 	strb.w	r2, [sp, #7]
    if( G2 ) g = g >> 1;
    if( Gscale ) g = scale8_video_LEAVING_R1_DIRTY( g, Gscale);

    // Scale down colors if we're desaturated at all
    // and add the brightness_floor to r, g, and b.
    if( sat != 255 ) {
 80a26ca:	2eff      	cmp	r6, #255	; 0xff
 80a26cc:	d01c      	beq.n	80a2708 <_ZN9NSFastLED15hsv2rgb_rainbowERKNS_4CHSVERNS_4CRGBE+0x118>

        nscale8x3_video( r, g, b, sat);
 80a26ce:	4633      	mov	r3, r6
 80a26d0:	f10d 0207 	add.w	r2, sp, #7
 80a26d4:	f10d 0106 	add.w	r1, sp, #6
 80a26d8:	f10d 0005 	add.w	r0, sp, #5
 80a26dc:	f7ff ff6e 	bl	80a25bc <_ZN9NSFastLEDL15nscale8x3_videoERhS0_S0_h>
 80a26e0:	43f2      	mvns	r2, r6
 80a26e2:	b2d2      	uxtb	r2, r2
 80a26e4:	4352      	muls	r2, r2

        uint8_t desat = 255 - sat;
        desat = scale8( desat, desat);

        uint8_t brightness_floor = desat;
        r += brightness_floor;
 80a26e6:	f89d 3005 	ldrb.w	r3, [sp, #5]
 80a26ea:	f3c2 2207 	ubfx	r2, r2, #8, #8
 80a26ee:	4413      	add	r3, r2
 80a26f0:	f88d 3005 	strb.w	r3, [sp, #5]
        g += brightness_floor;
 80a26f4:	f89d 3006 	ldrb.w	r3, [sp, #6]
 80a26f8:	4413      	add	r3, r2
 80a26fa:	f88d 3006 	strb.w	r3, [sp, #6]
        b += brightness_floor;
 80a26fe:	f89d 3007 	ldrb.w	r3, [sp, #7]
 80a2702:	441a      	add	r2, r3
 80a2704:	f88d 2007 	strb.w	r2, [sp, #7]
    }

    // Now scale everything down if we're at value < 255.
    if( val != 255 ) {
 80a2708:	2cff      	cmp	r4, #255	; 0xff
 80a270a:	d00e      	beq.n	80a272a <_ZN9NSFastLED15hsv2rgb_rainbowERKNS_4CHSVERNS_4CRGBE+0x13a>

        val = scale8_video_LEAVING_R1_DIRTY( val, val);
        nscale8x3_video( r, g, b, val);
 80a270c:	fb04 f304 	mul.w	r3, r4, r4
 80a2710:	121b      	asrs	r3, r3, #8
 80a2712:	2c00      	cmp	r4, #0
 80a2714:	bf18      	it	ne
 80a2716:	3301      	addne	r3, #1
 80a2718:	f10d 0207 	add.w	r2, sp, #7
 80a271c:	b2db      	uxtb	r3, r3
 80a271e:	f10d 0106 	add.w	r1, sp, #6
 80a2722:	f10d 0005 	add.w	r0, sp, #5
 80a2726:	f7ff ff49 	bl	80a25bc <_ZN9NSFastLEDL15nscale8x3_videoERhS0_S0_h>
    // It turns out that fixing it winds up costing more than
    // not fixing it.
    // To paraphrase Dr Bronner, profile! profile! profile!
    //asm volatile(  ""  :  :  : "r26", "r27" );
    //asm volatile (" movw r30, r26 \n" : : : "r30", "r31");
    rgb.r = r;
 80a272a:	f89d 3005 	ldrb.w	r3, [sp, #5]
 80a272e:	702b      	strb	r3, [r5, #0]
    rgb.g = g;
 80a2730:	f89d 3006 	ldrb.w	r3, [sp, #6]
 80a2734:	706b      	strb	r3, [r5, #1]
    rgb.b = b;
 80a2736:	f89d 3007 	ldrb.w	r3, [sp, #7]
 80a273a:	70ab      	strb	r3, [r5, #2]
}
 80a273c:	b003      	add	sp, #12
 80a273e:	bdf0      	pop	{r4, r5, r6, r7, pc}

080a2740 <_GLOBAL__sub_I__ZN9NSFastLED11hsv2rgb_rawERKNS_4CHSVERNS_4CRGBE>:
 80a2740:	f001 b90e 	b.w	80a3960 <HAL_Pin_Map>

080a2744 <_ZN9NSFastLEDL15nscale8x3_videoERhS0_S0_h>:
#endif
}


LIB8STATIC void nscale8x3_video( uint8_t& r, uint8_t& g, uint8_t& b, fract8 scale)
{
 80a2744:	b530      	push	{r4, r5, lr}
#if SCALE8_C == 1
    uint8_t nonzeroscale = (scale != 0) ? 1 : 0;
    r = (r == 0) ? 0 : (((int)r * (int)(scale) ) >> 8) + nonzeroscale;
 80a2746:	7804      	ldrb	r4, [r0, #0]


LIB8STATIC void nscale8x3_video( uint8_t& r, uint8_t& g, uint8_t& b, fract8 scale)
{
#if SCALE8_C == 1
    uint8_t nonzeroscale = (scale != 0) ? 1 : 0;
 80a2748:	1c1d      	adds	r5, r3, #0
 80a274a:	bf18      	it	ne
 80a274c:	2501      	movne	r5, #1
    r = (r == 0) ? 0 : (((int)r * (int)(scale) ) >> 8) + nonzeroscale;
 80a274e:	b11c      	cbz	r4, 80a2758 <_ZN9NSFastLEDL15nscale8x3_videoERhS0_S0_h+0x14>
 80a2750:	435c      	muls	r4, r3
 80a2752:	eb05 2424 	add.w	r4, r5, r4, asr #8
 80a2756:	b2e4      	uxtb	r4, r4
 80a2758:	7004      	strb	r4, [r0, #0]
    g = (g == 0) ? 0 : (((int)g * (int)(scale) ) >> 8) + nonzeroscale;
 80a275a:	7808      	ldrb	r0, [r1, #0]
 80a275c:	b118      	cbz	r0, 80a2766 <_ZN9NSFastLEDL15nscale8x3_videoERhS0_S0_h+0x22>
 80a275e:	4358      	muls	r0, r3
 80a2760:	eb05 2020 	add.w	r0, r5, r0, asr #8
 80a2764:	b2c0      	uxtb	r0, r0
 80a2766:	7008      	strb	r0, [r1, #0]
    b = (b == 0) ? 0 : (((int)b * (int)(scale) ) >> 8) + nonzeroscale;
 80a2768:	7811      	ldrb	r1, [r2, #0]
 80a276a:	b119      	cbz	r1, 80a2774 <_ZN9NSFastLEDL15nscale8x3_videoERhS0_S0_h+0x30>
 80a276c:	434b      	muls	r3, r1
 80a276e:	eb05 2323 	add.w	r3, r5, r3, asr #8
 80a2772:	b2d9      	uxtb	r1, r3
 80a2774:	7011      	strb	r1, [r2, #0]
 80a2776:	bd30      	pop	{r4, r5, pc}

080a2778 <_ZN9NSFastLED10fill_solidEPNS_4CRGBEiRKS0_>:



void fill_solid( struct CRGB * leds, int numToFill,
                 const struct CRGB& color)
{
 80a2778:	b510      	push	{r4, lr}
    for( int i = 0; i < numToFill; i++) {
 80a277a:	2300      	movs	r3, #0
 80a277c:	428b      	cmp	r3, r1
 80a277e:	f100 0003 	add.w	r0, r0, #3
 80a2782:	da0a      	bge.n	80a279a <_ZN9NSFastLED10fill_solidEPNS_4CRGBEiRKS0_+0x22>
    }

    // allow assignment from one RGB struct to another
	inline CRGB& operator= (const CRGB& rhs) __attribute__((always_inline))
    {
        r = rhs.r;
 80a2784:	7814      	ldrb	r4, [r2, #0]
 80a2786:	3301      	adds	r3, #1
 80a2788:	f800 4c03 	strb.w	r4, [r0, #-3]
        g = rhs.g;
 80a278c:	7854      	ldrb	r4, [r2, #1]
 80a278e:	f800 4c02 	strb.w	r4, [r0, #-2]
        b = rhs.b;
 80a2792:	7894      	ldrb	r4, [r2, #2]
 80a2794:	f800 4c01 	strb.w	r4, [r0, #-1]
 80a2798:	e7f0      	b.n	80a277c <_ZN9NSFastLED10fill_solidEPNS_4CRGBEiRKS0_+0x4>
 80a279a:	bd10      	pop	{r4, pc}

080a279c <_ZN9NSFastLED16ColorFromPaletteERKNS_13CRGBPalette16EhhNS_10TBlendTypeE>:
}



CRGB ColorFromPalette( const CRGBPalette16& pal, uint8_t index, uint8_t brightness, TBlendType blendType)
{
 80a279c:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
    uint8_t hi4 = index >> 4;
 80a279e:	1117      	asrs	r7, r2, #4
}



CRGB ColorFromPalette( const CRGBPalette16& pal, uint8_t index, uint8_t brightness, TBlendType blendType)
{
 80a27a0:	4605      	mov	r5, r0
    uint8_t hi4 = index >> 4;
    uint8_t lo4 = index & 0x0F;

    //  CRGB rgb1 = pal[ hi4];
    const CRGB* entry = &(pal[0]) + hi4;
 80a27a2:	eb07 0047 	add.w	r0, r7, r7, lsl #1
 80a27a6:	180c      	adds	r4, r1, r0
    uint8_t red1   = entry->red;
    uint8_t green1 = entry->green;
 80a27a8:	7866      	ldrb	r6, [r4, #1]
    uint8_t hi4 = index >> 4;
    uint8_t lo4 = index & 0x0F;

    //  CRGB rgb1 = pal[ hi4];
    const CRGB* entry = &(pal[0]) + hi4;
    uint8_t red1   = entry->red;
 80a27aa:	5c08      	ldrb	r0, [r1, r0]
    uint8_t green1 = entry->green;
    uint8_t blue1  = entry->blue;
 80a27ac:	f894 e002 	ldrb.w	lr, [r4, #2]

    uint8_t blend = lo4 && (blendType != NOBLEND);
 80a27b0:	f012 020f 	ands.w	r2, r2, #15
    uint8_t hi4 = index >> 4;
    uint8_t lo4 = index & 0x0F;

    //  CRGB rgb1 = pal[ hi4];
    const CRGB* entry = &(pal[0]) + hi4;
    uint8_t red1   = entry->red;
 80a27b4:	f88d 0005 	strb.w	r0, [sp, #5]
    uint8_t green1 = entry->green;
 80a27b8:	f88d 6006 	strb.w	r6, [sp, #6]
    uint8_t blue1  = entry->blue;
 80a27bc:	f88d e007 	strb.w	lr, [sp, #7]

    uint8_t blend = lo4 && (blendType != NOBLEND);
 80a27c0:	d027      	beq.n	80a2812 <_ZN9NSFastLED16ColorFromPaletteERKNS_13CRGBPalette16EhhNS_10TBlendTypeE+0x76>
 80a27c2:	f89d c020 	ldrb.w	ip, [sp, #32]
 80a27c6:	f1bc 0f00 	cmp.w	ip, #0
 80a27ca:	d022      	beq.n	80a2812 <_ZN9NSFastLED16ColorFromPaletteERKNS_13CRGBPalette16EhhNS_10TBlendTypeE+0x76>

    if( blend ) {

        if( hi4 == 15 ) {
 80a27cc:	2f0f      	cmp	r7, #15
 80a27ce:	d000      	beq.n	80a27d2 <_ZN9NSFastLED16ColorFromPaletteERKNS_13CRGBPalette16EhhNS_10TBlendTypeE+0x36>
            entry = &(pal[0]);
        } else {
            entry++;
 80a27d0:	1ce1      	adds	r1, r4, #3
        }

        uint8_t f2 = lo4 << 4;
 80a27d2:	0112      	lsls	r2, r2, #4
// If you are doing several 'scale8's in a row, use this, and
// then explicitly call cleanup_R1.
LIB8STATIC uint8_t scale8_LEAVING_R1_DIRTY( uint8_t i, fract8 scale)
{
#if SCALE8_C == 1
    return ((int)i * (int)(scale) ) >> 8;
 80a27d4:	4254      	negs	r4, r2
 80a27d6:	f891 c001 	ldrb.w	ip, [r1, #1]
 80a27da:	788f      	ldrb	r7, [r1, #2]
 80a27dc:	b2e4      	uxtb	r4, r4
        blue2  = scale8_LEAVING_R1_DIRTY( blue2,  f2);

        cleanup_R1();

        // These sums can't overflow, so no qadd8 needed.
        red1   += red2;
 80a27de:	7809      	ldrb	r1, [r1, #0]
 80a27e0:	fb02 fc0c 	mul.w	ip, r2, ip
 80a27e4:	4357      	muls	r7, r2
 80a27e6:	4360      	muls	r0, r4
        green1 += green2;
 80a27e8:	4366      	muls	r6, r4
        blue2  = scale8_LEAVING_R1_DIRTY( blue2,  f2);

        cleanup_R1();

        // These sums can't overflow, so no qadd8 needed.
        red1   += red2;
 80a27ea:	434a      	muls	r2, r1
        green1 += green2;
        blue1  += blue2;
 80a27ec:	fb04 f40e 	mul.w	r4, r4, lr
 80a27f0:	f3cc 2c07 	ubfx	ip, ip, #8, #8
 80a27f4:	f3c7 2707 	ubfx	r7, r7, #8, #8
        blue2  = scale8_LEAVING_R1_DIRTY( blue2,  f2);

        cleanup_R1();

        // These sums can't overflow, so no qadd8 needed.
        red1   += red2;
 80a27f8:	1200      	asrs	r0, r0, #8
 80a27fa:	eb00 2222 	add.w	r2, r0, r2, asr #8
        green1 += green2;
 80a27fe:	eb0c 2626 	add.w	r6, ip, r6, asr #8
        blue1  += blue2;
 80a2802:	eb07 2424 	add.w	r4, r7, r4, asr #8
        blue2  = scale8_LEAVING_R1_DIRTY( blue2,  f2);

        cleanup_R1();

        // These sums can't overflow, so no qadd8 needed.
        red1   += red2;
 80a2806:	f88d 2005 	strb.w	r2, [sp, #5]
        green1 += green2;
 80a280a:	f88d 6006 	strb.w	r6, [sp, #6]
        blue1  += blue2;
 80a280e:	f88d 4007 	strb.w	r4, [sp, #7]

    }

    if( brightness != 255) {
 80a2812:	2bff      	cmp	r3, #255	; 0xff
 80a2814:	d007      	beq.n	80a2826 <_ZN9NSFastLED16ColorFromPaletteERKNS_13CRGBPalette16EhhNS_10TBlendTypeE+0x8a>
        nscale8x3_video( red1, green1, blue1, brightness);
 80a2816:	f10d 0207 	add.w	r2, sp, #7
 80a281a:	f10d 0106 	add.w	r1, sp, #6
 80a281e:	f10d 0005 	add.w	r0, sp, #5
 80a2822:	f7ff ff8f 	bl	80a2744 <_ZN9NSFastLEDL15nscale8x3_videoERhS0_S0_h>
    }

    return CRGB( red1, green1, blue1);
}
 80a2826:	4628      	mov	r0, r5

    if( brightness != 255) {
        nscale8x3_video( red1, green1, blue1, brightness);
    }

    return CRGB( red1, green1, blue1);
 80a2828:	f89d 2006 	ldrb.w	r2, [sp, #6]
 80a282c:	f89d 3007 	ldrb.w	r3, [sp, #7]
    {
    }

    // allow construction from R, G, B
    inline CRGB( uint8_t ir, uint8_t ig, uint8_t ib)  __attribute__((always_inline))
        : r(ir), g(ig), b(ib)
 80a2830:	f89d 1005 	ldrb.w	r1, [sp, #5]
 80a2834:	706a      	strb	r2, [r5, #1]
 80a2836:	7029      	strb	r1, [r5, #0]
 80a2838:	70ab      	strb	r3, [r5, #2]
}
 80a283a:	b003      	add	sp, #12
 80a283c:	bdf0      	pop	{r4, r5, r6, r7, pc}

080a283e <_GLOBAL__sub_I__ZN9NSFastLED10fill_solidEPNS_4CRGBEiRKS0_>:
 80a283e:	f001 b88f 	b.w	80a3960 <HAL_Pin_Map>
	...

080a2844 <_ZN9NSFastLED11inoise8_rawEttt>:
  uint8_t X = x>>8;
  uint8_t Y = y>>8;
  uint8_t Z = z>>8;

  // Hash cube corner coordinates
  uint8_t A = P(X)+Y;
 80a2844:	4b89      	ldr	r3, [pc, #548]	; (80a2a6c <_ZN9NSFastLED11inoise8_rawEttt+0x228>)
uint16_t inoise16(uint32_t x) {
  return ((uint32_t)((int32_t)inoise16_raw(x) + 17308L)) << 1;
}

int8_t inoise8_raw(uint16_t x, uint16_t y, uint16_t z)
{
 80a2846:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
  // Find the unit cube containing the point
  uint8_t X = x>>8;
 80a284a:	1206      	asrs	r6, r0, #8
  uint8_t Y = y>>8;
  uint8_t Z = z>>8;

  // Hash cube corner coordinates
  uint8_t A = P(X)+Y;
  uint8_t AA = P(A)+Z;
 80a284c:	5d9c      	ldrb	r4, [r3, r6]

int8_t inoise8_raw(uint16_t x, uint16_t y, uint16_t z)
{
  // Find the unit cube containing the point
  uint8_t X = x>>8;
  uint8_t Y = y>>8;
 80a284e:	ea4f 2e11 	mov.w	lr, r1, lsr #8
  uint8_t Z = z>>8;

  // Hash cube corner coordinates
  uint8_t A = P(X)+Y;
  uint8_t AA = P(A)+Z;
 80a2852:	4474      	add	r4, lr
 80a2854:	b2e4      	uxtb	r4, r4
  uint8_t AB = P(A+1)+Z;
 80a2856:	191d      	adds	r5, r3, r4
 80a2858:	786f      	ldrb	r7, [r5, #1]
int8_t inoise8_raw(uint16_t x, uint16_t y, uint16_t z)
{
  // Find the unit cube containing the point
  uint8_t X = x>>8;
  uint8_t Y = y>>8;
  uint8_t Z = z>>8;
 80a285a:	ea4f 2812 	mov.w	r8, r2, lsr #8

  // Hash cube corner coordinates
  uint8_t A = P(X)+Y;
  uint8_t AA = P(A)+Z;
  uint8_t AB = P(A+1)+Z;
 80a285e:	4447      	add	r7, r8
uint16_t inoise16(uint32_t x) {
  return ((uint32_t)((int32_t)inoise16_raw(x) + 17308L)) << 1;
}

int8_t inoise8_raw(uint16_t x, uint16_t y, uint16_t z)
{
 80a2860:	b087      	sub	sp, #28
  uint8_t Z = z>>8;

  // Hash cube corner coordinates
  uint8_t A = P(X)+Y;
  uint8_t AA = P(A)+Z;
  uint8_t AB = P(A+1)+Z;
 80a2862:	b2fd      	uxtb	r5, r7
  uint8_t B = P(X+1)+Y;
 80a2864:	441e      	add	r6, r3
  uint8_t BB = P(B+1)+Z;

  // Get the relative position of the point in the cube
  uint8_t u = x;
  uint8_t v = y;
  uint8_t w = z;
 80a2866:	b2d2      	uxtb	r2, r2
  uint8_t BA = P(B) + Z;
  uint8_t BB = P(B+1)+Z;

  // Get the relative position of the point in the cube
  uint8_t u = x;
  uint8_t v = y;
 80a2868:	fa5f f981 	uxtb.w	r9, r1
  uint8_t Z = z>>8;

  // Hash cube corner coordinates
  uint8_t A = P(X)+Y;
  uint8_t AA = P(A)+Z;
  uint8_t AB = P(A+1)+Z;
 80a286c:	9501      	str	r5, [sp, #4]
  uint8_t w = z;

  // Get a signed version of the above for the grad function
  int8_t xx = ((uint8_t)(x)>>1) & 0x7F;
  int8_t yy = ((uint8_t)(y)>>1) & 0x7F;
  int8_t zz = ((uint8_t)(z)>>1) & 0x7F;
 80a286e:	0851      	lsrs	r1, r2, #1
  // Hash cube corner coordinates
  uint8_t A = P(X)+Y;
  uint8_t AA = P(A)+Z;
  uint8_t AB = P(A+1)+Z;
  uint8_t B = P(X+1)+Y;
  uint8_t BA = P(B) + Z;
 80a2870:	7875      	ldrb	r5, [r6, #1]
//         In other words, it computes i * (scale / 256)
//         4 clocks AVR with MUL, 2 clocks ARM
LIB8STATIC uint8_t scale8( uint8_t i, fract8 scale)
{
#if SCALE8_C == 1
    return ((uint16_t)i * (uint16_t)(scale) ) >> 8;
 80a2872:	4352      	muls	r2, r2
 80a2874:	4475      	add	r5, lr
 80a2876:	b2ed      	uxtb	r5, r5
 80a2878:	5d5e      	ldrb	r6, [r3, r5]
 80a287a:	1212      	asrs	r2, r2, #8
  uint8_t BB = P(B+1)+Z;
 80a287c:	441d      	add	r5, r3
 80a287e:	786d      	ldrb	r5, [r5, #1]
 80a2880:	9204      	str	r2, [sp, #16]
  uint8_t N = 0x80;

  // u = FADE(u); v = FADE(v); w = FADE(w);
  u = scale8_LEAVING_R1_DIRTY(u,u); v = scale8_LEAVING_R1_DIRTY(v,v); w = scale8(w,w);

  int8_t X1 = lerp7by8(grad8(P(AA), xx, yy, zz), grad8(P(BA), xx - N, yy, zz), u);
 80a2882:	5d1a      	ldrb	r2, [r3, r4]
  // Hash cube corner coordinates
  uint8_t A = P(X)+Y;
  uint8_t AA = P(A)+Z;
  uint8_t AB = P(A+1)+Z;
  uint8_t B = P(X+1)+Y;
  uint8_t BA = P(B) + Z;
 80a2884:	4446      	add	r6, r8
  uint8_t BB = P(B+1)+Z;
 80a2886:	4445      	add	r5, r8
  uint8_t N = 0x80;

  // u = FADE(u); v = FADE(v); w = FADE(w);
  u = scale8_LEAVING_R1_DIRTY(u,u); v = scale8_LEAVING_R1_DIRTY(v,v); w = scale8(w,w);

  int8_t X1 = lerp7by8(grad8(P(AA), xx, yy, zz), grad8(P(BA), xx - N, yy, zz), u);
 80a2888:	4490      	add	r8, r2
  uint8_t A = P(X)+Y;
  uint8_t AA = P(A)+Z;
  uint8_t AB = P(A+1)+Z;
  uint8_t B = P(X+1)+Y;
  uint8_t BA = P(B) + Z;
  uint8_t BB = P(B+1)+Z;
 80a288a:	b2ed      	uxtb	r5, r5
  uint8_t N = 0x80;

  // u = FADE(u); v = FADE(v); w = FADE(w);
  u = scale8_LEAVING_R1_DIRTY(u,u); v = scale8_LEAVING_R1_DIRTY(v,v); w = scale8(w,w);

  int8_t X1 = lerp7by8(grad8(P(AA), xx, yy, zz), grad8(P(BA), xx - N, yy, zz), u);
 80a288c:	fa5f f888 	uxtb.w	r8, r8
  uint8_t B = P(X+1)+Y;
  uint8_t BA = P(B) + Z;
  uint8_t BB = P(B+1)+Z;

  // Get the relative position of the point in the cube
  uint8_t u = x;
 80a2890:	b2c0      	uxtb	r0, r0
  uint8_t w = z;

  // Get a signed version of the above for the grad function
  int8_t xx = ((uint8_t)(x)>>1) & 0x7F;
  int8_t yy = ((uint8_t)(y)>>1) & 0x7F;
  int8_t zz = ((uint8_t)(z)>>1) & 0x7F;
 80a2892:	9103      	str	r1, [sp, #12]
  uint8_t A = P(X)+Y;
  uint8_t AA = P(A)+Z;
  uint8_t AB = P(A+1)+Z;
  uint8_t B = P(X+1)+Y;
  uint8_t BA = P(B) + Z;
  uint8_t BB = P(B+1)+Z;
 80a2894:	9502      	str	r5, [sp, #8]
// If you are doing several 'scale8's in a row, use this, and
// then explicitly call cleanup_R1.
LIB8STATIC uint8_t scale8_LEAVING_R1_DIRTY( uint8_t i, fract8 scale)
{
#if SCALE8_C == 1
    return ((int)i * (int)(scale) ) >> 8;
 80a2896:	fb09 f109 	mul.w	r1, r9, r9
  uint8_t v = y;
  uint8_t w = z;

  // Get a signed version of the above for the grad function
  int8_t xx = ((uint8_t)(x)>>1) & 0x7F;
  int8_t yy = ((uint8_t)(y)>>1) & 0x7F;
 80a289a:	ea4f 0559 	mov.w	r5, r9, lsr #1
  uint8_t N = 0x80;

  // u = FADE(u); v = FADE(v); w = FADE(w);
  u = scale8_LEAVING_R1_DIRTY(u,u); v = scale8_LEAVING_R1_DIRTY(v,v); w = scale8(w,w);

  int8_t X1 = lerp7by8(grad8(P(AA), xx, yy, zz), grad8(P(BA), xx - N, yy, zz), u);
 80a289e:	f813 9008 	ldrb.w	r9, [r3, r8]
  uint8_t u = x;
  uint8_t v = y;
  uint8_t w = z;

  // Get a signed version of the above for the grad function
  int8_t xx = ((uint8_t)(x)>>1) & 0x7F;
 80a28a2:	ea4f 0e50 	mov.w	lr, r0, lsr #1
 80a28a6:	4340      	muls	r0, r0
    case 14: return (( y) + (-x))>>1;
    case 15: return ((-y) + (-z))>>1;
  }
#else

  hash &= 0xF;
 80a28a8:	f009 030f 	and.w	r3, r9, #15
// but with an AVR asm version that's smaller and quicker than C
// (and probably not worth including in lib8tion)
static int8_t inline __attribute__((always_inline)) selectBasedOnHashBit(uint8_t hash, uint8_t bitnumber, int8_t a, int8_t b) {
	int8_t result;
#if !defined(__AVR__)
	result = (hash & (1<<bitnumber)) ? a : b;
 80a28ac:	08da      	lsrs	r2, r3, #3
  // Hash cube corner coordinates
  uint8_t A = P(X)+Y;
  uint8_t AA = P(A)+Z;
  uint8_t AB = P(A+1)+Z;
  uint8_t B = P(X+1)+Y;
  uint8_t BA = P(B) + Z;
 80a28ae:	fa5f fb86 	uxtb.w	fp, r6
  uint8_t v = y;
  uint8_t w = z;

  // Get a signed version of the above for the grad function
  int8_t xx = ((uint8_t)(x)>>1) & 0x7F;
  int8_t yy = ((uint8_t)(y)>>1) & 0x7F;
 80a28b2:	b26f      	sxtb	r7, r5
  uint8_t u = x;
  uint8_t v = y;
  uint8_t w = z;

  // Get a signed version of the above for the grad function
  int8_t xx = ((uint8_t)(x)>>1) & 0x7F;
 80a28b4:	fa4f f68e 	sxtb.w	r6, lr
// but with an AVR asm version that's smaller and quicker than C
// (and probably not worth including in lib8tion)
static int8_t inline __attribute__((always_inline)) selectBasedOnHashBit(uint8_t hash, uint8_t bitnumber, int8_t a, int8_t b) {
	int8_t result;
#if !defined(__AVR__)
	result = (hash & (1<<bitnumber)) ? a : b;
 80a28b8:	bf14      	ite	ne
 80a28ba:	463a      	movne	r2, r7
 80a28bc:	4632      	moveq	r2, r6
  int8_t u, v;
  //u = (hash&8)?y:x;
  u = selectBasedOnHashBit( hash, 3, y, x);

#if 1
  v = hash<4?y:hash==12||hash==14?x:z;
 80a28be:	2b03      	cmp	r3, #3
  uint8_t w = z;

  // Get a signed version of the above for the grad function
  int8_t xx = ((uint8_t)(x)>>1) & 0x7F;
  int8_t yy = ((uint8_t)(y)>>1) & 0x7F;
  int8_t zz = ((uint8_t)(z)>>1) & 0x7F;
 80a28c0:	f99d c00c 	ldrsb.w	ip, [sp, #12]
 80a28c4:	ea4f 2020 	mov.w	r0, r0, asr #8
 80a28c8:	ea4f 2121 	mov.w	r1, r1, asr #8
  int8_t u, v;
  //u = (hash&8)?y:x;
  u = selectBasedOnHashBit( hash, 3, y, x);

#if 1
  v = hash<4?y:hash==12||hash==14?x:z;
 80a28cc:	d906      	bls.n	80a28dc <_ZN9NSFastLED11inoise8_rawEttt+0x98>
 80a28ce:	f009 030d 	and.w	r3, r9, #13
 80a28d2:	2b0c      	cmp	r3, #12
 80a28d4:	bf14      	ite	ne
 80a28d6:	4663      	movne	r3, ip
 80a28d8:	4633      	moveq	r3, r6
 80a28da:	e000      	b.n	80a28de <_ZN9NSFastLED11inoise8_rawEttt+0x9a>
 80a28dc:	463b      	mov	r3, r7
		  v = z; // 04 05 06 07   08 09 0A 0B   0D  0F
	  }
  }
#endif

  if(hash&1) { u = -u; }
 80a28de:	f019 0f01 	tst.w	r9, #1
 80a28e2:	bf1c      	itt	ne
 80a28e4:	4252      	negne	r2, r2
 80a28e6:	b252      	sxtbne	r2, r2
  if(hash&2) { v = -v; }
 80a28e8:	f019 0f02 	tst.w	r9, #2
 80a28ec:	bf1c      	itt	ne
 80a28ee:	425b      	negne	r3, r3
 80a28f0:	b25b      	sxtbne	r3, r3
//       If the first argument is even, result is rounded down.
//       If the first argument is odd, result is result up.
LIB8STATIC int8_t avg7( int8_t i, int8_t j)
{
#if AVG7_C == 1
    return ((i + j) >> 1) + (i & 0x1);
 80a28f2:	4413      	add	r3, r2
 80a28f4:	f002 0201 	and.w	r2, r2, #1
 80a28f8:	eb02 0363 	add.w	r3, r2, r3, asr #1
 80a28fc:	b2dc      	uxtb	r4, r3
  uint8_t N = 0x80;

  // u = FADE(u); v = FADE(v); w = FADE(w);
  u = scale8_LEAVING_R1_DIRTY(u,u); v = scale8_LEAVING_R1_DIRTY(v,v); w = scale8(w,w);

  int8_t X1 = lerp7by8(grad8(P(AA), xx, yy, zz), grad8(P(BA), xx - N, yy, zz), u);
 80a28fe:	4b5b      	ldr	r3, [pc, #364]	; (80a2a6c <_ZN9NSFastLED11inoise8_rawEttt+0x228>)
 80a2900:	f1ae 0e80 	sub.w	lr, lr, #128	; 0x80
 80a2904:	f813 900b 	ldrb.w	r9, [r3, fp]
 80a2908:	fa4f fe8e 	sxtb.w	lr, lr
    case 14: return (( y) + (-x))>>1;
    case 15: return ((-y) + (-z))>>1;
  }
#else

  hash &= 0xF;
 80a290c:	f009 030f 	and.w	r3, r9, #15
// but with an AVR asm version that's smaller and quicker than C
// (and probably not worth including in lib8tion)
static int8_t inline __attribute__((always_inline)) selectBasedOnHashBit(uint8_t hash, uint8_t bitnumber, int8_t a, int8_t b) {
	int8_t result;
#if !defined(__AVR__)
	result = (hash & (1<<bitnumber)) ? a : b;
 80a2910:	08da      	lsrs	r2, r3, #3
 80a2912:	bf14      	ite	ne
 80a2914:	463a      	movne	r2, r7
 80a2916:	4672      	moveq	r2, lr
  int8_t u, v;
  //u = (hash&8)?y:x;
  u = selectBasedOnHashBit( hash, 3, y, x);

#if 1
  v = hash<4?y:hash==12||hash==14?x:z;
 80a2918:	2b03      	cmp	r3, #3
 80a291a:	fa4f fa84 	sxtb.w	sl, r4
 80a291e:	d906      	bls.n	80a292e <_ZN9NSFastLED11inoise8_rawEttt+0xea>
 80a2920:	f009 030d 	and.w	r3, r9, #13
 80a2924:	2b0c      	cmp	r3, #12
 80a2926:	bf14      	ite	ne
 80a2928:	4663      	movne	r3, ip
 80a292a:	4673      	moveq	r3, lr
 80a292c:	e000      	b.n	80a2930 <_ZN9NSFastLED11inoise8_rawEttt+0xec>
 80a292e:	463b      	mov	r3, r7
		  v = z; // 04 05 06 07   08 09 0A 0B   0D  0F
	  }
  }
#endif

  if(hash&1) { u = -u; }
 80a2930:	f019 0f01 	tst.w	r9, #1
 80a2934:	bf1c      	itt	ne
 80a2936:	4252      	negne	r2, r2
 80a2938:	b252      	sxtbne	r2, r2
  if(hash&2) { v = -v; }
 80a293a:	f019 0f02 	tst.w	r9, #2
 80a293e:	bf1c      	itt	ne
 80a2940:	425b      	negne	r3, r3
 80a2942:	b25b      	sxtbne	r3, r3
 80a2944:	4413      	add	r3, r2
 80a2946:	f002 0201 	and.w	r2, r2, #1
 80a294a:	eb02 0363 	add.w	r3, r2, r3, asr #1
 80a294e:	b2db      	uxtb	r3, r3
    // int16_t prod = (uint16_t)delta * (uint16_t)frac;
    // int8_t scaled = prod >> 8;
    // int8_t result = a + scaled;
    // return result;
    int8_t result;
    if( b > a) {
 80a2950:	b25a      	sxtb	r2, r3
 80a2952:	4592      	cmp	sl, r2
        uint8_t delta = b - a;
        uint8_t scaled = scale8( delta, frac);
        result = a + scaled;
 80a2954:	bfb5      	itete	lt
 80a2956:	1b1b      	sublt	r3, r3, r4
    } else {
        uint8_t delta = a - b;
        uint8_t scaled = scale8( delta, frac);
        result = a - scaled;
 80a2958:	1ae3      	subge	r3, r4, r3
    // return result;
    int8_t result;
    if( b > a) {
        uint8_t delta = b - a;
        uint8_t scaled = scale8( delta, frac);
        result = a + scaled;
 80a295a:	b2db      	uxtblt	r3, r3
    } else {
        uint8_t delta = a - b;
        uint8_t scaled = scale8( delta, frac);
        result = a - scaled;
 80a295c:	b2db      	uxtbge	r3, r3
    // return result;
    int8_t result;
    if( b > a) {
        uint8_t delta = b - a;
        uint8_t scaled = scale8( delta, frac);
        result = a + scaled;
 80a295e:	bfb5      	itete	lt
 80a2960:	4343      	mullt	r3, r0
    } else {
        uint8_t delta = a - b;
        uint8_t scaled = scale8( delta, frac);
        result = a - scaled;
 80a2962:	4343      	mulge	r3, r0
    // return result;
    int8_t result;
    if( b > a) {
        uint8_t delta = b - a;
        uint8_t scaled = scale8( delta, frac);
        result = a + scaled;
 80a2964:	eb04 2323 	addlt.w	r3, r4, r3, asr #8
    } else {
        uint8_t delta = a - b;
        uint8_t scaled = scale8( delta, frac);
        result = a - scaled;
 80a2968:	eba4 2323 	subge.w	r3, r4, r3, asr #8

  // u = FADE(u); v = FADE(v); w = FADE(w);
  u = scale8_LEAVING_R1_DIRTY(u,u); v = scale8_LEAVING_R1_DIRTY(v,v); w = scale8(w,w);

  int8_t X1 = lerp7by8(grad8(P(AA), xx, yy, zz), grad8(P(BA), xx - N, yy, zz), u);
  int8_t X2 = lerp7by8(grad8(P(AB), xx, yy-N, zz), grad8(P(BB), xx - N, yy - N, zz), u);
 80a296c:	4a3f      	ldr	r2, [pc, #252]	; (80a2a6c <_ZN9NSFastLED11inoise8_rawEttt+0x228>)
 80a296e:	9c01      	ldr	r4, [sp, #4]
        uint8_t scaled = scale8( delta, frac);
        result = a + scaled;
    } else {
        uint8_t delta = a - b;
        uint8_t scaled = scale8( delta, frac);
        result = a - scaled;
 80a2970:	b25b      	sxtb	r3, r3

  // u = FADE(u); v = FADE(v); w = FADE(w);
  u = scale8_LEAVING_R1_DIRTY(u,u); v = scale8_LEAVING_R1_DIRTY(v,v); w = scale8(w,w);

  int8_t X1 = lerp7by8(grad8(P(AA), xx, yy, zz), grad8(P(BA), xx - N, yy, zz), u);
  int8_t X2 = lerp7by8(grad8(P(AB), xx, yy-N, zz), grad8(P(BB), xx - N, yy - N, zz), u);
 80a2972:	f812 9004 	ldrb.w	r9, [r2, r4]
 80a2976:	3d80      	subs	r5, #128	; 0x80
    case 14: return (( y) + (-x))>>1;
    case 15: return ((-y) + (-z))>>1;
  }
#else

  hash &= 0xF;
 80a2978:	f009 020f 	and.w	r2, r9, #15
        uint8_t scaled = scale8( delta, frac);
        result = a + scaled;
    } else {
        uint8_t delta = a - b;
        uint8_t scaled = scale8( delta, frac);
        result = a - scaled;
 80a297c:	9300      	str	r3, [sp, #0]

  // u = FADE(u); v = FADE(v); w = FADE(w);
  u = scale8_LEAVING_R1_DIRTY(u,u); v = scale8_LEAVING_R1_DIRTY(v,v); w = scale8(w,w);

  int8_t X1 = lerp7by8(grad8(P(AA), xx, yy, zz), grad8(P(BA), xx - N, yy, zz), u);
  int8_t X2 = lerp7by8(grad8(P(AB), xx, yy-N, zz), grad8(P(BB), xx - N, yy - N, zz), u);
 80a297e:	b26d      	sxtb	r5, r5
// but with an AVR asm version that's smaller and quicker than C
// (and probably not worth including in lib8tion)
static int8_t inline __attribute__((always_inline)) selectBasedOnHashBit(uint8_t hash, uint8_t bitnumber, int8_t a, int8_t b) {
	int8_t result;
#if !defined(__AVR__)
	result = (hash & (1<<bitnumber)) ? a : b;
 80a2980:	08d3      	lsrs	r3, r2, #3
 80a2982:	bf14      	ite	ne
 80a2984:	462c      	movne	r4, r5
 80a2986:	4634      	moveq	r4, r6
  int8_t u, v;
  //u = (hash&8)?y:x;
  u = selectBasedOnHashBit( hash, 3, y, x);

#if 1
  v = hash<4?y:hash==12||hash==14?x:z;
 80a2988:	2a03      	cmp	r2, #3
 80a298a:	d907      	bls.n	80a299c <_ZN9NSFastLED11inoise8_rawEttt+0x158>
 80a298c:	f009 0a0d 	and.w	sl, r9, #13
 80a2990:	f1ba 0f0c 	cmp.w	sl, #12
 80a2994:	bf14      	ite	ne
 80a2996:	46e2      	movne	sl, ip
 80a2998:	46b2      	moveq	sl, r6
 80a299a:	e000      	b.n	80a299e <_ZN9NSFastLED11inoise8_rawEttt+0x15a>
 80a299c:	46aa      	mov	sl, r5
		  v = z; // 04 05 06 07   08 09 0A 0B   0D  0F
	  }
  }
#endif

  if(hash&1) { u = -u; }
 80a299e:	f019 0f01 	tst.w	r9, #1
 80a29a2:	bf1c      	itt	ne
 80a29a4:	4264      	negne	r4, r4
 80a29a6:	b264      	sxtbne	r4, r4
  if(hash&2) { v = -v; }
 80a29a8:	f019 0f02 	tst.w	r9, #2
 80a29ac:	bf1c      	itt	ne
 80a29ae:	f1ca 0a00 	rsbne	sl, sl, #0
 80a29b2:	fa4f fa8a 	sxtbne.w	sl, sl
 80a29b6:	44a2      	add	sl, r4
 80a29b8:	f004 0401 	and.w	r4, r4, #1
 80a29bc:	eb04 0a6a 	add.w	sl, r4, sl, asr #1
 80a29c0:	fa5f f28a 	uxtb.w	r2, sl
 80a29c4:	b254      	sxtb	r4, r2

  // u = FADE(u); v = FADE(v); w = FADE(w);
  u = scale8_LEAVING_R1_DIRTY(u,u); v = scale8_LEAVING_R1_DIRTY(v,v); w = scale8(w,w);

  int8_t X1 = lerp7by8(grad8(P(AA), xx, yy, zz), grad8(P(BA), xx - N, yy, zz), u);
  int8_t X2 = lerp7by8(grad8(P(AB), xx, yy-N, zz), grad8(P(BB), xx - N, yy - N, zz), u);
 80a29c6:	9b02      	ldr	r3, [sp, #8]
 80a29c8:	9405      	str	r4, [sp, #20]
 80a29ca:	4c28      	ldr	r4, [pc, #160]	; (80a2a6c <_ZN9NSFastLED11inoise8_rawEttt+0x228>)
 80a29cc:	f814 9003 	ldrb.w	r9, [r4, r3]
    case 14: return (( y) + (-x))>>1;
    case 15: return ((-y) + (-z))>>1;
  }
#else

  hash &= 0xF;
 80a29d0:	f009 0a0f 	and.w	sl, r9, #15
// but with an AVR asm version that's smaller and quicker than C
// (and probably not worth including in lib8tion)
static int8_t inline __attribute__((always_inline)) selectBasedOnHashBit(uint8_t hash, uint8_t bitnumber, int8_t a, int8_t b) {
	int8_t result;
#if !defined(__AVR__)
	result = (hash & (1<<bitnumber)) ? a : b;
 80a29d4:	ea5f 03da 	movs.w	r3, sl, lsr #3
 80a29d8:	bf14      	ite	ne
 80a29da:	462c      	movne	r4, r5
 80a29dc:	4674      	moveq	r4, lr
  int8_t u, v;
  //u = (hash&8)?y:x;
  u = selectBasedOnHashBit( hash, 3, y, x);

#if 1
  v = hash<4?y:hash==12||hash==14?x:z;
 80a29de:	f1ba 0f03 	cmp.w	sl, #3
 80a29e2:	d906      	bls.n	80a29f2 <_ZN9NSFastLED11inoise8_rawEttt+0x1ae>
 80a29e4:	f009 0a0d 	and.w	sl, r9, #13
 80a29e8:	f1ba 0f0c 	cmp.w	sl, #12
 80a29ec:	bf08      	it	eq
 80a29ee:	46f4      	moveq	ip, lr
 80a29f0:	e000      	b.n	80a29f4 <_ZN9NSFastLED11inoise8_rawEttt+0x1b0>
 80a29f2:	46ac      	mov	ip, r5
		  v = z; // 04 05 06 07   08 09 0A 0B   0D  0F
	  }
  }
#endif

  if(hash&1) { u = -u; }
 80a29f4:	f019 0f01 	tst.w	r9, #1
 80a29f8:	bf1c      	itt	ne
 80a29fa:	4264      	negne	r4, r4
 80a29fc:	b264      	sxtbne	r4, r4
  if(hash&2) { v = -v; }
 80a29fe:	f019 0f02 	tst.w	r9, #2
 80a2a02:	bf1c      	itt	ne
 80a2a04:	f1cc 0c00 	rsbne	ip, ip, #0
 80a2a08:	fa4f fc8c 	sxtbne.w	ip, ip
 80a2a0c:	44a4      	add	ip, r4
 80a2a0e:	f004 0401 	and.w	r4, r4, #1
 80a2a12:	eb04 046c 	add.w	r4, r4, ip, asr #1
 80a2a16:	b2e4      	uxtb	r4, r4
    // int16_t prod = (uint16_t)delta * (uint16_t)frac;
    // int8_t scaled = prod >> 8;
    // int8_t result = a + scaled;
    // return result;
    int8_t result;
    if( b > a) {
 80a2a18:	9b05      	ldr	r3, [sp, #20]
 80a2a1a:	fa4f fc84 	sxtb.w	ip, r4
 80a2a1e:	4563      	cmp	r3, ip
        uint8_t delta = b - a;
        uint8_t scaled = scale8( delta, frac);
        result = a + scaled;
 80a2a20:	bfb5      	itete	lt
 80a2a22:	1aa4      	sublt	r4, r4, r2
    } else {
        uint8_t delta = a - b;
        uint8_t scaled = scale8( delta, frac);
        result = a - scaled;
 80a2a24:	1b14      	subge	r4, r2, r4
    // return result;
    int8_t result;
    if( b > a) {
        uint8_t delta = b - a;
        uint8_t scaled = scale8( delta, frac);
        result = a + scaled;
 80a2a26:	b2e4      	uxtblt	r4, r4
    } else {
        uint8_t delta = a - b;
        uint8_t scaled = scale8( delta, frac);
        result = a - scaled;
 80a2a28:	b2e4      	uxtbge	r4, r4
    // return result;
    int8_t result;
    if( b > a) {
        uint8_t delta = b - a;
        uint8_t scaled = scale8( delta, frac);
        result = a + scaled;
 80a2a2a:	bfb5      	itete	lt
 80a2a2c:	4344      	mullt	r4, r0
    } else {
        uint8_t delta = a - b;
        uint8_t scaled = scale8( delta, frac);
        result = a - scaled;
 80a2a2e:	4344      	mulge	r4, r0
    // return result;
    int8_t result;
    if( b > a) {
        uint8_t delta = b - a;
        uint8_t scaled = scale8( delta, frac);
        result = a + scaled;
 80a2a30:	eb02 2224 	addlt.w	r2, r2, r4, asr #8
    } else {
        uint8_t delta = a - b;
        uint8_t scaled = scale8( delta, frac);
        result = a - scaled;
 80a2a34:	eba2 2224 	subge.w	r2, r2, r4, asr #8
  // u = FADE(u); v = FADE(v); w = FADE(w);
  u = scale8_LEAVING_R1_DIRTY(u,u); v = scale8_LEAVING_R1_DIRTY(v,v); w = scale8(w,w);

  int8_t X1 = lerp7by8(grad8(P(AA), xx, yy, zz), grad8(P(BA), xx - N, yy, zz), u);
  int8_t X2 = lerp7by8(grad8(P(AB), xx, yy-N, zz), grad8(P(BB), xx - N, yy - N, zz), u);
  int8_t X3 = lerp7by8(grad8(P(AA+1), xx, yy, zz-N), grad8(P(BA+1), xx - N, yy, zz-N), u);
 80a2a38:	4c0c      	ldr	r4, [pc, #48]	; (80a2a6c <_ZN9NSFastLED11inoise8_rawEttt+0x228>)
 80a2a3a:	9b03      	ldr	r3, [sp, #12]
 80a2a3c:	44a0      	add	r8, r4
 80a2a3e:	f898 9001 	ldrb.w	r9, [r8, #1]
 80a2a42:	f1a3 0880 	sub.w	r8, r3, #128	; 0x80
    case 14: return (( y) + (-x))>>1;
    case 15: return ((-y) + (-z))>>1;
  }
#else

  hash &= 0xF;
 80a2a46:	f009 040f 	and.w	r4, r9, #15
// but with an AVR asm version that's smaller and quicker than C
// (and probably not worth including in lib8tion)
static int8_t inline __attribute__((always_inline)) selectBasedOnHashBit(uint8_t hash, uint8_t bitnumber, int8_t a, int8_t b) {
	int8_t result;
#if !defined(__AVR__)
	result = (hash & (1<<bitnumber)) ? a : b;
 80a2a4a:	08e3      	lsrs	r3, r4, #3
 80a2a4c:	bf14      	ite	ne
 80a2a4e:	46bc      	movne	ip, r7
 80a2a50:	46b4      	moveq	ip, r6
  int8_t u, v;
  //u = (hash&8)?y:x;
  u = selectBasedOnHashBit( hash, 3, y, x);

#if 1
  v = hash<4?y:hash==12||hash==14?x:z;
 80a2a52:	2c03      	cmp	r4, #3
        uint8_t scaled = scale8( delta, frac);
        result = a + scaled;
    } else {
        uint8_t delta = a - b;
        uint8_t scaled = scale8( delta, frac);
        result = a - scaled;
 80a2a54:	b252      	sxtb	r2, r2
  // u = FADE(u); v = FADE(v); w = FADE(w);
  u = scale8_LEAVING_R1_DIRTY(u,u); v = scale8_LEAVING_R1_DIRTY(v,v); w = scale8(w,w);

  int8_t X1 = lerp7by8(grad8(P(AA), xx, yy, zz), grad8(P(BA), xx - N, yy, zz), u);
  int8_t X2 = lerp7by8(grad8(P(AB), xx, yy-N, zz), grad8(P(BB), xx - N, yy - N, zz), u);
  int8_t X3 = lerp7by8(grad8(P(AA+1), xx, yy, zz-N), grad8(P(BA+1), xx - N, yy, zz-N), u);
 80a2a56:	fa4f f888 	sxtb.w	r8, r8
  int8_t u, v;
  //u = (hash&8)?y:x;
  u = selectBasedOnHashBit( hash, 3, y, x);

#if 1
  v = hash<4?y:hash==12||hash==14?x:z;
 80a2a5a:	d909      	bls.n	80a2a70 <_ZN9NSFastLED11inoise8_rawEttt+0x22c>
 80a2a5c:	f009 0a0d 	and.w	sl, r9, #13
 80a2a60:	f1ba 0f0c 	cmp.w	sl, #12
 80a2a64:	bf14      	ite	ne
 80a2a66:	46c2      	movne	sl, r8
 80a2a68:	46b2      	moveq	sl, r6
 80a2a6a:	e002      	b.n	80a2a72 <_ZN9NSFastLED11inoise8_rawEttt+0x22e>
 80a2a6c:	080a685c 	.word	0x080a685c
 80a2a70:	46ba      	mov	sl, r7
		  v = z; // 04 05 06 07   08 09 0A 0B   0D  0F
	  }
  }
#endif

  if(hash&1) { u = -u; }
 80a2a72:	f019 0f01 	tst.w	r9, #1
 80a2a76:	bf1c      	itt	ne
 80a2a78:	f1cc 0c00 	rsbne	ip, ip, #0
 80a2a7c:	fa4f fc8c 	sxtbne.w	ip, ip
  if(hash&2) { v = -v; }
 80a2a80:	f019 0f02 	tst.w	r9, #2
 80a2a84:	bf1c      	itt	ne
 80a2a86:	f1ca 0a00 	rsbne	sl, sl, #0
 80a2a8a:	fa4f fa8a 	sxtbne.w	sl, sl
 80a2a8e:	44e2      	add	sl, ip
 80a2a90:	f00c 0c01 	and.w	ip, ip, #1
 80a2a94:	eb0c 0a6a 	add.w	sl, ip, sl, asr #1
  // u = FADE(u); v = FADE(v); w = FADE(w);
  u = scale8_LEAVING_R1_DIRTY(u,u); v = scale8_LEAVING_R1_DIRTY(v,v); w = scale8(w,w);

  int8_t X1 = lerp7by8(grad8(P(AA), xx, yy, zz), grad8(P(BA), xx - N, yy, zz), u);
  int8_t X2 = lerp7by8(grad8(P(AB), xx, yy-N, zz), grad8(P(BB), xx - N, yy - N, zz), u);
  int8_t X3 = lerp7by8(grad8(P(AA+1), xx, yy, zz-N), grad8(P(BA+1), xx - N, yy, zz-N), u);
 80a2a98:	f8df c198 	ldr.w	ip, [pc, #408]	; 80a2c34 <_ZN9NSFastLED11inoise8_rawEttt+0x3f0>
 80a2a9c:	fa5f f48a 	uxtb.w	r4, sl
 80a2aa0:	44dc      	add	ip, fp
 80a2aa2:	f89c 9001 	ldrb.w	r9, [ip, #1]
 80a2aa6:	fa4f fa84 	sxtb.w	sl, r4
    case 14: return (( y) + (-x))>>1;
    case 15: return ((-y) + (-z))>>1;
  }
#else

  hash &= 0xF;
 80a2aaa:	f009 0b0f 	and.w	fp, r9, #15
// but with an AVR asm version that's smaller and quicker than C
// (and probably not worth including in lib8tion)
static int8_t inline __attribute__((always_inline)) selectBasedOnHashBit(uint8_t hash, uint8_t bitnumber, int8_t a, int8_t b) {
	int8_t result;
#if !defined(__AVR__)
	result = (hash & (1<<bitnumber)) ? a : b;
 80a2aae:	ea5f 03db 	movs.w	r3, fp, lsr #3
 80a2ab2:	bf14      	ite	ne
 80a2ab4:	46bc      	movne	ip, r7
 80a2ab6:	46f4      	moveq	ip, lr
  int8_t u, v;
  //u = (hash&8)?y:x;
  u = selectBasedOnHashBit( hash, 3, y, x);

#if 1
  v = hash<4?y:hash==12||hash==14?x:z;
 80a2ab8:	f1bb 0f03 	cmp.w	fp, #3
 80a2abc:	d905      	bls.n	80a2aca <_ZN9NSFastLED11inoise8_rawEttt+0x286>
 80a2abe:	f009 070d 	and.w	r7, r9, #13
 80a2ac2:	2f0c      	cmp	r7, #12
 80a2ac4:	bf14      	ite	ne
 80a2ac6:	4647      	movne	r7, r8
 80a2ac8:	4677      	moveq	r7, lr
		  v = z; // 04 05 06 07   08 09 0A 0B   0D  0F
	  }
  }
#endif

  if(hash&1) { u = -u; }
 80a2aca:	f019 0f01 	tst.w	r9, #1
 80a2ace:	bf1c      	itt	ne
 80a2ad0:	f1cc 0c00 	rsbne	ip, ip, #0
 80a2ad4:	fa4f fc8c 	sxtbne.w	ip, ip
  if(hash&2) { v = -v; }
 80a2ad8:	f019 0f02 	tst.w	r9, #2
 80a2adc:	bf1c      	itt	ne
 80a2ade:	427f      	negne	r7, r7
 80a2ae0:	b27f      	sxtbne	r7, r7
 80a2ae2:	4467      	add	r7, ip
 80a2ae4:	f00c 0c01 	and.w	ip, ip, #1
 80a2ae8:	eb0c 0767 	add.w	r7, ip, r7, asr #1
 80a2aec:	b2ff      	uxtb	r7, r7
    // int16_t prod = (uint16_t)delta * (uint16_t)frac;
    // int8_t scaled = prod >> 8;
    // int8_t result = a + scaled;
    // return result;
    int8_t result;
    if( b > a) {
 80a2aee:	fa4f fc87 	sxtb.w	ip, r7
 80a2af2:	45e2      	cmp	sl, ip
        uint8_t delta = b - a;
        uint8_t scaled = scale8( delta, frac);
        result = a + scaled;
 80a2af4:	bfb5      	itete	lt
 80a2af6:	1b3f      	sublt	r7, r7, r4
    } else {
        uint8_t delta = a - b;
        uint8_t scaled = scale8( delta, frac);
        result = a - scaled;
 80a2af8:	1be7      	subge	r7, r4, r7
    // return result;
    int8_t result;
    if( b > a) {
        uint8_t delta = b - a;
        uint8_t scaled = scale8( delta, frac);
        result = a + scaled;
 80a2afa:	b2ff      	uxtblt	r7, r7
    } else {
        uint8_t delta = a - b;
        uint8_t scaled = scale8( delta, frac);
        result = a - scaled;
 80a2afc:	b2ff      	uxtbge	r7, r7
    // return result;
    int8_t result;
    if( b > a) {
        uint8_t delta = b - a;
        uint8_t scaled = scale8( delta, frac);
        result = a + scaled;
 80a2afe:	bfb5      	itete	lt
 80a2b00:	4347      	mullt	r7, r0
    } else {
        uint8_t delta = a - b;
        uint8_t scaled = scale8( delta, frac);
        result = a - scaled;
 80a2b02:	4347      	mulge	r7, r0
    // return result;
    int8_t result;
    if( b > a) {
        uint8_t delta = b - a;
        uint8_t scaled = scale8( delta, frac);
        result = a + scaled;
 80a2b04:	eb04 2427 	addlt.w	r4, r4, r7, asr #8
    } else {
        uint8_t delta = a - b;
        uint8_t scaled = scale8( delta, frac);
        result = a - scaled;
 80a2b08:	eba4 2427 	subge.w	r4, r4, r7, asr #8
  u = scale8_LEAVING_R1_DIRTY(u,u); v = scale8_LEAVING_R1_DIRTY(v,v); w = scale8(w,w);

  int8_t X1 = lerp7by8(grad8(P(AA), xx, yy, zz), grad8(P(BA), xx - N, yy, zz), u);
  int8_t X2 = lerp7by8(grad8(P(AB), xx, yy-N, zz), grad8(P(BB), xx - N, yy - N, zz), u);
  int8_t X3 = lerp7by8(grad8(P(AA+1), xx, yy, zz-N), grad8(P(BA+1), xx - N, yy, zz-N), u);
  int8_t X4 = lerp7by8(grad8(P(AB+1), xx, yy-N, zz-N), grad8(P(BB+1), xx - N, yy - N, zz - N), u);
 80a2b0c:	9b01      	ldr	r3, [sp, #4]
 80a2b0e:	4f49      	ldr	r7, [pc, #292]	; (80a2c34 <_ZN9NSFastLED11inoise8_rawEttt+0x3f0>)
        uint8_t scaled = scale8( delta, frac);
        result = a + scaled;
    } else {
        uint8_t delta = a - b;
        uint8_t scaled = scale8( delta, frac);
        result = a - scaled;
 80a2b10:	b264      	sxtb	r4, r4
  u = scale8_LEAVING_R1_DIRTY(u,u); v = scale8_LEAVING_R1_DIRTY(v,v); w = scale8(w,w);

  int8_t X1 = lerp7by8(grad8(P(AA), xx, yy, zz), grad8(P(BA), xx - N, yy, zz), u);
  int8_t X2 = lerp7by8(grad8(P(AB), xx, yy-N, zz), grad8(P(BB), xx - N, yy - N, zz), u);
  int8_t X3 = lerp7by8(grad8(P(AA+1), xx, yy, zz-N), grad8(P(BA+1), xx - N, yy, zz-N), u);
  int8_t X4 = lerp7by8(grad8(P(AB+1), xx, yy-N, zz-N), grad8(P(BB+1), xx - N, yy - N, zz - N), u);
 80a2b12:	441f      	add	r7, r3
 80a2b14:	f897 c001 	ldrb.w	ip, [r7, #1]
    case 14: return (( y) + (-x))>>1;
    case 15: return ((-y) + (-z))>>1;
  }
#else

  hash &= 0xF;
 80a2b18:	f00c 090f 	and.w	r9, ip, #15
// but with an AVR asm version that's smaller and quicker than C
// (and probably not worth including in lib8tion)
static int8_t inline __attribute__((always_inline)) selectBasedOnHashBit(uint8_t hash, uint8_t bitnumber, int8_t a, int8_t b) {
	int8_t result;
#if !defined(__AVR__)
	result = (hash & (1<<bitnumber)) ? a : b;
 80a2b1c:	ea5f 03d9 	movs.w	r3, r9, lsr #3
 80a2b20:	bf14      	ite	ne
 80a2b22:	462f      	movne	r7, r5
 80a2b24:	4637      	moveq	r7, r6
  int8_t u, v;
  //u = (hash&8)?y:x;
  u = selectBasedOnHashBit( hash, 3, y, x);

#if 1
  v = hash<4?y:hash==12||hash==14?x:z;
 80a2b26:	f1b9 0f03 	cmp.w	r9, #3
 80a2b2a:	d906      	bls.n	80a2b3a <_ZN9NSFastLED11inoise8_rawEttt+0x2f6>
 80a2b2c:	f00c 090d 	and.w	r9, ip, #13
 80a2b30:	f1b9 0f0c 	cmp.w	r9, #12
 80a2b34:	bf18      	it	ne
 80a2b36:	4646      	movne	r6, r8
 80a2b38:	e000      	b.n	80a2b3c <_ZN9NSFastLED11inoise8_rawEttt+0x2f8>
 80a2b3a:	462e      	mov	r6, r5
		  v = z; // 04 05 06 07   08 09 0A 0B   0D  0F
	  }
  }
#endif

  if(hash&1) { u = -u; }
 80a2b3c:	f01c 0f01 	tst.w	ip, #1
 80a2b40:	bf1c      	itt	ne
 80a2b42:	427f      	negne	r7, r7
 80a2b44:	b27f      	sxtbne	r7, r7
  if(hash&2) { v = -v; }
 80a2b46:	f01c 0f02 	tst.w	ip, #2
 80a2b4a:	bf1c      	itt	ne
 80a2b4c:	4276      	negne	r6, r6
 80a2b4e:	b276      	sxtbne	r6, r6
 80a2b50:	443e      	add	r6, r7
 80a2b52:	f007 0701 	and.w	r7, r7, #1
 80a2b56:	eb07 0666 	add.w	r6, r7, r6, asr #1
  u = scale8_LEAVING_R1_DIRTY(u,u); v = scale8_LEAVING_R1_DIRTY(v,v); w = scale8(w,w);

  int8_t X1 = lerp7by8(grad8(P(AA), xx, yy, zz), grad8(P(BA), xx - N, yy, zz), u);
  int8_t X2 = lerp7by8(grad8(P(AB), xx, yy-N, zz), grad8(P(BB), xx - N, yy - N, zz), u);
  int8_t X3 = lerp7by8(grad8(P(AA+1), xx, yy, zz-N), grad8(P(BA+1), xx - N, yy, zz-N), u);
  int8_t X4 = lerp7by8(grad8(P(AB+1), xx, yy-N, zz-N), grad8(P(BB+1), xx - N, yy - N, zz - N), u);
 80a2b5a:	9b02      	ldr	r3, [sp, #8]
 80a2b5c:	4f35      	ldr	r7, [pc, #212]	; (80a2c34 <_ZN9NSFastLED11inoise8_rawEttt+0x3f0>)
 80a2b5e:	b2f6      	uxtb	r6, r6
 80a2b60:	441f      	add	r7, r3
 80a2b62:	f897 9001 	ldrb.w	r9, [r7, #1]
 80a2b66:	fa4f fc86 	sxtb.w	ip, r6
    case 14: return (( y) + (-x))>>1;
    case 15: return ((-y) + (-z))>>1;
  }
#else

  hash &= 0xF;
 80a2b6a:	f009 0a0f 	and.w	sl, r9, #15
// but with an AVR asm version that's smaller and quicker than C
// (and probably not worth including in lib8tion)
static int8_t inline __attribute__((always_inline)) selectBasedOnHashBit(uint8_t hash, uint8_t bitnumber, int8_t a, int8_t b) {
	int8_t result;
#if !defined(__AVR__)
	result = (hash & (1<<bitnumber)) ? a : b;
 80a2b6e:	ea5f 03da 	movs.w	r3, sl, lsr #3
 80a2b72:	bf14      	ite	ne
 80a2b74:	462f      	movne	r7, r5
 80a2b76:	4677      	moveq	r7, lr
  int8_t u, v;
  //u = (hash&8)?y:x;
  u = selectBasedOnHashBit( hash, 3, y, x);

#if 1
  v = hash<4?y:hash==12||hash==14?x:z;
 80a2b78:	f1ba 0f03 	cmp.w	sl, #3
 80a2b7c:	d905      	bls.n	80a2b8a <_ZN9NSFastLED11inoise8_rawEttt+0x346>
 80a2b7e:	f009 050d 	and.w	r5, r9, #13
 80a2b82:	2d0c      	cmp	r5, #12
 80a2b84:	bf14      	ite	ne
 80a2b86:	4645      	movne	r5, r8
 80a2b88:	4675      	moveq	r5, lr
		  v = z; // 04 05 06 07   08 09 0A 0B   0D  0F
	  }
  }
#endif

  if(hash&1) { u = -u; }
 80a2b8a:	f019 0f01 	tst.w	r9, #1
 80a2b8e:	bf1c      	itt	ne
 80a2b90:	427f      	negne	r7, r7
 80a2b92:	b27f      	sxtbne	r7, r7
  if(hash&2) { v = -v; }
 80a2b94:	f019 0f02 	tst.w	r9, #2
 80a2b98:	bf1c      	itt	ne
 80a2b9a:	426d      	negne	r5, r5
 80a2b9c:	b26d      	sxtbne	r5, r5
 80a2b9e:	443d      	add	r5, r7
 80a2ba0:	f007 0701 	and.w	r7, r7, #1
 80a2ba4:	eb07 0565 	add.w	r5, r7, r5, asr #1
 80a2ba8:	b2ed      	uxtb	r5, r5
    // int16_t prod = (uint16_t)delta * (uint16_t)frac;
    // int8_t scaled = prod >> 8;
    // int8_t result = a + scaled;
    // return result;
    int8_t result;
    if( b > a) {
 80a2baa:	b26f      	sxtb	r7, r5
 80a2bac:	45bc      	cmp	ip, r7
        uint8_t delta = b - a;
        uint8_t scaled = scale8( delta, frac);
        result = a + scaled;
 80a2bae:	bfb3      	iteet	lt
 80a2bb0:	1bad      	sublt	r5, r5, r6
    } else {
        uint8_t delta = a - b;
        uint8_t scaled = scale8( delta, frac);
        result = a - scaled;
 80a2bb2:	1b75      	subge	r5, r6, r5
 80a2bb4:	b2ed      	uxtbge	r5, r5
    // return result;
    int8_t result;
    if( b > a) {
        uint8_t delta = b - a;
        uint8_t scaled = scale8( delta, frac);
        result = a + scaled;
 80a2bb6:	b2ed      	uxtblt	r5, r5
 80a2bb8:	bfb4      	ite	lt
 80a2bba:	4368      	mullt	r0, r5
    } else {
        uint8_t delta = a - b;
        uint8_t scaled = scale8( delta, frac);
        result = a - scaled;
 80a2bbc:	4345      	mulge	r5, r0
    // int16_t prod = (uint16_t)delta * (uint16_t)frac;
    // int8_t scaled = prod >> 8;
    // int8_t result = a + scaled;
    // return result;
    int8_t result;
    if( b > a) {
 80a2bbe:	9b00      	ldr	r3, [sp, #0]
        uint8_t delta = b - a;
        uint8_t scaled = scale8( delta, frac);
        result = a + scaled;
 80a2bc0:	bfb4      	ite	lt
 80a2bc2:	eb06 2620 	addlt.w	r6, r6, r0, asr #8
    } else {
        uint8_t delta = a - b;
        uint8_t scaled = scale8( delta, frac);
        result = a - scaled;
 80a2bc6:	eba6 2625 	subge.w	r6, r6, r5, asr #8
    // int16_t prod = (uint16_t)delta * (uint16_t)frac;
    // int8_t scaled = prod >> 8;
    // int8_t result = a + scaled;
    // return result;
    int8_t result;
    if( b > a) {
 80a2bca:	429a      	cmp	r2, r3
 80a2bcc:	f89d 3000 	ldrb.w	r3, [sp]
        uint8_t scaled = scale8( delta, frac);
        result = a + scaled;
    } else {
        uint8_t delta = a - b;
        uint8_t scaled = scale8( delta, frac);
        result = a - scaled;
 80a2bd0:	b276      	sxtb	r6, r6
    // return result;
    int8_t result;
    if( b > a) {
        uint8_t delta = b - a;
        uint8_t scaled = scale8( delta, frac);
        result = a + scaled;
 80a2bd2:	bfcb      	itete	gt
 80a2bd4:	1ad0      	subgt	r0, r2, r3
    } else {
        uint8_t delta = a - b;
        uint8_t scaled = scale8( delta, frac);
        result = a - scaled;
 80a2bd6:	1a98      	suble	r0, r3, r2
    // return result;
    int8_t result;
    if( b > a) {
        uint8_t delta = b - a;
        uint8_t scaled = scale8( delta, frac);
        result = a + scaled;
 80a2bd8:	b2c0      	uxtbgt	r0, r0
    } else {
        uint8_t delta = a - b;
        uint8_t scaled = scale8( delta, frac);
        result = a - scaled;
 80a2bda:	b2c0      	uxtble	r0, r0
    // return result;
    int8_t result;
    if( b > a) {
        uint8_t delta = b - a;
        uint8_t scaled = scale8( delta, frac);
        result = a + scaled;
 80a2bdc:	bfcb      	itete	gt
 80a2bde:	4348      	mulgt	r0, r1
    } else {
        uint8_t delta = a - b;
        uint8_t scaled = scale8( delta, frac);
        result = a - scaled;
 80a2be0:	4348      	mulle	r0, r1
    // return result;
    int8_t result;
    if( b > a) {
        uint8_t delta = b - a;
        uint8_t scaled = scale8( delta, frac);
        result = a + scaled;
 80a2be2:	eb03 2320 	addgt.w	r3, r3, r0, asr #8
    } else {
        uint8_t delta = a - b;
        uint8_t scaled = scale8( delta, frac);
        result = a - scaled;
 80a2be6:	eba3 2320 	suble.w	r3, r3, r0, asr #8
    // int16_t prod = (uint16_t)delta * (uint16_t)frac;
    // int8_t scaled = prod >> 8;
    // int8_t result = a + scaled;
    // return result;
    int8_t result;
    if( b > a) {
 80a2bea:	42a6      	cmp	r6, r4
 80a2bec:	b2e4      	uxtb	r4, r4
        uint8_t delta = b - a;
        uint8_t scaled = scale8( delta, frac);
        result = a + scaled;
 80a2bee:	bfcb      	itete	gt
 80a2bf0:	1b36      	subgt	r6, r6, r4
    } else {
        uint8_t delta = a - b;
        uint8_t scaled = scale8( delta, frac);
        result = a - scaled;
 80a2bf2:	1ba6      	suble	r6, r4, r6
    // return result;
    int8_t result;
    if( b > a) {
        uint8_t delta = b - a;
        uint8_t scaled = scale8( delta, frac);
        result = a + scaled;
 80a2bf4:	b2f6      	uxtbgt	r6, r6
    } else {
        uint8_t delta = a - b;
        uint8_t scaled = scale8( delta, frac);
        result = a - scaled;
 80a2bf6:	b2f6      	uxtble	r6, r6
    // return result;
    int8_t result;
    if( b > a) {
        uint8_t delta = b - a;
        uint8_t scaled = scale8( delta, frac);
        result = a + scaled;
 80a2bf8:	bfcb      	itete	gt
 80a2bfa:	4371      	mulgt	r1, r6
    } else {
        uint8_t delta = a - b;
        uint8_t scaled = scale8( delta, frac);
        result = a - scaled;
 80a2bfc:	4371      	mulle	r1, r6
    // return result;
    int8_t result;
    if( b > a) {
        uint8_t delta = b - a;
        uint8_t scaled = scale8( delta, frac);
        result = a + scaled;
 80a2bfe:	eb04 2121 	addgt.w	r1, r4, r1, asr #8
    } else {
        uint8_t delta = a - b;
        uint8_t scaled = scale8( delta, frac);
        result = a - scaled;
 80a2c02:	eba4 2121 	suble.w	r1, r4, r1, asr #8
 80a2c06:	b258      	sxtb	r0, r3
 80a2c08:	b249      	sxtb	r1, r1
    // int16_t prod = (uint16_t)delta * (uint16_t)frac;
    // int8_t scaled = prod >> 8;
    // int8_t result = a + scaled;
    // return result;
    int8_t result;
    if( b > a) {
 80a2c0a:	4281      	cmp	r1, r0
 80a2c0c:	b2c0      	uxtb	r0, r0
 80a2c0e:	dd06      	ble.n	80a2c1e <_ZN9NSFastLED11inoise8_rawEttt+0x3da>
        uint8_t delta = b - a;
        uint8_t scaled = scale8( delta, frac);
        result = a + scaled;
 80a2c10:	1a0a      	subs	r2, r1, r0
 80a2c12:	9b04      	ldr	r3, [sp, #16]
 80a2c14:	b2d2      	uxtb	r2, r2
 80a2c16:	4353      	muls	r3, r2
 80a2c18:	eb00 2023 	add.w	r0, r0, r3, asr #8
 80a2c1c:	e005      	b.n	80a2c2a <_ZN9NSFastLED11inoise8_rawEttt+0x3e6>
    } else {
        uint8_t delta = a - b;
        uint8_t scaled = scale8( delta, frac);
        result = a - scaled;
 80a2c1e:	1a41      	subs	r1, r0, r1
 80a2c20:	9b04      	ldr	r3, [sp, #16]
 80a2c22:	b2c9      	uxtb	r1, r1
 80a2c24:	434b      	muls	r3, r1
 80a2c26:	eba0 2023 	sub.w	r0, r0, r3, asr #8
 80a2c2a:	b240      	sxtb	r0, r0
  int8_t Y2 = lerp7by8(X3,X4,v);

  int8_t ans = lerp7by8(Y1,Y2,w);

  return ans;
}
 80a2c2c:	b007      	add	sp, #28
 80a2c2e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80a2c32:	bf00      	nop
 80a2c34:	080a685c 	.word	0x080a685c

080a2c38 <_ZN9NSFastLED7inoise8Ettt>:

uint8_t inoise8(uint16_t x, uint16_t y, uint16_t z) {
 80a2c38:	b508      	push	{r3, lr}
  return scale8(76+(inoise8_raw(x,y,z)),215)<<1;
 80a2c3a:	f7ff fe03 	bl	80a2844 <_ZN9NSFastLED11inoise8_rawEttt>
 80a2c3e:	304c      	adds	r0, #76	; 0x4c
 80a2c40:	23d7      	movs	r3, #215	; 0xd7
 80a2c42:	b2c0      	uxtb	r0, r0
 80a2c44:	4358      	muls	r0, r3
 80a2c46:	09c0      	lsrs	r0, r0, #7
}
 80a2c48:	f000 00fe 	and.w	r0, r0, #254	; 0xfe
 80a2c4c:	bd08      	pop	{r3, pc}

080a2c4e <_GLOBAL__sub_I__ZN9NSFastLED12inoise16_rawEmmm>:
 80a2c4e:	f000 be87 	b.w	80a3960 <HAL_Pin_Map>

080a2c52 <_GLOBAL__sub_I__ZN9NSFastLED10rand16seedE>:
 80a2c52:	f000 be85 	b.w	80a3960 <HAL_Pin_Map>

080a2c56 <_ZN9NSFastLED14CLEDController13getAdjustmentEh>:
 80a2c56:	2300      	movs	r3, #0

    CLEDController & setTemperature(CRGB temperature) { m_ColorTemperature = temperature; return *this; }
    CLEDController & setTemperature(ColorTemperature temperature) { m_ColorTemperature = temperature; return *this; }
    CRGB getTemperature() { return m_ColorTemperature; }

    CRGB getAdjustment(uint8_t scale) {
 80a2c58:	b570      	push	{r4, r5, r6, lr}
 80a2c5a:	7003      	strb	r3, [r0, #0]
 80a2c5c:	7043      	strb	r3, [r0, #1]
 80a2c5e:	7083      	strb	r3, [r0, #2]
#if defined(NO_CORRECTION) && (NO_CORRECTION==1)
        return CRGB(scale,scale,scale);
#else
        CRGB adj(0,0,0);

        if(scale > 0) {
 80a2c60:	b192      	cbz	r2, 80a2c88 <_ZN9NSFastLED14CLEDController13getAdjustmentEh+0x32>
 80a2c62:	4605      	mov	r5, r0
 80a2c64:	f101 040b 	add.w	r4, r1, #11
 80a2c68:	310e      	adds	r1, #14
            for(uint8_t i = 0; i < 3; i++) {
                uint8_t cc = m_ColorCorrection.raw[i];
 80a2c6a:	f814 6f01 	ldrb.w	r6, [r4, #1]!
                uint8_t ct = m_ColorTemperature.raw[i];
                if(cc > 0 && ct > 0) {
 80a2c6e:	b13e      	cbz	r6, 80a2c80 <_ZN9NSFastLED14CLEDController13getAdjustmentEh+0x2a>
        CRGB adj(0,0,0);

        if(scale > 0) {
            for(uint8_t i = 0; i < 3; i++) {
                uint8_t cc = m_ColorCorrection.raw[i];
                uint8_t ct = m_ColorTemperature.raw[i];
 80a2c70:	78e3      	ldrb	r3, [r4, #3]
                if(cc > 0 && ct > 0) {
 80a2c72:	b12b      	cbz	r3, 80a2c80 <_ZN9NSFastLED14CLEDController13getAdjustmentEh+0x2a>
                    uint32_t work = (((uint32_t)cc)+1) * (((uint32_t)ct)+1) * scale;
 80a2c74:	3301      	adds	r3, #1
 80a2c76:	fb06 3303 	mla	r3, r6, r3, r3
 80a2c7a:	4353      	muls	r3, r2
                    work /= 0x10000L;
                    adj.raw[i] = work & 0xFF;
 80a2c7c:	0c1b      	lsrs	r3, r3, #16
 80a2c7e:	702b      	strb	r3, [r5, #0]
        return CRGB(scale,scale,scale);
#else
        CRGB adj(0,0,0);

        if(scale > 0) {
            for(uint8_t i = 0; i < 3; i++) {
 80a2c80:	428c      	cmp	r4, r1
 80a2c82:	f105 0501 	add.w	r5, r5, #1
 80a2c86:	d1f0      	bne.n	80a2c6a <_ZN9NSFastLED14CLEDController13getAdjustmentEh+0x14>
            }
        }

        return adj;
#endif
    }
 80a2c88:	bd70      	pop	{r4, r5, r6, pc}

080a2c8a <_ZN9NSFastLED8CFastLED7addLedsEPNS_14CLEDControllerEPNS_4CRGBEii>:
	setMaxRefreshRate(400);
}

CLEDController &CFastLED::addLeds(CLEDController *pLed,
									   struct CRGB *data,
									   int nLedsOrOffset, int nLedsIfOffset) {
 80a2c8a:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80a2c8c:	4614      	mov	r4, r2
	int nOffset = (nLedsIfOffset > 0) ? nLedsOrOffset : 0;
 80a2c8e:	1e1e      	subs	r6, r3, #0
	setMaxRefreshRate(400);
}

CLEDController &CFastLED::addLeds(CLEDController *pLed,
									   struct CRGB *data,
									   int nLedsOrOffset, int nLedsIfOffset) {
 80a2c90:	460f      	mov	r7, r1
 80a2c92:	4605      	mov	r5, r0
	int nOffset = (nLedsIfOffset > 0) ? nLedsOrOffset : 0;
	int nLeds = (nLedsIfOffset > 0) ? nLedsIfOffset : nLedsOrOffset;
 80a2c94:	bfd8      	it	le
 80a2c96:	4616      	movle	r6, r2

	pLed->init();
 80a2c98:	6803      	ldr	r3, [r0, #0]
}

CLEDController &CFastLED::addLeds(CLEDController *pLed,
									   struct CRGB *data,
									   int nLedsOrOffset, int nLedsIfOffset) {
	int nOffset = (nLedsIfOffset > 0) ? nLedsOrOffset : 0;
 80a2c9a:	bfd8      	it	le
 80a2c9c:	2400      	movle	r4, #0
	int nLeds = (nLedsIfOffset > 0) ? nLedsIfOffset : nLedsOrOffset;

	pLed->init();
 80a2c9e:	689b      	ldr	r3, [r3, #8]
        show(data, nLeds, getAdjustment(brightness))
    }
#endif

    CLEDController & setLeds(CRGB *data, int nLeds) {
        m_Data = data;
 80a2ca0:	eb04 0444 	add.w	r4, r4, r4, lsl #1
 80a2ca4:	4798      	blx	r3
 80a2ca6:	1939      	adds	r1, r7, r4
 80a2ca8:	6069      	str	r1, [r5, #4]
        m_nLeds = nLeds;
 80a2caa:	616e      	str	r6, [r5, #20]
	pLed->setLeds(data + nOffset, nLeds);
	return *pLed;
}
 80a2cac:	4628      	mov	r0, r5
 80a2cae:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

080a2cb0 <_ZN9NSFastLED8CFastLED8countFPSEi>:
// }

extern int noise_min;
extern int noise_max;

void CFastLED::countFPS(int nFrames) {
 80a2cb0:	b570      	push	{r4, r5, r6, lr}
  static int br = 0;
  static uint32_t lastframe = 0; // ::millis();

  if(br++ >= nFrames) {
 80a2cb2:	4c0c      	ldr	r4, [pc, #48]	; (80a2ce4 <_ZN9NSFastLED8CFastLED8countFPSEi+0x34>)
// }

extern int noise_min;
extern int noise_max;

void CFastLED::countFPS(int nFrames) {
 80a2cb4:	4606      	mov	r6, r0
  static int br = 0;
  static uint32_t lastframe = 0; // ::millis();

  if(br++ >= nFrames) {
 80a2cb6:	6823      	ldr	r3, [r4, #0]
 80a2cb8:	1c5a      	adds	r2, r3, #1
 80a2cba:	428b      	cmp	r3, r1
 80a2cbc:	6022      	str	r2, [r4, #0]
 80a2cbe:	db10      	blt.n	80a2ce2 <_ZN9NSFastLED8CFastLED8countFPSEi+0x32>
#endif

#include "timer_hal.h"
#include "delay_hal.h"

inline system_tick_t millis(void) { return HAL_Timer_Get_Milli_Seconds(); }
 80a2cc0:	f000 fe0e 	bl	80a38e0 <HAL_Timer_Get_Milli_Seconds>
		uint32_t now = ::millis();
		now -= lastframe;
		m_nFPS = (br * 1000) / now;
 80a2cc4:	6822      	ldr	r2, [r4, #0]
  static int br = 0;
  static uint32_t lastframe = 0; // ::millis();

  if(br++ >= nFrames) {
		uint32_t now = ::millis();
		now -= lastframe;
 80a2cc6:	4d08      	ldr	r5, [pc, #32]	; (80a2ce8 <_ZN9NSFastLED8CFastLED8countFPSEi+0x38>)
		m_nFPS = (br * 1000) / now;
 80a2cc8:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 80a2ccc:	4353      	muls	r3, r2
 80a2cce:	682a      	ldr	r2, [r5, #0]
 80a2cd0:	1a80      	subs	r0, r0, r2
 80a2cd2:	fbb3 f3f0 	udiv	r3, r3, r0
 80a2cd6:	8073      	strh	r3, [r6, #2]
    br = 0;
 80a2cd8:	2300      	movs	r3, #0
 80a2cda:	6023      	str	r3, [r4, #0]
 80a2cdc:	f000 fe00 	bl	80a38e0 <HAL_Timer_Get_Milli_Seconds>
    lastframe = ::millis();
 80a2ce0:	6028      	str	r0, [r5, #0]
 80a2ce2:	bd70      	pop	{r4, r5, r6, pc}
 80a2ce4:	200008f8 	.word	0x200008f8
 80a2ce8:	200008fc 	.word	0x200008fc

080a2cec <_ZN9NSFastLED8CFastLED4showEh>:
	pLed->init();
	pLed->setLeds(data + nOffset, nLeds);
	return *pLed;
}

void CFastLED::show(uint8_t scale) {
 80a2cec:	e92d 4ff7 	stmdb	sp!, {r0, r1, r2, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80a2cf0:	4605      	mov	r5, r0
 80a2cf2:	460f      	mov	r7, r1
 80a2cf4:	4c19      	ldr	r4, [pc, #100]	; (80a2d5c <_ZN9NSFastLED8CFastLED4showEh+0x70>)
	// guard against showing too rapidly
	while(m_nMinMicros && ((micros()-lastshow) < m_nMinMicros));
 80a2cf6:	686b      	ldr	r3, [r5, #4]
 80a2cf8:	b133      	cbz	r3, 80a2d08 <_ZN9NSFastLED8CFastLED4showEh+0x1c>
inline unsigned long micros(void) { return HAL_Timer_Get_Micro_Seconds(); }
 80a2cfa:	f000 fde9 	bl	80a38d0 <HAL_Timer_Get_Micro_Seconds>
 80a2cfe:	6823      	ldr	r3, [r4, #0]
 80a2d00:	1ac0      	subs	r0, r0, r3
 80a2d02:	686b      	ldr	r3, [r5, #4]
 80a2d04:	4298      	cmp	r0, r3
 80a2d06:	d3f6      	bcc.n	80a2cf6 <_ZN9NSFastLED8CFastLED4showEh+0xa>
 80a2d08:	f000 fde2 	bl	80a38d0 <HAL_Timer_Get_Micro_Seconds>
	lastshow = micros();
 80a2d0c:	4b13      	ldr	r3, [pc, #76]	; (80a2d5c <_ZN9NSFastLED8CFastLED4showEh+0x70>)
    CRGB* leds() { return m_Data; }

    // Reference to the n'th item in the controller
    CRGB &operator[](int x) { return m_Data[x]; }

    inline CLEDController & setDither(uint8_t ditherMode = BINARY_DITHER) { m_DitherMode = ditherMode; return *this; }
 80a2d0e:	2600      	movs	r6, #0
 80a2d10:	6018      	str	r0, [r3, #0]
    void showColor(const struct CRGB & data, uint8_t brightness=255) {
        showColor(data, m_nLeds, getAdjustment(brightness));
    }

    // navigating the list of controllers
    static CLEDController *head() { return m_pHead; }
 80a2d12:	4b13      	ldr	r3, [pc, #76]	; (80a2d60 <_ZN9NSFastLED8CFastLED4showEh+0x74>)
 80a2d14:	681c      	ldr	r4, [r3, #0]

	CLEDController *pCur = CLEDController::head();
	while(pCur) {
 80a2d16:	b1d4      	cbz	r4, 80a2d4e <_ZN9NSFastLED8CFastLED4showEh+0x62>
		uint8_t d = pCur->getDither();
		if(m_nFPS < 100) { pCur->setDither(0); }
 80a2d18:	886b      	ldrh	r3, [r5, #2]
        showColor(data, nLeds, getAdjustment(brightness));
    }

    // show function using the "attached to this controller" led data
    void showLeds(uint8_t brightness=255) {
        show(m_Data, m_nLeds, getAdjustment(brightness));
 80a2d1a:	f8d4 a004 	ldr.w	sl, [r4, #4]
 80a2d1e:	2b63      	cmp	r3, #99	; 0x63
 80a2d20:	f8d4 b014 	ldr.w	fp, [r4, #20]
 80a2d24:	6823      	ldr	r3, [r4, #0]
 80a2d26:	f894 8012 	ldrb.w	r8, [r4, #18]
 80a2d2a:	4621      	mov	r1, r4
    CRGB* leds() { return m_Data; }

    // Reference to the n'th item in the controller
    CRGB &operator[](int x) { return m_Data[x]; }

    inline CLEDController & setDither(uint8_t ditherMode = BINARY_DITHER) { m_DitherMode = ditherMode; return *this; }
 80a2d2c:	bf98      	it	ls
 80a2d2e:	74a6      	strbls	r6, [r4, #18]
        showColor(data, nLeds, getAdjustment(brightness));
    }

    // show function using the "attached to this controller" led data
    void showLeds(uint8_t brightness=255) {
        show(m_Data, m_nLeds, getAdjustment(brightness));
 80a2d30:	463a      	mov	r2, r7
 80a2d32:	a801      	add	r0, sp, #4
 80a2d34:	f8d3 9004 	ldr.w	r9, [r3, #4]
 80a2d38:	f7ff ff8d 	bl	80a2c56 <_ZN9NSFastLED14CLEDController13getAdjustmentEh>
 80a2d3c:	4620      	mov	r0, r4
 80a2d3e:	ab01      	add	r3, sp, #4
 80a2d40:	465a      	mov	r2, fp
 80a2d42:	4651      	mov	r1, sl
 80a2d44:	47c8      	blx	r9
    CRGB* leds() { return m_Data; }

    // Reference to the n'th item in the controller
    CRGB &operator[](int x) { return m_Data[x]; }

    inline CLEDController & setDither(uint8_t ditherMode = BINARY_DITHER) { m_DitherMode = ditherMode; return *this; }
 80a2d46:	f884 8012 	strb.w	r8, [r4, #18]
 80a2d4a:	68a4      	ldr	r4, [r4, #8]
	// guard against showing too rapidly
	while(m_nMinMicros && ((micros()-lastshow) < m_nMinMicros));
	lastshow = micros();

	CLEDController *pCur = CLEDController::head();
	while(pCur) {
 80a2d4c:	e7e3      	b.n	80a2d16 <_ZN9NSFastLED8CFastLED4showEh+0x2a>
		if(m_nFPS < 100) { pCur->setDither(0); }
		pCur->showLeds(scale);
		pCur->setDither(d);
		pCur = pCur->next();
	}
	countFPS();
 80a2d4e:	2119      	movs	r1, #25
 80a2d50:	4628      	mov	r0, r5
 80a2d52:	f7ff ffad 	bl	80a2cb0 <_ZN9NSFastLED8CFastLED8countFPSEi>
}
 80a2d56:	b003      	add	sp, #12
 80a2d58:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80a2d5c:	20000900 	.word	0x20000900
 80a2d60:	20000904 	.word	0x20000904

080a2d64 <_GLOBAL__sub_I__ZN9NSFastLED12pSmartMatrixE>:

	}
}
#endif

FASTLED_NAMESPACE_END
 80a2d64:	b508      	push	{r3, lr}
 80a2d66:	f000 fdfb 	bl	80a3960 <HAL_Pin_Map>
// uint32_t CRGB::Squant = ((uint32_t)((__TIME__[4]-'0') * 28))<<16 | ((__TIME__[6]-'0')*50)<<8 | ((__TIME__[7]-'0')*28);

CFastLED::CFastLED() {
	// clear out the array of led controllers
	// m_nControllers = 0;
	m_Scale = 255;
 80a2d6a:	4b04      	ldr	r3, [pc, #16]	; (80a2d7c <_GLOBAL__sub_I__ZN9NSFastLED12pSmartMatrixE+0x18>)
 80a2d6c:	22ff      	movs	r2, #255	; 0xff
 80a2d6e:	701a      	strb	r2, [r3, #0]
	m_nFPS = 0;
 80a2d70:	2200      	movs	r2, #0
 80a2d72:	805a      	strh	r2, [r3, #2]
  }
}

void CFastLED::setMaxRefreshRate(uint16_t refresh) {
		if(refresh > 0) {
			m_nMinMicros = 1000000 / refresh;
 80a2d74:	f640 12c4 	movw	r2, #2500	; 0x9c4
 80a2d78:	605a      	str	r2, [r3, #4]
 80a2d7a:	bd08      	pop	{r3, pc}
 80a2d7c:	200008ec 	.word	0x200008ec

080a2d80 <_GLOBAL__sub_I__ZN9NSFastLED27calculate_unscaled_power_mWEPKNS_4CRGBEt>:
 80a2d80:	f000 bdee 	b.w	80a3960 <HAL_Pin_Map>

080a2d84 <_GLOBAL__sub_I_wiring.cpp>:
 80a2d84:	f000 bdec 	b.w	80a3960 <HAL_Pin_Map>

080a2d88 <_ZN9TCPClientD1Ev>:
class TCPClient : public Client {

public:
    TCPClient();
    TCPClient(sock_handle_t sock);
    virtual ~TCPClient() {};
 80a2d88:	b538      	push	{r3, r4, r5, lr}
 80a2d8a:	4b0b      	ldr	r3, [pc, #44]	; (80a2db8 <_ZN9TCPClientD1Ev+0x30>)
      // Does not throw if __r._M_get_use_count() == 0, caller must check.
      explicit __shared_count(const __weak_count<_Lp>& __r, std::nothrow_t);

      ~__shared_count() noexcept
      {
	if (_M_pi != nullptr)
 80a2d8c:	6984      	ldr	r4, [r0, #24]
 80a2d8e:	4605      	mov	r5, r0
 80a2d90:	6003      	str	r3, [r0, #0]
 80a2d92:	b17c      	cbz	r4, 80a2db4 <_ZN9TCPClientD1Ev+0x2c>

  template<>
    inline void
    _Sp_counted_base<_S_single>::_M_release() noexcept
    {
      if (--_M_use_count == 0)
 80a2d94:	6863      	ldr	r3, [r4, #4]
 80a2d96:	3b01      	subs	r3, #1
 80a2d98:	6063      	str	r3, [r4, #4]
 80a2d9a:	b95b      	cbnz	r3, 80a2db4 <_ZN9TCPClientD1Ev+0x2c>
        {
          _M_dispose();
 80a2d9c:	6823      	ldr	r3, [r4, #0]
 80a2d9e:	4620      	mov	r0, r4
 80a2da0:	689b      	ldr	r3, [r3, #8]
 80a2da2:	4798      	blx	r3
          if (--_M_weak_count == 0)
 80a2da4:	68a3      	ldr	r3, [r4, #8]
 80a2da6:	3b01      	subs	r3, #1
 80a2da8:	60a3      	str	r3, [r4, #8]
 80a2daa:	b91b      	cbnz	r3, 80a2db4 <_ZN9TCPClientD1Ev+0x2c>
            _M_destroy();
 80a2dac:	6823      	ldr	r3, [r4, #0]
 80a2dae:	4620      	mov	r0, r4
 80a2db0:	68db      	ldr	r3, [r3, #12]
 80a2db2:	4798      	blx	r3
 80a2db4:	4628      	mov	r0, r5
 80a2db6:	bd38      	pop	{r3, r4, r5, pc}
 80a2db8:	080a6b68 	.word	0x080a6b68

080a2dbc <_ZN9TCPClientD0Ev>:
 80a2dbc:	b510      	push	{r4, lr}
 80a2dbe:	4604      	mov	r4, r0
 80a2dc0:	f7ff ffe2 	bl	80a2d88 <_ZN9TCPClientD1Ev>
 80a2dc4:	4620      	mov	r0, r4
 80a2dc6:	f7fd f96c 	bl	80a00a2 <_ZdlPv>
 80a2dca:	4620      	mov	r0, r4
 80a2dcc:	bd10      	pop	{r4, pc}

080a2dce <_ZN4MQTT10initializeEPcPhtiPFvS0_S1_jEi>:

    if (buffer != NULL)
      delete[] buffer;
}

void MQTT::initialize(char* domain, uint8_t *ip, uint16_t port, int keepalive, void (*callback)(char*,uint8_t*,unsigned int), int maxpacketsize) {
 80a2dce:	b538      	push	{r3, r4, r5, lr}
 80a2dd0:	461d      	mov	r5, r3
    this->callback = callback;
 80a2dd2:	9b05      	ldr	r3, [sp, #20]

    if (buffer != NULL)
      delete[] buffer;
}

void MQTT::initialize(char* domain, uint8_t *ip, uint16_t port, int keepalive, void (*callback)(char*,uint8_t*,unsigned int), int maxpacketsize) {
 80a2dd4:	4604      	mov	r4, r0
    this->callback = callback;
 80a2dd6:	6303      	str	r3, [r0, #48]	; 0x30
    this->qoscallback = NULL;
 80a2dd8:	2300      	movs	r3, #0
 80a2dda:	6343      	str	r3, [r0, #52]	; 0x34
    if (ip != NULL)
 80a2ddc:	b102      	cbz	r2, 80a2de0 <_ZN4MQTT10initializeEPcPhtiPFvS0_S1_jEi+0x12>
        this->ip = ip;
 80a2dde:	6482      	str	r2, [r0, #72]	; 0x48
    if (domain != NULL)
 80a2de0:	b119      	cbz	r1, 80a2dea <_ZN4MQTT10initializeEPcPhtiPFvS0_S1_jEi+0x1c>
        this->domain = domain;
 80a2de2:	f104 0038 	add.w	r0, r4, #56	; 0x38
 80a2de6:	f002 f80e 	bl	80a4e06 <_ZN6StringaSEPKc>
    this->port = port;
    this->keepalive = keepalive;
 80a2dea:	9b04      	ldr	r3, [sp, #16]

    // if maxpacketsize is over MQTT_MAX_PACKET_SIZE.
    this->maxpacketsize = (maxpacketsize <= MQTT_MAX_PACKET_SIZE ? MQTT_MAX_PACKET_SIZE : maxpacketsize);
    if (buffer != NULL)
 80a2dec:	69e0      	ldr	r0, [r4, #28]
    if (ip != NULL)
        this->ip = ip;
    if (domain != NULL)
        this->domain = domain;
    this->port = port;
    this->keepalive = keepalive;
 80a2dee:	6523      	str	r3, [r4, #80]	; 0x50

    // if maxpacketsize is over MQTT_MAX_PACKET_SIZE.
    this->maxpacketsize = (maxpacketsize <= MQTT_MAX_PACKET_SIZE ? MQTT_MAX_PACKET_SIZE : maxpacketsize);
 80a2df0:	9b06      	ldr	r3, [sp, #24]
    this->qoscallback = NULL;
    if (ip != NULL)
        this->ip = ip;
    if (domain != NULL)
        this->domain = domain;
    this->port = port;
 80a2df2:	f8a4 504c 	strh.w	r5, [r4, #76]	; 0x4c
    this->keepalive = keepalive;

    // if maxpacketsize is over MQTT_MAX_PACKET_SIZE.
    this->maxpacketsize = (maxpacketsize <= MQTT_MAX_PACKET_SIZE ? MQTT_MAX_PACKET_SIZE : maxpacketsize);
 80a2df6:	f5b3 6f80 	cmp.w	r3, #1024	; 0x400
 80a2dfa:	bfb8      	it	lt
 80a2dfc:	f44f 6380 	movlt.w	r3, #1024	; 0x400
 80a2e00:	f8a4 3054 	strh.w	r3, [r4, #84]	; 0x54
    if (buffer != NULL)
 80a2e04:	b108      	cbz	r0, 80a2e0a <_ZN4MQTT10initializeEPcPhtiPFvS0_S1_jEi+0x3c>
      delete[] buffer;
 80a2e06:	f7fd f94e 	bl	80a00a6 <_ZdaPv>
    buffer = new uint8_t[this->maxpacketsize];
 80a2e0a:	f8b4 0054 	ldrh.w	r0, [r4, #84]	; 0x54
 80a2e0e:	f7fd f946 	bl	80a009e <_Znaj>
 80a2e12:	61e0      	str	r0, [r4, #28]
 80a2e14:	bd38      	pop	{r3, r4, r5, pc}
	...

080a2e18 <_ZN4MQTTC1EPctPFvS0_PhjE>:
#define MQTTQOS2_HEADER_MASK        (2 << 1)

#define DUP_FLAG_OFF_MASK           (0<<3)
#define DUP_FLAG_ON_MASK            (1<<3)

MQTT::MQTT(char* domain, uint16_t port, void (*callback)(char*,uint8_t*,unsigned int)) {
 80a2e18:	e92d 41ff 	stmdb	sp!, {r0, r1, r2, r3, r4, r5, r6, r7, r8, lr}
 80a2e1c:	4604      	mov	r4, r0
 80a2e1e:	4617      	mov	r7, r2
 80a2e20:	4698      	mov	r8, r3
 80a2e22:	460e      	mov	r6, r1
 80a2e24:	2500      	movs	r5, #0
 80a2e26:	f001 fe1b 	bl	80a4a60 <_ZN9TCPClientC1Ev>
 80a2e2a:	61e5      	str	r5, [r4, #28]
 80a2e2c:	490b      	ldr	r1, [pc, #44]	; (80a2e5c <_ZN4MQTTC1EPctPFvS0_PhjE+0x44>)
 80a2e2e:	f104 0038 	add.w	r0, r4, #56	; 0x38
 80a2e32:	f001 ffd5 	bl	80a4de0 <_ZN6StringC1EPK19__FlashStringHelper>
    this->initialize(domain, NULL, port, MQTT_DEFAULT_KEEPALIVE, callback, MQTT_MAX_PACKET_SIZE);
 80a2e36:	f44f 6380 	mov.w	r3, #1024	; 0x400
 80a2e3a:	9302      	str	r3, [sp, #8]
 80a2e3c:	230f      	movs	r3, #15
 80a2e3e:	9300      	str	r3, [sp, #0]
 80a2e40:	4620      	mov	r0, r4
#define MQTTQOS2_HEADER_MASK        (2 << 1)

#define DUP_FLAG_OFF_MASK           (0<<3)
#define DUP_FLAG_ON_MASK            (1<<3)

MQTT::MQTT(char* domain, uint16_t port, void (*callback)(char*,uint8_t*,unsigned int)) {
 80a2e42:	64a5      	str	r5, [r4, #72]	; 0x48
    this->initialize(domain, NULL, port, MQTT_DEFAULT_KEEPALIVE, callback, MQTT_MAX_PACKET_SIZE);
 80a2e44:	f8cd 8004 	str.w	r8, [sp, #4]
 80a2e48:	463b      	mov	r3, r7
 80a2e4a:	462a      	mov	r2, r5
 80a2e4c:	4631      	mov	r1, r6
 80a2e4e:	f7ff ffbe 	bl	80a2dce <_ZN4MQTT10initializeEPcPhtiPFvS0_S1_jEi>
}
 80a2e52:	4620      	mov	r0, r4
 80a2e54:	b004      	add	sp, #16
 80a2e56:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80a2e5a:	bf00      	nop
 80a2e5c:	080a6a47 	.word	0x080a6a47

080a2e60 <_ZN4MQTT8readByteEv>:
        _client.stop();
    }
    return false;
}

uint8_t MQTT::readByte() {
 80a2e60:	b510      	push	{r4, lr}
 80a2e62:	4604      	mov	r4, r0
    while(!_client.available()) {}
 80a2e64:	4620      	mov	r0, r4
 80a2e66:	f001 fd6b 	bl	80a4940 <_ZN9TCPClient9availableEv>
 80a2e6a:	2800      	cmp	r0, #0
 80a2e6c:	d0fa      	beq.n	80a2e64 <_ZN4MQTT8readByteEv+0x4>
    return _client.read();
 80a2e6e:	4620      	mov	r0, r4
 80a2e70:	f001 fd0d 	bl	80a488e <_ZN9TCPClient4readEv>
}
 80a2e74:	b2c0      	uxtb	r0, r0
 80a2e76:	bd10      	pop	{r4, pc}

080a2e78 <_ZN4MQTT10readPacketEPh>:

uint16_t MQTT::readPacket(uint8_t* lengthLength) {
 80a2e78:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80a2e7c:	4605      	mov	r5, r0
    uint16_t len = 0;
    buffer[len++] = readByte();
 80a2e7e:	69c4      	ldr	r4, [r0, #28]
uint8_t MQTT::readByte() {
    while(!_client.available()) {}
    return _client.read();
}

uint16_t MQTT::readPacket(uint8_t* lengthLength) {
 80a2e80:	468a      	mov	sl, r1
    uint16_t len = 0;
    buffer[len++] = readByte();
 80a2e82:	f7ff ffed 	bl	80a2e60 <_ZN4MQTT8readByteEv>
    bool isPublish = (buffer[0]&0xF0) == MQTTPUBLISH;
    uint32_t multiplier = 1;
 80a2e86:	f04f 0801 	mov.w	r8, #1
    return _client.read();
}

uint16_t MQTT::readPacket(uint8_t* lengthLength) {
    uint16_t len = 0;
    buffer[len++] = readByte();
 80a2e8a:	4646      	mov	r6, r8
 80a2e8c:	7020      	strb	r0, [r4, #0]
    bool isPublish = (buffer[0]&0xF0) == MQTTPUBLISH;
 80a2e8e:	69eb      	ldr	r3, [r5, #28]
    uint32_t multiplier = 1;
    uint16_t length = 0;
 80a2e90:	2700      	movs	r7, #0
 80a2e92:	f893 9000 	ldrb.w	r9, [r3]
 80a2e96:	f009 09f0 	and.w	r9, r9, #240	; 0xf0
    uint8_t digit = 0;
    uint16_t skip = 0;
    uint8_t start = 0;

    do {
        digit = readByte();
 80a2e9a:	4628      	mov	r0, r5
 80a2e9c:	f7ff ffe0 	bl	80a2e60 <_ZN4MQTT8readByteEv>
        buffer[len++] = digit;
 80a2ea0:	69eb      	ldr	r3, [r5, #28]
 80a2ea2:	1c74      	adds	r4, r6, #1
 80a2ea4:	5598      	strb	r0, [r3, r6]
        length += (digit & 127) * multiplier;
 80a2ea6:	f000 037f 	and.w	r3, r0, #127	; 0x7f
 80a2eaa:	fb03 7708 	mla	r7, r3, r8, r7
        multiplier *= 128;
    } while ((digit & 128) != 0);
 80a2eae:	0603      	lsls	r3, r0, #24
    uint16_t skip = 0;
    uint8_t start = 0;

    do {
        digit = readByte();
        buffer[len++] = digit;
 80a2eb0:	b2a4      	uxth	r4, r4
        length += (digit & 127) * multiplier;
 80a2eb2:	b2bf      	uxth	r7, r7
        multiplier *= 128;
 80a2eb4:	ea4f 18c8 	mov.w	r8, r8, lsl #7
    } while ((digit & 128) != 0);
 80a2eb8:	d501      	bpl.n	80a2ebe <_ZN4MQTT10readPacketEPh+0x46>
    uint16_t skip = 0;
    uint8_t start = 0;

    do {
        digit = readByte();
        buffer[len++] = digit;
 80a2eba:	4626      	mov	r6, r4
 80a2ebc:	e7ed      	b.n	80a2e9a <_ZN4MQTT10readPacketEPh+0x22>
        length += (digit & 127) * multiplier;
        multiplier *= 128;
    } while ((digit & 128) != 0);
    *lengthLength = len-1;
 80a2ebe:	1e63      	subs	r3, r4, #1

    if (isPublish) {
 80a2ec0:	f1b9 0f30 	cmp.w	r9, #48	; 0x30
        digit = readByte();
        buffer[len++] = digit;
        length += (digit & 127) * multiplier;
        multiplier *= 128;
    } while ((digit & 128) != 0);
    *lengthLength = len-1;
 80a2ec4:	f88a 3000 	strb.w	r3, [sl]

    if (isPublish) {
 80a2ec8:	d113      	bne.n	80a2ef2 <_ZN4MQTT10readPacketEPh+0x7a>
        // Read in topic length to calculate bytes to skip over for Stream writing
        buffer[len++] = readByte();
 80a2eca:	4628      	mov	r0, r5
 80a2ecc:	f8d5 801c 	ldr.w	r8, [r5, #28]
 80a2ed0:	f7ff ffc6 	bl	80a2e60 <_ZN4MQTT8readByteEv>
 80a2ed4:	f808 0004 	strb.w	r0, [r8, r4]
        buffer[len++] = readByte();
 80a2ed8:	4628      	mov	r0, r5
 80a2eda:	f8d5 801c 	ldr.w	r8, [r5, #28]
 80a2ede:	f7ff ffbf 	bl	80a2e60 <_ZN4MQTT8readByteEv>
 80a2ee2:	1cf4      	adds	r4, r6, #3
 80a2ee4:	3602      	adds	r6, #2
 80a2ee6:	b2b6      	uxth	r6, r6
 80a2ee8:	b2a4      	uxth	r4, r4
 80a2eea:	f808 0006 	strb.w	r0, [r8, r6]
        skip = (buffer[*lengthLength+1]<<8)+buffer[*lengthLength+2];
        start = 2;
 80a2eee:	2302      	movs	r3, #2
 80a2ef0:	e000      	b.n	80a2ef4 <_ZN4MQTT10readPacketEPh+0x7c>
    bool isPublish = (buffer[0]&0xF0) == MQTTPUBLISH;
    uint32_t multiplier = 1;
    uint16_t length = 0;
    uint8_t digit = 0;
    uint16_t skip = 0;
    uint8_t start = 0;
 80a2ef2:	2300      	movs	r3, #0
 80a2ef4:	1b1b      	subs	r3, r3, r4
 80a2ef6:	b29e      	uxth	r6, r3
            // skip message id
            skip += 2;
        }
    }

    for (uint16_t i = start;i<length;i++) {
 80a2ef8:	19a3      	adds	r3, r4, r6
 80a2efa:	b29b      	uxth	r3, r3
 80a2efc:	429f      	cmp	r7, r3
 80a2efe:	d90b      	bls.n	80a2f18 <_ZN4MQTT10readPacketEPh+0xa0>
        digit = readByte();
 80a2f00:	4628      	mov	r0, r5
 80a2f02:	f7ff ffad 	bl	80a2e60 <_ZN4MQTT8readByteEv>
        if (len < this->maxpacketsize) {
 80a2f06:	f8b5 3054 	ldrh.w	r3, [r5, #84]	; 0x54
 80a2f0a:	42a3      	cmp	r3, r4
            buffer[len] = digit;
 80a2f0c:	bf84      	itt	hi
 80a2f0e:	69eb      	ldrhi	r3, [r5, #28]
 80a2f10:	5518      	strbhi	r0, [r3, r4]
        }
        len++;
 80a2f12:	3401      	adds	r4, #1
 80a2f14:	b2a4      	uxth	r4, r4
            // skip message id
            skip += 2;
        }
    }

    for (uint16_t i = start;i<length;i++) {
 80a2f16:	e7ef      	b.n	80a2ef8 <_ZN4MQTT10readPacketEPh+0x80>
            buffer[len] = digit;
        }
        len++;
    }

    if (len > this->maxpacketsize) {
 80a2f18:	f8b5 0054 	ldrh.w	r0, [r5, #84]	; 0x54
        len = 0; // This will cause the packet to be ignored.
    }

    return len;
}
 80a2f1c:	42a0      	cmp	r0, r4
 80a2f1e:	bf2c      	ite	cs
 80a2f20:	4620      	movcs	r0, r4
 80a2f22:	2000      	movcc	r0, #0
 80a2f24:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}

080a2f28 <_ZN4MQTT5writeEhPht>:
        return _client.write(buffer, length);
    }
    return false;
}

bool MQTT::write(uint8_t header, uint8_t* buf, uint16_t length) {
 80a2f28:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
 80a2f2a:	4607      	mov	r7, r0
 80a2f2c:	468e      	mov	lr, r1
 80a2f2e:	461e      	mov	r6, r3
    uint8_t lenBuf[4];
    uint8_t llen = 0;
    uint8_t digit;
    uint8_t pos = 0;
    uint16_t rc;
    uint16_t len = length;
 80a2f30:	461d      	mov	r5, r3
    return false;
}

bool MQTT::write(uint8_t header, uint8_t* buf, uint16_t length) {
    uint8_t lenBuf[4];
    uint8_t llen = 0;
 80a2f32:	2400      	movs	r4, #0
    uint8_t digit;
    uint8_t pos = 0;
    uint16_t rc;
    uint16_t len = length;
    do {
        digit = len % 128;
 80a2f34:	f005 037f 	and.w	r3, r5, #127	; 0x7f
        len = len / 128;
        if (len > 0) {
            digit |= 0x80;
        }
        lenBuf[pos++] = digit;
 80a2f38:	a902      	add	r1, sp, #8
    uint16_t rc;
    uint16_t len = length;
    do {
        digit = len % 128;
        len = len / 128;
        if (len > 0) {
 80a2f3a:	09ed      	lsrs	r5, r5, #7
            digit |= 0x80;
        }
        lenBuf[pos++] = digit;
 80a2f3c:	4421      	add	r1, r4
    uint16_t len = length;
    do {
        digit = len % 128;
        len = len / 128;
        if (len > 0) {
            digit |= 0x80;
 80a2f3e:	bf18      	it	ne
 80a2f40:	f043 0380 	orrne.w	r3, r3, #128	; 0x80
        }
        lenBuf[pos++] = digit;
        llen++;
 80a2f44:	3401      	adds	r4, #1
        digit = len % 128;
        len = len / 128;
        if (len > 0) {
            digit |= 0x80;
        }
        lenBuf[pos++] = digit;
 80a2f46:	f801 3c04 	strb.w	r3, [r1, #-4]
        llen++;
 80a2f4a:	b2e4      	uxtb	r4, r4
    } while(len > 0);
 80a2f4c:	2d00      	cmp	r5, #0
 80a2f4e:	d1f1      	bne.n	80a2f34 <_ZN4MQTT5writeEhPht+0xc>

    buf[4-llen] = header;
 80a2f50:	f1c4 0304 	rsb	r3, r4, #4
 80a2f54:	18d1      	adds	r1, r2, r3
 80a2f56:	f802 e003 	strb.w	lr, [r2, r3]
    for (int i = 0; i < llen; i++) {
 80a2f5a:	42a5      	cmp	r5, r4
 80a2f5c:	da06      	bge.n	80a2f6c <_ZN4MQTT5writeEhPht+0x44>
        buf[5-llen+i] = lenBuf[i];
 80a2f5e:	a801      	add	r0, sp, #4
 80a2f60:	1b2b      	subs	r3, r5, r4
 80a2f62:	5c28      	ldrb	r0, [r5, r0]
 80a2f64:	4413      	add	r3, r2
 80a2f66:	7158      	strb	r0, [r3, #5]
        lenBuf[pos++] = digit;
        llen++;
    } while(len > 0);

    buf[4-llen] = header;
    for (int i = 0; i < llen; i++) {
 80a2f68:	3501      	adds	r5, #1
 80a2f6a:	e7f6      	b.n	80a2f5a <_ZN4MQTT5writeEhPht+0x32>
        buf[5-llen+i] = lenBuf[i];
    }
    rc = _client.write(buf+(4-llen), length+1+llen);
 80a2f6c:	1c72      	adds	r2, r6, #1
 80a2f6e:	4422      	add	r2, r4
 80a2f70:	4638      	mov	r0, r7
 80a2f72:	f001 fbfe 	bl	80a4772 <_ZN9TCPClient5writeEPKhj>
 80a2f76:	4605      	mov	r5, r0
#endif

#include "timer_hal.h"
#include "delay_hal.h"

inline system_tick_t millis(void) { return HAL_Timer_Get_Milli_Seconds(); }
 80a2f78:	f000 fcb2 	bl	80a38e0 <HAL_Timer_Get_Milli_Seconds>

    lastOutActivity = millis();
    return (rc == 1+llen+length);
 80a2f7c:	3401      	adds	r4, #1
    for (int i = 0; i < llen; i++) {
        buf[5-llen+i] = lenBuf[i];
    }
    rc = _client.write(buf+(4-llen), length+1+llen);

    lastOutActivity = millis();
 80a2f7e:	6278      	str	r0, [r7, #36]	; 0x24
    return (rc == 1+llen+length);
 80a2f80:	4434      	add	r4, r6
 80a2f82:	b2a8      	uxth	r0, r5
}
 80a2f84:	1a23      	subs	r3, r4, r0
 80a2f86:	4258      	negs	r0, r3
 80a2f88:	4158      	adcs	r0, r3
 80a2f8a:	b003      	add	sp, #12
 80a2f8c:	bdf0      	pop	{r4, r5, r6, r7, pc}

080a2f8e <_ZN4MQTT10disconnectEv>:
        return write(MQTTUNSUBSCRIBE | MQTTQOS1_HEADER_MASK,buffer,length-5);
    }
    return false;
}

void MQTT::disconnect() {
 80a2f8e:	b510      	push	{r4, lr}
 80a2f90:	4604      	mov	r4, r0
    buffer[0] = MQTTDISCONNECT;
 80a2f92:	69c3      	ldr	r3, [r0, #28]
 80a2f94:	22e0      	movs	r2, #224	; 0xe0
 80a2f96:	701a      	strb	r2, [r3, #0]
    buffer[1] = 0;
 80a2f98:	69c3      	ldr	r3, [r0, #28]
 80a2f9a:	2200      	movs	r2, #0
 80a2f9c:	705a      	strb	r2, [r3, #1]
    _client.write(buffer,2);
 80a2f9e:	69c1      	ldr	r1, [r0, #28]
 80a2fa0:	2202      	movs	r2, #2
 80a2fa2:	f001 fbe6 	bl	80a4772 <_ZN9TCPClient5writeEPKhj>
    _client.stop();
 80a2fa6:	4620      	mov	r0, r4
 80a2fa8:	f001 fd08 	bl	80a49bc <_ZN9TCPClient4stopEv>
 80a2fac:	f000 fc98 	bl	80a38e0 <HAL_Timer_Get_Milli_Seconds>
    lastInActivity = lastOutActivity = millis();
 80a2fb0:	6260      	str	r0, [r4, #36]	; 0x24
 80a2fb2:	62a0      	str	r0, [r4, #40]	; 0x28
 80a2fb4:	bd10      	pop	{r4, pc}

080a2fb6 <_ZN4MQTT11writeStringEPKcPht>:
}

uint16_t MQTT::writeString(const char* string, uint8_t* buf, uint16_t pos) {
 80a2fb6:	b5f0      	push	{r4, r5, r6, r7, lr}
    const char* idp = string;
    uint16_t i = 0;
    pos += 2;
 80a2fb8:	460d      	mov	r5, r1
 80a2fba:	3302      	adds	r3, #2
 80a2fbc:	b29b      	uxth	r3, r3
 80a2fbe:	1a6c      	subs	r4, r5, r1
    while (*idp && pos < this->maxpacketsize) {
 80a2fc0:	f815 6b01 	ldrb.w	r6, [r5], #1
 80a2fc4:	b2a4      	uxth	r4, r4
 80a2fc6:	b13e      	cbz	r6, 80a2fd8 <_ZN4MQTT11writeStringEPKcPht+0x22>
 80a2fc8:	f8b0 7054 	ldrh.w	r7, [r0, #84]	; 0x54
 80a2fcc:	429f      	cmp	r7, r3
 80a2fce:	d903      	bls.n	80a2fd8 <_ZN4MQTT11writeStringEPKcPht+0x22>
        buf[pos++] = *idp++;
 80a2fd0:	1c5c      	adds	r4, r3, #1
 80a2fd2:	54d6      	strb	r6, [r2, r3]
 80a2fd4:	b2a3      	uxth	r3, r4

uint16_t MQTT::writeString(const char* string, uint8_t* buf, uint16_t pos) {
    const char* idp = string;
    uint16_t i = 0;
    pos += 2;
    while (*idp && pos < this->maxpacketsize) {
 80a2fd6:	e7f2      	b.n	80a2fbe <_ZN4MQTT11writeStringEPKcPht+0x8>
        buf[pos++] = *idp++;
        i++;
    }
    buf[pos-i-2] = (i >> 8);
 80a2fd8:	1b19      	subs	r1, r3, r4
 80a2fda:	440a      	add	r2, r1
 80a2fdc:	1221      	asrs	r1, r4, #8
 80a2fde:	f802 1c02 	strb.w	r1, [r2, #-2]
    buf[pos-i-1] = (i & 0xFF);
 80a2fe2:	f802 4c01 	strb.w	r4, [r2, #-1]
    return pos;
}
 80a2fe6:	4618      	mov	r0, r3
 80a2fe8:	bdf0      	pop	{r4, r5, r6, r7, pc}

080a2fea <_ZN4MQTT11isConnectedEv>:


bool MQTT::isConnected() {
 80a2fea:	b538      	push	{r3, r4, r5, lr}
 80a2fec:	4605      	mov	r5, r0
    bool rc = (int)_client.connected();
 80a2fee:	f001 fde9 	bl	80a4bc4 <_ZN9TCPClient9connectedEv>
 80a2ff2:	2800      	cmp	r0, #0
 80a2ff4:	bf14      	ite	ne
 80a2ff6:	2401      	movne	r4, #1
 80a2ff8:	2400      	moveq	r4, #0
    if (!rc) _client.stop();
 80a2ffa:	d102      	bne.n	80a3002 <_ZN4MQTT11isConnectedEv+0x18>
 80a2ffc:	4628      	mov	r0, r5
 80a2ffe:	f001 fcdd 	bl	80a49bc <_ZN9TCPClient4stopEv>
    return rc;
}
 80a3002:	4620      	mov	r0, r4
 80a3004:	bd38      	pop	{r3, r4, r5, pc}
	...

080a3008 <_ZN4MQTT7connectEPKcS1_S1_S1_NS_9EMQTT_QOSEhS1_bNS_12MQTT_VERSIONE>:

bool MQTT::connect(const char *id, const char *user, const char *pass) {
    return connect(id, user, pass, 0, QOS0, 0, 0, true);
}

bool MQTT::connect(const char *id, const char *user, const char *pass, const char* willTopic, EMQTT_QOS willQos, uint8_t willRetain, const char* willMessage, bool cleanSession, MQTT_VERSION version) {
 80a3008:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 80a300c:	b087      	sub	sp, #28
 80a300e:	4604      	mov	r4, r0
 80a3010:	4689      	mov	r9, r1
 80a3012:	4617      	mov	r7, r2
 80a3014:	461e      	mov	r6, r3
 80a3016:	f8dd 8038 	ldr.w	r8, [sp, #56]	; 0x38
    if (!isConnected()) {
 80a301a:	f7ff ffe6 	bl	80a2fea <_ZN4MQTT11isConnectedEv>
 80a301e:	4605      	mov	r5, r0
 80a3020:	2800      	cmp	r0, #0
 80a3022:	f040 80bd 	bne.w	80a31a0 <_ZN4MQTT7connectEPKcS1_S1_S1_NS_9EMQTT_QOSEhS1_bNS_12MQTT_VERSIONE+0x198>
        int result = 0;
        if (ip == NULL)
 80a3026:	6ca1      	ldr	r1, [r4, #72]	; 0x48
 80a3028:	b939      	cbnz	r1, 80a303a <_ZN4MQTT7connectEPKcS1_S1_S1_NS_9EMQTT_QOSEhS1_bNS_12MQTT_VERSIONE+0x32>
            result = _client.connect(this->domain.c_str(), this->port);
 80a302a:	4603      	mov	r3, r0
 80a302c:	f8b4 204c 	ldrh.w	r2, [r4, #76]	; 0x4c
 80a3030:	6ba1      	ldr	r1, [r4, #56]	; 0x38
 80a3032:	4620      	mov	r0, r4
 80a3034:	f001 fbbe 	bl	80a47b4 <_ZN9TCPClient7connectEPKctm>
 80a3038:	e009      	b.n	80a304e <_ZN4MQTT7connectEPKcS1_S1_S1_NS_9EMQTT_QOSEhS1_bNS_12MQTT_VERSIONE+0x46>
        else
            result = _client.connect(this->ip, this->port);
 80a303a:	4668      	mov	r0, sp
 80a303c:	f000 ff00 	bl	80a3e40 <_ZN9IPAddressC1EPKh>
 80a3040:	462b      	mov	r3, r5
 80a3042:	f8b4 204c 	ldrh.w	r2, [r4, #76]	; 0x4c
 80a3046:	4669      	mov	r1, sp
 80a3048:	4620      	mov	r0, r4
 80a304a:	f001 fd13 	bl	80a4a74 <_ZN9TCPClient7connectE9IPAddresstm>

        if (result) {
 80a304e:	2800      	cmp	r0, #0
 80a3050:	f000 80a2 	beq.w	80a3198 <_ZN4MQTT7connectEPKcS1_S1_S1_NS_9EMQTT_QOSEhS1_bNS_12MQTT_VERSIONE+0x190>
            nextMsgId = 1;
 80a3054:	2301      	movs	r3, #1
 80a3056:	8423      	strh	r3, [r4, #32]
            uint16_t length = 5;

            if (version == MQTT_V311) {
 80a3058:	f89d 304c 	ldrb.w	r3, [sp, #76]	; 0x4c
 80a305c:	2b04      	cmp	r3, #4
 80a305e:	d115      	bne.n	80a308c <_ZN4MQTT7connectEPKcS1_S1_S1_NS_9EMQTT_QOSEhS1_bNS_12MQTT_VERSIONE+0x84>
                const uint8_t MQTT_HEADER_V311[] = {0x00,0x04,'M','Q','T','T',MQTT_V311};
 80a3060:	4b52      	ldr	r3, [pc, #328]	; (80a31ac <_ZN4MQTT7connectEPKcS1_S1_S1_NS_9EMQTT_QOSEhS1_bNS_12MQTT_VERSIONE+0x1a4>)
 80a3062:	6818      	ldr	r0, [r3, #0]
 80a3064:	889a      	ldrh	r2, [r3, #4]
 80a3066:	9000      	str	r0, [sp, #0]
 80a3068:	f8ad 2004 	strh.w	r2, [sp, #4]
 80a306c:	799b      	ldrb	r3, [r3, #6]
                memcpy(buffer + length, MQTT_HEADER_V311, sizeof(MQTT_HEADER_V311));
 80a306e:	69e2      	ldr	r2, [r4, #28]
 80a3070:	9800      	ldr	r0, [sp, #0]
        if (result) {
            nextMsgId = 1;
            uint16_t length = 5;

            if (version == MQTT_V311) {
                const uint8_t MQTT_HEADER_V311[] = {0x00,0x04,'M','Q','T','T',MQTT_V311};
 80a3072:	f88d 3006 	strb.w	r3, [sp, #6]
                memcpy(buffer + length, MQTT_HEADER_V311, sizeof(MQTT_HEADER_V311));
 80a3076:	f8c2 0005 	str.w	r0, [r2, #5]
 80a307a:	1d53      	adds	r3, r2, #5
 80a307c:	f8bd 1004 	ldrh.w	r1, [sp, #4]
 80a3080:	f89d 2006 	ldrb.w	r2, [sp, #6]
 80a3084:	8099      	strh	r1, [r3, #4]
 80a3086:	719a      	strb	r2, [r3, #6]
                length+=sizeof(MQTT_HEADER_V311);
 80a3088:	230c      	movs	r3, #12
 80a308a:	e012      	b.n	80a30b2 <_ZN4MQTT7connectEPKcS1_S1_S1_NS_9EMQTT_QOSEhS1_bNS_12MQTT_VERSIONE+0xaa>
            } else {
                const uint8_t MQTT_HEADER_V31[] = {0x00,0x06,'M','Q','I','s','d','p', MQTT_V31};
 80a308c:	466a      	mov	r2, sp
 80a308e:	4b48      	ldr	r3, [pc, #288]	; (80a31b0 <_ZN4MQTT7connectEPKcS1_S1_S1_NS_9EMQTT_QOSEhS1_bNS_12MQTT_VERSIONE+0x1a8>)
                memcpy(buffer + length, MQTT_HEADER_V31, sizeof(MQTT_HEADER_V31));
 80a3090:	f8d4 c01c 	ldr.w	ip, [r4, #28]
            if (version == MQTT_V311) {
                const uint8_t MQTT_HEADER_V311[] = {0x00,0x04,'M','Q','T','T',MQTT_V311};
                memcpy(buffer + length, MQTT_HEADER_V311, sizeof(MQTT_HEADER_V311));
                length+=sizeof(MQTT_HEADER_V311);
            } else {
                const uint8_t MQTT_HEADER_V31[] = {0x00,0x06,'M','Q','I','s','d','p', MQTT_V31};
 80a3094:	6818      	ldr	r0, [r3, #0]
 80a3096:	6859      	ldr	r1, [r3, #4]
 80a3098:	7a1b      	ldrb	r3, [r3, #8]
 80a309a:	c203      	stmia	r2!, {r0, r1}
 80a309c:	7013      	strb	r3, [r2, #0]
                memcpy(buffer + length, MQTT_HEADER_V31, sizeof(MQTT_HEADER_V31));
 80a309e:	466b      	mov	r3, sp
 80a30a0:	cb03      	ldmia	r3!, {r0, r1}
 80a30a2:	f8cc 0005 	str.w	r0, [ip, #5]
 80a30a6:	f8cc 1009 	str.w	r1, [ip, #9]
 80a30aa:	7813      	ldrb	r3, [r2, #0]
 80a30ac:	f88c 300d 	strb.w	r3, [ip, #13]
                length+=sizeof(MQTT_HEADER_V31);
 80a30b0:	230e      	movs	r3, #14
            }

            uint8_t v = 0;
            if (willTopic) {
 80a30b2:	f1b8 0f00 	cmp.w	r8, #0
 80a30b6:	d00a      	beq.n	80a30ce <_ZN4MQTT7connectEPKcS1_S1_S1_NS_9EMQTT_QOSEhS1_bNS_12MQTT_VERSIONE+0xc6>
                v = 0x06|(willQos<<3)|(willRetain<<5);
 80a30b8:	f89d 2040 	ldrb.w	r2, [sp, #64]	; 0x40
 80a30bc:	f89d 103c 	ldrb.w	r1, [sp, #60]	; 0x3c
 80a30c0:	0152      	lsls	r2, r2, #5
 80a30c2:	f042 0206 	orr.w	r2, r2, #6
 80a30c6:	ea42 02c1 	orr.w	r2, r2, r1, lsl #3
 80a30ca:	b2d2      	uxtb	r2, r2
 80a30cc:	e000      	b.n	80a30d0 <_ZN4MQTT7connectEPKcS1_S1_S1_NS_9EMQTT_QOSEhS1_bNS_12MQTT_VERSIONE+0xc8>
            } else {
                v = 0x02;
 80a30ce:	2202      	movs	r2, #2
            }

            if (!cleanSession) {
 80a30d0:	f89d 1048 	ldrb.w	r1, [sp, #72]	; 0x48
 80a30d4:	b909      	cbnz	r1, 80a30da <_ZN4MQTT7connectEPKcS1_S1_S1_NS_9EMQTT_QOSEhS1_bNS_12MQTT_VERSIONE+0xd2>
              v = v&0xfd;
 80a30d6:	f002 02fd 	and.w	r2, r2, #253	; 0xfd
            }

            if(user != NULL) {
 80a30da:	b12f      	cbz	r7, 80a30e8 <_ZN4MQTT7connectEPKcS1_S1_S1_NS_9EMQTT_QOSEhS1_bNS_12MQTT_VERSIONE+0xe0>
                v = v|0x80;

                if(pass != NULL) {
 80a30dc:	b916      	cbnz	r6, 80a30e4 <_ZN4MQTT7connectEPKcS1_S1_S1_NS_9EMQTT_QOSEhS1_bNS_12MQTT_VERSIONE+0xdc>
            if (!cleanSession) {
              v = v&0xfd;
            }

            if(user != NULL) {
                v = v|0x80;
 80a30de:	f042 0280 	orr.w	r2, r2, #128	; 0x80
 80a30e2:	e001      	b.n	80a30e8 <_ZN4MQTT7connectEPKcS1_S1_S1_NS_9EMQTT_QOSEhS1_bNS_12MQTT_VERSIONE+0xe0>

                if(pass != NULL) {
                    v = v|(0x80>>1);
 80a30e4:	f042 02c0 	orr.w	r2, r2, #192	; 0xc0
                }
            }

            buffer[length++] = v;
 80a30e8:	69e1      	ldr	r1, [r4, #28]

            buffer[length++] = ((this->keepalive) >> 8);
 80a30ea:	1c58      	adds	r0, r3, #1
                if(pass != NULL) {
                    v = v|(0x80>>1);
                }
            }

            buffer[length++] = v;
 80a30ec:	54ca      	strb	r2, [r1, r3]

            buffer[length++] = ((this->keepalive) >> 8);
 80a30ee:	6d22      	ldr	r2, [r4, #80]	; 0x50
 80a30f0:	69e1      	ldr	r1, [r4, #28]
 80a30f2:	1212      	asrs	r2, r2, #8
 80a30f4:	540a      	strb	r2, [r1, r0]
            buffer[length++] = ((this->keepalive) & 0xFF);
 80a30f6:	69e1      	ldr	r1, [r4, #28]
 80a30f8:	6d20      	ldr	r0, [r4, #80]	; 0x50
 80a30fa:	1c9a      	adds	r2, r3, #2
 80a30fc:	5488      	strb	r0, [r1, r2]
            length = writeString(id, buffer, length);
 80a30fe:	3303      	adds	r3, #3
 80a3100:	69e2      	ldr	r2, [r4, #28]
 80a3102:	4649      	mov	r1, r9
 80a3104:	4620      	mov	r0, r4
 80a3106:	f7ff ff56 	bl	80a2fb6 <_ZN4MQTT11writeStringEPKcPht>
            if (willTopic) {
 80a310a:	f1b8 0f00 	cmp.w	r8, #0
 80a310e:	d00b      	beq.n	80a3128 <_ZN4MQTT7connectEPKcS1_S1_S1_NS_9EMQTT_QOSEhS1_bNS_12MQTT_VERSIONE+0x120>
                length = writeString(willTopic, buffer, length);
 80a3110:	4603      	mov	r3, r0
 80a3112:	69e2      	ldr	r2, [r4, #28]
 80a3114:	4641      	mov	r1, r8
 80a3116:	4620      	mov	r0, r4
 80a3118:	f7ff ff4d 	bl	80a2fb6 <_ZN4MQTT11writeStringEPKcPht>
                length = writeString(willMessage, buffer, length);
 80a311c:	69e2      	ldr	r2, [r4, #28]
 80a311e:	4603      	mov	r3, r0
 80a3120:	9911      	ldr	r1, [sp, #68]	; 0x44
 80a3122:	4620      	mov	r0, r4
 80a3124:	f7ff ff47 	bl	80a2fb6 <_ZN4MQTT11writeStringEPKcPht>
            }

            if(user != NULL) {
 80a3128:	b167      	cbz	r7, 80a3144 <_ZN4MQTT7connectEPKcS1_S1_S1_NS_9EMQTT_QOSEhS1_bNS_12MQTT_VERSIONE+0x13c>
                length = writeString(user,buffer,length);
 80a312a:	4603      	mov	r3, r0
 80a312c:	69e2      	ldr	r2, [r4, #28]
 80a312e:	4639      	mov	r1, r7
 80a3130:	4620      	mov	r0, r4
 80a3132:	f7ff ff40 	bl	80a2fb6 <_ZN4MQTT11writeStringEPKcPht>
                if(pass != NULL) {
 80a3136:	b12e      	cbz	r6, 80a3144 <_ZN4MQTT7connectEPKcS1_S1_S1_NS_9EMQTT_QOSEhS1_bNS_12MQTT_VERSIONE+0x13c>
                    length = writeString(pass,buffer,length);
 80a3138:	4603      	mov	r3, r0
 80a313a:	69e2      	ldr	r2, [r4, #28]
 80a313c:	4631      	mov	r1, r6
 80a313e:	4620      	mov	r0, r4
 80a3140:	f7ff ff39 	bl	80a2fb6 <_ZN4MQTT11writeStringEPKcPht>
                }
            }

            write(MQTTCONNECT, buffer, length-5);
 80a3144:	1f43      	subs	r3, r0, #5
 80a3146:	b29b      	uxth	r3, r3
 80a3148:	69e2      	ldr	r2, [r4, #28]
 80a314a:	2110      	movs	r1, #16
 80a314c:	4620      	mov	r0, r4
 80a314e:	f7ff feeb 	bl	80a2f28 <_ZN4MQTT5writeEhPht>
 80a3152:	f000 fbc5 	bl	80a38e0 <HAL_Timer_Get_Milli_Seconds>
            lastInActivity = lastOutActivity = millis();

            while (!_client.available()) {
                unsigned long t = millis();
                if (t-lastInActivity > this->keepalive*1000UL) {
 80a3156:	f44f 767a 	mov.w	r6, #1000	; 0x3e8
                    length = writeString(pass,buffer,length);
                }
            }

            write(MQTTCONNECT, buffer, length-5);
            lastInActivity = lastOutActivity = millis();
 80a315a:	6260      	str	r0, [r4, #36]	; 0x24
 80a315c:	62a0      	str	r0, [r4, #40]	; 0x28

            while (!_client.available()) {
 80a315e:	4620      	mov	r0, r4
 80a3160:	f001 fbee 	bl	80a4940 <_ZN9TCPClient9availableEv>
 80a3164:	b940      	cbnz	r0, 80a3178 <_ZN4MQTT7connectEPKcS1_S1_S1_NS_9EMQTT_QOSEhS1_bNS_12MQTT_VERSIONE+0x170>
 80a3166:	f000 fbbb 	bl	80a38e0 <HAL_Timer_Get_Milli_Seconds>
                unsigned long t = millis();
                if (t-lastInActivity > this->keepalive*1000UL) {
 80a316a:	6aa3      	ldr	r3, [r4, #40]	; 0x28
 80a316c:	1ac0      	subs	r0, r0, r3
 80a316e:	6d23      	ldr	r3, [r4, #80]	; 0x50
 80a3170:	4373      	muls	r3, r6
 80a3172:	4298      	cmp	r0, r3
 80a3174:	d9f3      	bls.n	80a315e <_ZN4MQTT7connectEPKcS1_S1_S1_NS_9EMQTT_QOSEhS1_bNS_12MQTT_VERSIONE+0x156>
 80a3176:	e00f      	b.n	80a3198 <_ZN4MQTT7connectEPKcS1_S1_S1_NS_9EMQTT_QOSEhS1_bNS_12MQTT_VERSIONE+0x190>
                    _client.stop();
                    return false;
                }
            }
            uint8_t llen;
            uint16_t len = readPacket(&llen);
 80a3178:	4669      	mov	r1, sp
 80a317a:	4620      	mov	r0, r4
 80a317c:	f7ff fe7c 	bl	80a2e78 <_ZN4MQTT10readPacketEPh>

            if (len == 4) {
 80a3180:	2804      	cmp	r0, #4
 80a3182:	d109      	bne.n	80a3198 <_ZN4MQTT7connectEPKcS1_S1_S1_NS_9EMQTT_QOSEhS1_bNS_12MQTT_VERSIONE+0x190>
                if (buffer[3] == CONN_ACCEPT) {
 80a3184:	69e3      	ldr	r3, [r4, #28]
 80a3186:	78de      	ldrb	r6, [r3, #3]
 80a3188:	b936      	cbnz	r6, 80a3198 <_ZN4MQTT7connectEPKcS1_S1_S1_NS_9EMQTT_QOSEhS1_bNS_12MQTT_VERSIONE+0x190>
 80a318a:	f000 fba9 	bl	80a38e0 <HAL_Timer_Get_Milli_Seconds>
                    lastInActivity = millis();
                    pingOutstanding = false;
                    debug_print(" Connect success\n");
                    return true;
 80a318e:	2501      	movs	r5, #1
            uint8_t llen;
            uint16_t len = readPacket(&llen);

            if (len == 4) {
                if (buffer[3] == CONN_ACCEPT) {
                    lastInActivity = millis();
 80a3190:	62a0      	str	r0, [r4, #40]	; 0x28
                    pingOutstanding = false;
 80a3192:	f884 602c 	strb.w	r6, [r4, #44]	; 0x2c
 80a3196:	e004      	b.n	80a31a2 <_ZN4MQTT7connectEPKcS1_S1_S1_NS_9EMQTT_QOSEhS1_bNS_12MQTT_VERSIONE+0x19a>
                    // check EMQTT_CONNACK_RESPONSE code.
                    debug_print(" Connect fail. code = [%d]\n", buffer[3]);
                }
            }
        }
        _client.stop();
 80a3198:	4620      	mov	r0, r4
 80a319a:	f001 fc0f 	bl	80a49bc <_ZN9TCPClient4stopEv>
 80a319e:	e000      	b.n	80a31a2 <_ZN4MQTT7connectEPKcS1_S1_S1_NS_9EMQTT_QOSEhS1_bNS_12MQTT_VERSIONE+0x19a>
    }
    return false;
 80a31a0:	2500      	movs	r5, #0
}
 80a31a2:	4628      	mov	r0, r5
 80a31a4:	b007      	add	sp, #28
 80a31a6:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 80a31aa:	bf00      	nop
 80a31ac:	080a695d 	.word	0x080a695d
 80a31b0:	080a6964 	.word	0x080a6964

080a31b4 <_ZN4MQTT7connectEPKcS1_S1_>:

bool MQTT::connect(const char *id) {
    return connect(id, NULL, NULL, 0, QOS0, 0, 0, true);
}

bool MQTT::connect(const char *id, const char *user, const char *pass) {
 80a31b4:	b510      	push	{r4, lr}
    return connect(id, user, pass, 0, QOS0, 0, 0, true);
 80a31b6:	2404      	movs	r4, #4

bool MQTT::connect(const char *id) {
    return connect(id, NULL, NULL, 0, QOS0, 0, 0, true);
}

bool MQTT::connect(const char *id, const char *user, const char *pass) {
 80a31b8:	b086      	sub	sp, #24
    return connect(id, user, pass, 0, QOS0, 0, 0, true);
 80a31ba:	9405      	str	r4, [sp, #20]
 80a31bc:	2401      	movs	r4, #1
 80a31be:	9404      	str	r4, [sp, #16]
 80a31c0:	2400      	movs	r4, #0
 80a31c2:	9403      	str	r4, [sp, #12]
 80a31c4:	9402      	str	r4, [sp, #8]
 80a31c6:	9401      	str	r4, [sp, #4]
 80a31c8:	9400      	str	r4, [sp, #0]
 80a31ca:	f7ff ff1d 	bl	80a3008 <_ZN4MQTT7connectEPKcS1_S1_S1_NS_9EMQTT_QOSEhS1_bNS_12MQTT_VERSIONE>
}
 80a31ce:	b006      	add	sp, #24
 80a31d0:	bd10      	pop	{r4, pc}

080a31d2 <_ZN4MQTT7publishEPKcPKhjbNS_9EMQTT_QOSEbPt>:

bool MQTT::publish(const char* topic, const uint8_t* payload, unsigned int plength, bool retain, EMQTT_QOS qos, uint16_t *messageid) {
    return publish(topic, payload, plength, retain, qos, false, messageid);
}

bool MQTT::publish(const char* topic, const uint8_t* payload, unsigned int plength, bool retain, EMQTT_QOS qos, bool dup, uint16_t *messageid) {
 80a31d2:	e92d 4ff1 	stmdb	sp!, {r0, r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80a31d6:	9e0d      	ldr	r6, [sp, #52]	; 0x34
 80a31d8:	4604      	mov	r4, r0
 80a31da:	468b      	mov	fp, r1
 80a31dc:	4691      	mov	r9, r2
 80a31de:	469a      	mov	sl, r3
 80a31e0:	f89d 8028 	ldrb.w	r8, [sp, #40]	; 0x28
 80a31e4:	f89d 502c 	ldrb.w	r5, [sp, #44]	; 0x2c
 80a31e8:	f89d 7030 	ldrb.w	r7, [sp, #48]	; 0x30
    if (isConnected()) {
 80a31ec:	f7ff fefd 	bl	80a2fea <_ZN4MQTT11isConnectedEv>
 80a31f0:	2800      	cmp	r0, #0
 80a31f2:	d04b      	beq.n	80a328c <_ZN4MQTT7publishEPKcPKhjbNS_9EMQTT_QOSEbPt+0xba>
        // Leave room in the buffer for header and variable length field
        uint16_t length = 5;
        memset(buffer, 0, this->maxpacketsize);
 80a31f4:	f8b4 2054 	ldrh.w	r2, [r4, #84]	; 0x54
 80a31f8:	2100      	movs	r1, #0
 80a31fa:	69e0      	ldr	r0, [r4, #28]
 80a31fc:	f002 ffd1 	bl	80a61a2 <memset>

        length = writeString(topic, buffer, length);
 80a3200:	2305      	movs	r3, #5
 80a3202:	69e2      	ldr	r2, [r4, #28]
 80a3204:	4659      	mov	r1, fp
 80a3206:	4620      	mov	r0, r4
 80a3208:	f7ff fed5 	bl	80a2fb6 <_ZN4MQTT11writeStringEPKcPht>

        if (qos == QOS2 || qos == QOS1) {
 80a320c:	1e6b      	subs	r3, r5, #1
 80a320e:	2b01      	cmp	r3, #1
 80a3210:	d812      	bhi.n	80a3238 <_ZN4MQTT7publishEPKcPKhjbNS_9EMQTT_QOSEbPt+0x66>
            nextMsgId += 1;
 80a3212:	8c23      	ldrh	r3, [r4, #32]
            buffer[length++] = (nextMsgId >> 8);
 80a3214:	69e2      	ldr	r2, [r4, #28]
        memset(buffer, 0, this->maxpacketsize);

        length = writeString(topic, buffer, length);

        if (qos == QOS2 || qos == QOS1) {
            nextMsgId += 1;
 80a3216:	3301      	adds	r3, #1
 80a3218:	b29b      	uxth	r3, r3
 80a321a:	8423      	strh	r3, [r4, #32]
            buffer[length++] = (nextMsgId >> 8);
 80a321c:	121b      	asrs	r3, r3, #8
 80a321e:	5413      	strb	r3, [r2, r0]
 80a3220:	1c41      	adds	r1, r0, #1
            buffer[length++] = (nextMsgId & 0xFF);
 80a3222:	69e3      	ldr	r3, [r4, #28]
 80a3224:	8c22      	ldrh	r2, [r4, #32]

        length = writeString(topic, buffer, length);

        if (qos == QOS2 || qos == QOS1) {
            nextMsgId += 1;
            buffer[length++] = (nextMsgId >> 8);
 80a3226:	b289      	uxth	r1, r1
            buffer[length++] = (nextMsgId & 0xFF);
 80a3228:	3002      	adds	r0, #2
 80a322a:	b280      	uxth	r0, r0
 80a322c:	545a      	strb	r2, [r3, r1]
            if (messageid != NULL)
 80a322e:	b11e      	cbz	r6, 80a3238 <_ZN4MQTT7publishEPKcPKhjbNS_9EMQTT_QOSEbPt+0x66>
                *messageid = nextMsgId++;
 80a3230:	8c23      	ldrh	r3, [r4, #32]
 80a3232:	1c5a      	adds	r2, r3, #1
 80a3234:	8422      	strh	r2, [r4, #32]
 80a3236:	8033      	strh	r3, [r6, #0]

bool MQTT::publish(const char* topic, const uint8_t* payload, unsigned int plength, bool retain, EMQTT_QOS qos, uint16_t *messageid) {
    return publish(topic, payload, plength, retain, qos, false, messageid);
}

bool MQTT::publish(const char* topic, const uint8_t* payload, unsigned int plength, bool retain, EMQTT_QOS qos, bool dup, uint16_t *messageid) {
 80a3238:	2200      	movs	r2, #0
            buffer[length++] = (nextMsgId & 0xFF);
            if (messageid != NULL)
                *messageid = nextMsgId++;
        }

        for (uint16_t i=0; i < plength && length < this->maxpacketsize; i++) {
 80a323a:	b291      	uxth	r1, r2
 80a323c:	1883      	adds	r3, r0, r2
 80a323e:	458a      	cmp	sl, r1
 80a3240:	b29b      	uxth	r3, r3
 80a3242:	d909      	bls.n	80a3258 <_ZN4MQTT7publishEPKcPKhjbNS_9EMQTT_QOSEbPt+0x86>
 80a3244:	f8b4 6054 	ldrh.w	r6, [r4, #84]	; 0x54
 80a3248:	3201      	adds	r2, #1
 80a324a:	429e      	cmp	r6, r3
 80a324c:	d904      	bls.n	80a3258 <_ZN4MQTT7publishEPKcPKhjbNS_9EMQTT_QOSEbPt+0x86>
            buffer[length++] = payload[i];
 80a324e:	f819 6001 	ldrb.w	r6, [r9, r1]
 80a3252:	69e1      	ldr	r1, [r4, #28]
 80a3254:	54ce      	strb	r6, [r1, r3]
 80a3256:	e7f0      	b.n	80a323a <_ZN4MQTT7publishEPKcPKhjbNS_9EMQTT_QOSEbPt+0x68>
        }

        uint8_t header = MQTTPUBLISH;
        if (retain) {
            header |= 1;
 80a3258:	f1b8 0f00 	cmp.w	r8, #0
 80a325c:	bf0c      	ite	eq
 80a325e:	2130      	moveq	r1, #48	; 0x30
 80a3260:	2131      	movne	r1, #49	; 0x31
        }

        if (dup) {
 80a3262:	b10f      	cbz	r7, 80a3268 <_ZN4MQTT7publishEPKcPKhjbNS_9EMQTT_QOSEbPt+0x96>
            header |= DUP_FLAG_ON_MASK;
 80a3264:	f041 0108 	orr.w	r1, r1, #8
        }

        if (qos == QOS2)
 80a3268:	2d02      	cmp	r5, #2
 80a326a:	d102      	bne.n	80a3272 <_ZN4MQTT7publishEPKcPKhjbNS_9EMQTT_QOSEbPt+0xa0>
            header |= MQTTQOS2_HEADER_MASK;
 80a326c:	f041 0104 	orr.w	r1, r1, #4
 80a3270:	e003      	b.n	80a327a <_ZN4MQTT7publishEPKcPKhjbNS_9EMQTT_QOSEbPt+0xa8>
        else if (qos == QOS1)
 80a3272:	2d01      	cmp	r5, #1
            header |= MQTTQOS1_HEADER_MASK;
 80a3274:	bf08      	it	eq
 80a3276:	f041 0102 	orreq.w	r1, r1, #2
        else
            header |= MQTTQOS0_HEADER_MASK;

        return write(header, buffer, length-5);
 80a327a:	4620      	mov	r0, r4
 80a327c:	3b05      	subs	r3, #5
 80a327e:	69e2      	ldr	r2, [r4, #28]
 80a3280:	b29b      	uxth	r3, r3
    }
    return false;
}
 80a3282:	b001      	add	sp, #4
 80a3284:	e8bd 4ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
        else if (qos == QOS1)
            header |= MQTTQOS1_HEADER_MASK;
        else
            header |= MQTTQOS0_HEADER_MASK;

        return write(header, buffer, length-5);
 80a3288:	f7ff be4e 	b.w	80a2f28 <_ZN4MQTT5writeEhPht>
    }
    return false;
}
 80a328c:	b001      	add	sp, #4
 80a328e:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

080a3292 <_ZN4MQTT7publishEPKcPKhjbNS_9EMQTT_QOSEPt>:

bool MQTT::publish(const char* topic, const uint8_t* payload, unsigned int plength, bool retain) {
    return publish(topic, payload, plength, retain, QOS0, NULL);
}

bool MQTT::publish(const char* topic, const uint8_t* payload, unsigned int plength, bool retain, EMQTT_QOS qos, uint16_t *messageid) {
 80a3292:	b51f      	push	{r0, r1, r2, r3, r4, lr}
    return publish(topic, payload, plength, retain, qos, false, messageid);
 80a3294:	9c08      	ldr	r4, [sp, #32]
 80a3296:	9403      	str	r4, [sp, #12]
 80a3298:	2400      	movs	r4, #0
 80a329a:	9402      	str	r4, [sp, #8]
 80a329c:	f89d 401c 	ldrb.w	r4, [sp, #28]
 80a32a0:	9401      	str	r4, [sp, #4]
 80a32a2:	f89d 4018 	ldrb.w	r4, [sp, #24]
 80a32a6:	9400      	str	r4, [sp, #0]
 80a32a8:	f7ff ff93 	bl	80a31d2 <_ZN4MQTT7publishEPKcPKhjbNS_9EMQTT_QOSEbPt>
}
 80a32ac:	b004      	add	sp, #16
 80a32ae:	bd10      	pop	{r4, pc}

080a32b0 <_ZN4MQTT7publishEPKcS1_>:
        return true;
    }
    return false;
}

bool MQTT::publish(const char* topic, const char* payload) {
 80a32b0:	b57f      	push	{r0, r1, r2, r3, r4, r5, r6, lr}
 80a32b2:	4605      	mov	r5, r0
    return publish(topic, (uint8_t*)payload, strlen(payload), false, QOS0, NULL);
 80a32b4:	4610      	mov	r0, r2
        return true;
    }
    return false;
}

bool MQTT::publish(const char* topic, const char* payload) {
 80a32b6:	460e      	mov	r6, r1
 80a32b8:	4614      	mov	r4, r2
    return publish(topic, (uint8_t*)payload, strlen(payload), false, QOS0, NULL);
 80a32ba:	f003 f80a 	bl	80a62d2 <strlen>
 80a32be:	2300      	movs	r3, #0
 80a32c0:	9302      	str	r3, [sp, #8]
 80a32c2:	9301      	str	r3, [sp, #4]
 80a32c4:	9300      	str	r3, [sp, #0]
 80a32c6:	4622      	mov	r2, r4
 80a32c8:	4603      	mov	r3, r0
 80a32ca:	4631      	mov	r1, r6
 80a32cc:	4628      	mov	r0, r5
 80a32ce:	f7ff ffe0 	bl	80a3292 <_ZN4MQTT7publishEPKcPKhjbNS_9EMQTT_QOSEPt>
}
 80a32d2:	b004      	add	sp, #16
 80a32d4:	bd70      	pop	{r4, r5, r6, pc}

080a32d6 <_ZN4MQTT14publishReleaseEt>:
        return write(header, buffer, length-5);
    }
    return false;
}

bool MQTT::publishRelease(uint16_t messageid) {
 80a32d6:	b538      	push	{r3, r4, r5, lr}
 80a32d8:	4604      	mov	r4, r0
 80a32da:	460d      	mov	r5, r1
    if (isConnected()) {
 80a32dc:	f7ff fe85 	bl	80a2fea <_ZN4MQTT11isConnectedEv>
 80a32e0:	b190      	cbz	r0, 80a3308 <_ZN4MQTT14publishReleaseEt+0x32>
        uint16_t length = 0;
        // reserved bits in MQTT v3.1.1
        buffer[length++] = MQTTPUBREL | MQTTQOS1_HEADER_MASK;
 80a32e2:	69e3      	ldr	r3, [r4, #28]
 80a32e4:	2262      	movs	r2, #98	; 0x62
 80a32e6:	701a      	strb	r2, [r3, #0]
        buffer[length++] = 2;
 80a32e8:	69e3      	ldr	r3, [r4, #28]
 80a32ea:	2202      	movs	r2, #2
 80a32ec:	705a      	strb	r2, [r3, #1]
        buffer[length++] = (messageid >> 8);
 80a32ee:	69e3      	ldr	r3, [r4, #28]
 80a32f0:	122a      	asrs	r2, r5, #8
 80a32f2:	709a      	strb	r2, [r3, #2]
        buffer[length++] = (messageid & 0xFF);
 80a32f4:	69e3      	ldr	r3, [r4, #28]
        return _client.write(buffer, length);
 80a32f6:	2204      	movs	r2, #4
        uint16_t length = 0;
        // reserved bits in MQTT v3.1.1
        buffer[length++] = MQTTPUBREL | MQTTQOS1_HEADER_MASK;
        buffer[length++] = 2;
        buffer[length++] = (messageid >> 8);
        buffer[length++] = (messageid & 0xFF);
 80a32f8:	70dd      	strb	r5, [r3, #3]
        return _client.write(buffer, length);
 80a32fa:	69e1      	ldr	r1, [r4, #28]
 80a32fc:	4620      	mov	r0, r4
 80a32fe:	f001 fa38 	bl	80a4772 <_ZN9TCPClient5writeEPKhj>
 80a3302:	3000      	adds	r0, #0
 80a3304:	bf18      	it	ne
 80a3306:	2001      	movne	r0, #1
    }
    return false;
}
 80a3308:	bd38      	pop	{r3, r4, r5, pc}

080a330a <_ZN4MQTT15publishCompleteEt>:

bool MQTT::publishComplete(uint16_t messageid) {
 80a330a:	b538      	push	{r3, r4, r5, lr}
 80a330c:	4604      	mov	r4, r0
 80a330e:	460d      	mov	r5, r1
    if (isConnected()) {
 80a3310:	f7ff fe6b 	bl	80a2fea <_ZN4MQTT11isConnectedEv>
 80a3314:	b190      	cbz	r0, 80a333c <_ZN4MQTT15publishCompleteEt+0x32>
        uint16_t length = 0;
        // reserved bits in MQTT v3.1.1
        buffer[length++] = MQTTPUBCOMP | MQTTQOS1_HEADER_MASK;
 80a3316:	69e3      	ldr	r3, [r4, #28]
 80a3318:	2272      	movs	r2, #114	; 0x72
 80a331a:	701a      	strb	r2, [r3, #0]
        buffer[length++] = 2;
 80a331c:	69e3      	ldr	r3, [r4, #28]
 80a331e:	2202      	movs	r2, #2
 80a3320:	705a      	strb	r2, [r3, #1]
        buffer[length++] = (messageid >> 8);
 80a3322:	69e3      	ldr	r3, [r4, #28]
 80a3324:	122a      	asrs	r2, r5, #8
 80a3326:	709a      	strb	r2, [r3, #2]
        buffer[length++] = (messageid & 0xFF);
 80a3328:	69e3      	ldr	r3, [r4, #28]
        return _client.write(buffer, length);
 80a332a:	2204      	movs	r2, #4
        uint16_t length = 0;
        // reserved bits in MQTT v3.1.1
        buffer[length++] = MQTTPUBCOMP | MQTTQOS1_HEADER_MASK;
        buffer[length++] = 2;
        buffer[length++] = (messageid >> 8);
        buffer[length++] = (messageid & 0xFF);
 80a332c:	70dd      	strb	r5, [r3, #3]
        return _client.write(buffer, length);
 80a332e:	69e1      	ldr	r1, [r4, #28]
 80a3330:	4620      	mov	r0, r4
 80a3332:	f001 fa1e 	bl	80a4772 <_ZN9TCPClient5writeEPKhj>
 80a3336:	3000      	adds	r0, #0
 80a3338:	bf18      	it	ne
 80a333a:	2001      	movne	r0, #1
    }
    return false;
}
 80a333c:	bd38      	pop	{r3, r4, r5, pc}

080a333e <_ZN4MQTT4loopEv>:
    }

    return len;
}

bool MQTT::loop() {
 80a333e:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80a3342:	b083      	sub	sp, #12
 80a3344:	af00      	add	r7, sp, #0
 80a3346:	4604      	mov	r4, r0
    if (isConnected()) {
 80a3348:	f7ff fe4f 	bl	80a2fea <_ZN4MQTT11isConnectedEv>
 80a334c:	4681      	mov	r9, r0
 80a334e:	2800      	cmp	r0, #0
 80a3350:	f000 80f6 	beq.w	80a3540 <_ZN4MQTT4loopEv+0x202>
 80a3354:	f000 fac4 	bl	80a38e0 <HAL_Timer_Get_Milli_Seconds>
        unsigned long t = millis();
        if ((t - lastInActivity > this->keepalive*1000UL) || (t - lastOutActivity > this->keepalive*1000UL)) {
 80a3358:	6d22      	ldr	r2, [r4, #80]	; 0x50
 80a335a:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 80a335e:	4353      	muls	r3, r2
 80a3360:	6aa2      	ldr	r2, [r4, #40]	; 0x28
 80a3362:	4605      	mov	r5, r0
 80a3364:	1a82      	subs	r2, r0, r2
 80a3366:	429a      	cmp	r2, r3
 80a3368:	d803      	bhi.n	80a3372 <_ZN4MQTT4loopEv+0x34>
 80a336a:	6a62      	ldr	r2, [r4, #36]	; 0x24
 80a336c:	1a82      	subs	r2, r0, r2
 80a336e:	4293      	cmp	r3, r2
 80a3370:	d217      	bcs.n	80a33a2 <_ZN4MQTT4loopEv+0x64>
            if (pingOutstanding) {
 80a3372:	f894 302c 	ldrb.w	r3, [r4, #44]	; 0x2c
 80a3376:	b12b      	cbz	r3, 80a3384 <_ZN4MQTT4loopEv+0x46>
                _client.stop();
 80a3378:	4620      	mov	r0, r4
 80a337a:	f001 fb1f 	bl	80a49bc <_ZN9TCPClient4stopEv>
                return false;
 80a337e:	f04f 0900 	mov.w	r9, #0
 80a3382:	e0dd      	b.n	80a3540 <_ZN4MQTT4loopEv+0x202>
            } else {
                buffer[0] = MQTTPINGREQ;
 80a3384:	69e2      	ldr	r2, [r4, #28]
 80a3386:	21c0      	movs	r1, #192	; 0xc0
 80a3388:	7011      	strb	r1, [r2, #0]
                buffer[1] = 0;
 80a338a:	69e2      	ldr	r2, [r4, #28]
                _client.write(buffer,2);
 80a338c:	4620      	mov	r0, r4
            if (pingOutstanding) {
                _client.stop();
                return false;
            } else {
                buffer[0] = MQTTPINGREQ;
                buffer[1] = 0;
 80a338e:	7053      	strb	r3, [r2, #1]
                _client.write(buffer,2);
 80a3390:	69e1      	ldr	r1, [r4, #28]
 80a3392:	2202      	movs	r2, #2
 80a3394:	f001 f9ed 	bl	80a4772 <_ZN9TCPClient5writeEPKhj>
                lastOutActivity = t;
                lastInActivity = t;
                pingOutstanding = true;
 80a3398:	2301      	movs	r3, #1
                return false;
            } else {
                buffer[0] = MQTTPINGREQ;
                buffer[1] = 0;
                _client.write(buffer,2);
                lastOutActivity = t;
 80a339a:	6265      	str	r5, [r4, #36]	; 0x24
                lastInActivity = t;
 80a339c:	62a5      	str	r5, [r4, #40]	; 0x28
                pingOutstanding = true;
 80a339e:	f884 302c 	strb.w	r3, [r4, #44]	; 0x2c
            }
        }
        if (_client.available()) {
 80a33a2:	4620      	mov	r0, r4
 80a33a4:	f001 facc 	bl	80a4940 <_ZN9TCPClient9availableEv>
 80a33a8:	2800      	cmp	r0, #0
 80a33aa:	f000 80c9 	beq.w	80a3540 <_ZN4MQTT4loopEv+0x202>
            uint8_t llen;
            uint16_t len = readPacket(&llen);
 80a33ae:	1df9      	adds	r1, r7, #7
 80a33b0:	4620      	mov	r0, r4
 80a33b2:	f7ff fd61 	bl	80a2e78 <_ZN4MQTT10readPacketEPh>
            uint16_t msgId = 0;
            uint8_t *payload;
            if (len > 0) {
 80a33b6:	4602      	mov	r2, r0
 80a33b8:	2800      	cmp	r0, #0
 80a33ba:	f000 80c1 	beq.w	80a3540 <_ZN4MQTT4loopEv+0x202>
                lastInActivity = t;
                uint8_t type = buffer[0]&0xF0;
 80a33be:	69e3      	ldr	r3, [r4, #28]
            uint8_t llen;
            uint16_t len = readPacket(&llen);
            uint16_t msgId = 0;
            uint8_t *payload;
            if (len > 0) {
                lastInActivity = t;
 80a33c0:	62a5      	str	r5, [r4, #40]	; 0x28
                uint8_t type = buffer[0]&0xF0;
 80a33c2:	7818      	ldrb	r0, [r3, #0]
 80a33c4:	f000 01f0 	and.w	r1, r0, #240	; 0xf0
                if (type == MQTTPUBLISH) {
 80a33c8:	2930      	cmp	r1, #48	; 0x30
 80a33ca:	d17d      	bne.n	80a34c8 <_ZN4MQTT4loopEv+0x18a>
                    if (callback) {
 80a33cc:	f8d4 b030 	ldr.w	fp, [r4, #48]	; 0x30
 80a33d0:	f1bb 0f00 	cmp.w	fp, #0
 80a33d4:	f000 80b4 	beq.w	80a3540 <_ZN4MQTT4loopEv+0x202>
                        uint16_t tl = (buffer[llen+1]<<8)+buffer[llen+2]; // topic length
 80a33d8:	f897 c007 	ldrb.w	ip, [r7, #7]
              							_client.write(buffer, 4);
              							lastOutActivity = t;
            						} else {
                            payload = buffer+llen+3+tl;
                            callback(topic,payload,len-llen-3-tl);
                        }
 80a33dc:	46ea      	mov	sl, sp
            if (len > 0) {
                lastInActivity = t;
                uint8_t type = buffer[0]&0xF0;
                if (type == MQTTPUBLISH) {
                    if (callback) {
                        uint16_t tl = (buffer[llen+1]<<8)+buffer[llen+2]; // topic length
 80a33de:	eb03 000c 	add.w	r0, r3, ip
 80a33e2:	7881      	ldrb	r1, [r0, #2]
 80a33e4:	f890 e001 	ldrb.w	lr, [r0, #1]
 80a33e8:	eb01 2e0e 	add.w	lr, r1, lr, lsl #8
 80a33ec:	fa1f fe8e 	uxth.w	lr, lr
                        char topic[tl+1];
 80a33f0:	f10e 0108 	add.w	r1, lr, #8
 80a33f4:	f021 0107 	bic.w	r1, r1, #7
 80a33f8:	ebad 0d01 	sub.w	sp, sp, r1
 80a33fc:	4668      	mov	r0, sp
 80a33fe:	2100      	movs	r1, #0
                        for (uint16_t i=0;i<tl;i++) {
 80a3400:	b28e      	uxth	r6, r1
 80a3402:	45b6      	cmp	lr, r6
 80a3404:	d906      	bls.n	80a3414 <_ZN4MQTT4loopEv+0xd6>
                            topic[i] = buffer[llen+3+i];
 80a3406:	eb0c 0601 	add.w	r6, ip, r1
 80a340a:	441e      	add	r6, r3
 80a340c:	78f6      	ldrb	r6, [r6, #3]
 80a340e:	5446      	strb	r6, [r0, r1]
 80a3410:	3101      	adds	r1, #1
                uint8_t type = buffer[0]&0xF0;
                if (type == MQTTPUBLISH) {
                    if (callback) {
                        uint16_t tl = (buffer[llen+1]<<8)+buffer[llen+2]; // topic length
                        char topic[tl+1];
                        for (uint16_t i=0;i<tl;i++) {
 80a3412:	e7f5      	b.n	80a3400 <_ZN4MQTT4loopEv+0xc2>
                            topic[i] = buffer[llen+3+i];
                        }
                        topic[tl] = 0;
 80a3414:	2100      	movs	r1, #0
 80a3416:	f800 100e 	strb.w	r1, [r0, lr]
 80a341a:	781e      	ldrb	r6, [r3, #0]
 80a341c:	f10c 0103 	add.w	r1, ip, #3
 80a3420:	f006 0606 	and.w	r6, r6, #6
                        // msgId only present for QOS>0
                        if ((buffer[0]&0x06) == MQTTQOS1_HEADER_MASK) { // QoS=1
 80a3424:	2e02      	cmp	r6, #2
 80a3426:	ebcc 0202 	rsb	r2, ip, r2
 80a342a:	d11e      	bne.n	80a346a <_ZN4MQTT4loopEv+0x12c>
                            msgId = (buffer[llen+3+tl]<<8)+buffer[llen+3+tl+1];
 80a342c:	4471      	add	r1, lr
 80a342e:	f813 8001 	ldrb.w	r8, [r3, r1]
 80a3432:	4419      	add	r1, r3
 80a3434:	7849      	ldrb	r1, [r1, #1]
                            payload = buffer+llen+3+tl+2;
                            callback(topic,payload,len-llen-3-tl-2);
 80a3436:	ebce 0202 	rsb	r2, lr, r2
                            topic[i] = buffer[llen+3+i];
                        }
                        topic[tl] = 0;
                        // msgId only present for QOS>0
                        if ((buffer[0]&0x06) == MQTTQOS1_HEADER_MASK) { // QoS=1
                            msgId = (buffer[llen+3+tl]<<8)+buffer[llen+3+tl+1];
 80a343a:	eb01 2808 	add.w	r8, r1, r8, lsl #8
                            payload = buffer+llen+3+tl+2;
                            callback(topic,payload,len-llen-3-tl-2);
 80a343e:	f10c 0105 	add.w	r1, ip, #5
 80a3442:	4471      	add	r1, lr
 80a3444:	3a05      	subs	r2, #5
 80a3446:	4419      	add	r1, r3
 80a3448:	47d8      	blx	fp

                            buffer[0] = MQTTPUBACK; // respond with PUBACK
 80a344a:	69e3      	ldr	r3, [r4, #28]
 80a344c:	2240      	movs	r2, #64	; 0x40
 80a344e:	701a      	strb	r2, [r3, #0]
                            buffer[1] = 2;
 80a3450:	69e3      	ldr	r3, [r4, #28]
                            topic[i] = buffer[llen+3+i];
                        }
                        topic[tl] = 0;
                        // msgId only present for QOS>0
                        if ((buffer[0]&0x06) == MQTTQOS1_HEADER_MASK) { // QoS=1
                            msgId = (buffer[llen+3+tl]<<8)+buffer[llen+3+tl+1];
 80a3452:	fa1f f888 	uxth.w	r8, r8
                            payload = buffer+llen+3+tl+2;
                            callback(topic,payload,len-llen-3-tl-2);

                            buffer[0] = MQTTPUBACK; // respond with PUBACK
                            buffer[1] = 2;
 80a3456:	705e      	strb	r6, [r3, #1]
                            buffer[2] = (msgId >> 8);
 80a3458:	69e3      	ldr	r3, [r4, #28]
 80a345a:	ea4f 2228 	mov.w	r2, r8, asr #8
 80a345e:	709a      	strb	r2, [r3, #2]
                            buffer[3] = (msgId & 0xFF);
 80a3460:	69e3      	ldr	r3, [r4, #28]
                            _client.write(buffer,4);
 80a3462:	2204      	movs	r2, #4
                            callback(topic,payload,len-llen-3-tl-2);

                            buffer[0] = MQTTPUBACK; // respond with PUBACK
                            buffer[1] = 2;
                            buffer[2] = (msgId >> 8);
                            buffer[3] = (msgId & 0xFF);
 80a3464:	f883 8003 	strb.w	r8, [r3, #3]
 80a3468:	e020      	b.n	80a34ac <_ZN4MQTT4loopEv+0x16e>
                            _client.write(buffer,4);
                            lastOutActivity = t;
        						    } else if ((buffer[0] & 0x06) == MQTTQOS2_HEADER_MASK) { // QoS=2
 80a346a:	2e04      	cmp	r6, #4
 80a346c:	d124      	bne.n	80a34b8 <_ZN4MQTT4loopEv+0x17a>
							              msgId = (buffer[llen + 3 + tl] << 8) + buffer[llen + 3 + tl + 1];
 80a346e:	4471      	add	r1, lr
 80a3470:	f813 8001 	ldrb.w	r8, [r3, r1]
 80a3474:	4419      	add	r1, r3
 80a3476:	7849      	ldrb	r1, [r1, #1]
							              payload = buffer + llen + 3 + tl + 2;
							              callback(topic, payload, len - llen - 3 - tl - 2);
 80a3478:	ebce 0202 	rsb	r2, lr, r2
                            buffer[2] = (msgId >> 8);
                            buffer[3] = (msgId & 0xFF);
                            _client.write(buffer,4);
                            lastOutActivity = t;
        						    } else if ((buffer[0] & 0x06) == MQTTQOS2_HEADER_MASK) { // QoS=2
							              msgId = (buffer[llen + 3 + tl] << 8) + buffer[llen + 3 + tl + 1];
 80a347c:	eb01 2808 	add.w	r8, r1, r8, lsl #8
							              payload = buffer + llen + 3 + tl + 2;
							              callback(topic, payload, len - llen - 3 - tl - 2);
 80a3480:	f10c 0105 	add.w	r1, ip, #5
 80a3484:	4471      	add	r1, lr
 80a3486:	3a05      	subs	r2, #5
 80a3488:	4419      	add	r1, r3
 80a348a:	47d8      	blx	fp

              							buffer[0] = MQTTPUBREC; // respond with PUBREC
 80a348c:	69e3      	ldr	r3, [r4, #28]
 80a348e:	2250      	movs	r2, #80	; 0x50
 80a3490:	701a      	strb	r2, [r3, #0]
              							buffer[1] = 2;
 80a3492:	69e3      	ldr	r3, [r4, #28]
 80a3494:	2202      	movs	r2, #2
 80a3496:	705a      	strb	r2, [r3, #1]
              							buffer[2] = (msgId >> 8);
 80a3498:	69e3      	ldr	r3, [r4, #28]
                            buffer[2] = (msgId >> 8);
                            buffer[3] = (msgId & 0xFF);
                            _client.write(buffer,4);
                            lastOutActivity = t;
        						    } else if ((buffer[0] & 0x06) == MQTTQOS2_HEADER_MASK) { // QoS=2
							              msgId = (buffer[llen + 3 + tl] << 8) + buffer[llen + 3 + tl + 1];
 80a349a:	fa1f f888 	uxth.w	r8, r8
							              payload = buffer + llen + 3 + tl + 2;
							              callback(topic, payload, len - llen - 3 - tl - 2);

              							buffer[0] = MQTTPUBREC; // respond with PUBREC
              							buffer[1] = 2;
              							buffer[2] = (msgId >> 8);
 80a349e:	ea4f 2228 	mov.w	r2, r8, asr #8
 80a34a2:	709a      	strb	r2, [r3, #2]
              							buffer[3] = (msgId & 0xFF);
              							_client.write(buffer, 4);
 80a34a4:	4632      	mov	r2, r6
							              callback(topic, payload, len - llen - 3 - tl - 2);

              							buffer[0] = MQTTPUBREC; // respond with PUBREC
              							buffer[1] = 2;
              							buffer[2] = (msgId >> 8);
              							buffer[3] = (msgId & 0xFF);
 80a34a6:	69e3      	ldr	r3, [r4, #28]
 80a34a8:	f883 8003 	strb.w	r8, [r3, #3]
              							_client.write(buffer, 4);
 80a34ac:	69e1      	ldr	r1, [r4, #28]
 80a34ae:	4620      	mov	r0, r4
 80a34b0:	f001 f95f 	bl	80a4772 <_ZN9TCPClient5writeEPKhj>
              							lastOutActivity = t;
 80a34b4:	6265      	str	r5, [r4, #36]	; 0x24
 80a34b6:	e005      	b.n	80a34c4 <_ZN4MQTT4loopEv+0x186>
            						} else {
                            payload = buffer+llen+3+tl;
                            callback(topic,payload,len-llen-3-tl);
 80a34b8:	3a03      	subs	r2, #3
 80a34ba:	4471      	add	r1, lr
 80a34bc:	ebce 0202 	rsb	r2, lr, r2
 80a34c0:	4419      	add	r1, r3
 80a34c2:	47d8      	blx	fp
 80a34c4:	46d5      	mov	sp, sl
 80a34c6:	e03b      	b.n	80a3540 <_ZN4MQTT4loopEv+0x202>
                        }
                    }
                } else if (type == MQTTPUBREC) {
 80a34c8:	2950      	cmp	r1, #80	; 0x50
 80a34ca:	d108      	bne.n	80a34de <_ZN4MQTT4loopEv+0x1a0>
                    // check for the situation that QoS2 receive PUBREC, should return PUBREL
                    msgId = (buffer[2] << 8) + buffer[3];
                    this->publishRelease(msgId);
 80a34cc:	7899      	ldrb	r1, [r3, #2]
 80a34ce:	78db      	ldrb	r3, [r3, #3]
 80a34d0:	4620      	mov	r0, r4
 80a34d2:	eb03 2101 	add.w	r1, r3, r1, lsl #8
 80a34d6:	b289      	uxth	r1, r1
 80a34d8:	f7ff fefd 	bl	80a32d6 <_ZN4MQTT14publishReleaseEt>
 80a34dc:	e030      	b.n	80a3540 <_ZN4MQTT4loopEv+0x202>
                } else if (type == MQTTPUBACK) {
 80a34de:	2940      	cmp	r1, #64	; 0x40
 80a34e0:	d00c      	beq.n	80a34fc <_ZN4MQTT4loopEv+0x1be>
                        if (len == 4 && (buffer[0]&0x06) == MQTTQOS0_HEADER_MASK) {
                            msgId = (buffer[2]<<8)+buffer[3];
                            this->qoscallback(msgId);
                        }
                    }
                } else if (type == MQTTPUBREL) {
 80a34e2:	2960      	cmp	r1, #96	; 0x60
 80a34e4:	d108      	bne.n	80a34f8 <_ZN4MQTT4loopEv+0x1ba>
                  msgId = (buffer[2] << 8) + buffer[3];
                  this->publishComplete(msgId);
 80a34e6:	7899      	ldrb	r1, [r3, #2]
 80a34e8:	78db      	ldrb	r3, [r3, #3]
 80a34ea:	4620      	mov	r0, r4
 80a34ec:	eb03 2101 	add.w	r1, r3, r1, lsl #8
 80a34f0:	b289      	uxth	r1, r1
 80a34f2:	f7ff ff0a 	bl	80a330a <_ZN4MQTT15publishCompleteEt>
 80a34f6:	e023      	b.n	80a3540 <_ZN4MQTT4loopEv+0x202>
                } else if (type == MQTTPUBCOMP) {
 80a34f8:	2970      	cmp	r1, #112	; 0x70
 80a34fa:	d10d      	bne.n	80a3518 <_ZN4MQTT4loopEv+0x1da>
                  if (qoscallback) {
 80a34fc:	6b61      	ldr	r1, [r4, #52]	; 0x34
 80a34fe:	b1f9      	cbz	r1, 80a3540 <_ZN4MQTT4loopEv+0x202>
                      // msgId only present for QOS==0
                      if (len == 4 && (buffer[0]&0x06) == MQTTQOS0_HEADER_MASK) {
 80a3500:	2a04      	cmp	r2, #4
 80a3502:	d11d      	bne.n	80a3540 <_ZN4MQTT4loopEv+0x202>
 80a3504:	f010 0f06 	tst.w	r0, #6
 80a3508:	d11a      	bne.n	80a3540 <_ZN4MQTT4loopEv+0x202>
                          msgId = (buffer[2]<<8)+buffer[3];
                          this->qoscallback(msgId);
 80a350a:	7898      	ldrb	r0, [r3, #2]
 80a350c:	78db      	ldrb	r3, [r3, #3]
 80a350e:	eb03 2000 	add.w	r0, r3, r0, lsl #8
 80a3512:	b280      	uxth	r0, r0
 80a3514:	4788      	blx	r1
 80a3516:	e013      	b.n	80a3540 <_ZN4MQTT4loopEv+0x202>
                      }
                  }
                } else if (type == MQTTSUBACK) {
 80a3518:	2990      	cmp	r1, #144	; 0x90
 80a351a:	d011      	beq.n	80a3540 <_ZN4MQTT4loopEv+0x202>
                    // if something...
                } else if (type == MQTTPINGREQ) {
 80a351c:	29c0      	cmp	r1, #192	; 0xc0
 80a351e:	d10a      	bne.n	80a3536 <_ZN4MQTT4loopEv+0x1f8>
                    buffer[0] = MQTTPINGRESP;
 80a3520:	22d0      	movs	r2, #208	; 0xd0
 80a3522:	701a      	strb	r2, [r3, #0]
                    buffer[1] = 0;
 80a3524:	69e3      	ldr	r3, [r4, #28]
 80a3526:	2200      	movs	r2, #0
 80a3528:	705a      	strb	r2, [r3, #1]
                    _client.write(buffer,2);
 80a352a:	69e1      	ldr	r1, [r4, #28]
 80a352c:	2202      	movs	r2, #2
 80a352e:	4620      	mov	r0, r4
 80a3530:	f001 f91f 	bl	80a4772 <_ZN9TCPClient5writeEPKhj>
 80a3534:	e004      	b.n	80a3540 <_ZN4MQTT4loopEv+0x202>
                } else if (type == MQTTPINGRESP) {
 80a3536:	29d0      	cmp	r1, #208	; 0xd0
                    pingOutstanding = false;
 80a3538:	bf04      	itt	eq
 80a353a:	2300      	moveq	r3, #0
 80a353c:	f884 302c 	strbeq.w	r3, [r4, #44]	; 0x2c
            }
        }
        return true;
    }
    return false;
}
 80a3540:	4648      	mov	r0, r9
 80a3542:	370c      	adds	r7, #12
 80a3544:	46bd      	mov	sp, r7
 80a3546:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}

080a354a <_ZN4MQTT9subscribeEPKcNS_9EMQTT_QOSE>:

bool MQTT::subscribe(const char* topic) {
    return subscribe(topic, QOS0);
}

bool MQTT::subscribe(const char* topic, EMQTT_QOS qos) {
 80a354a:	b570      	push	{r4, r5, r6, lr}
 80a354c:	4604      	mov	r4, r0
 80a354e:	460e      	mov	r6, r1
 80a3550:	4615      	mov	r5, r2

    if (isConnected()) {
 80a3552:	f7ff fd4a 	bl	80a2fea <_ZN4MQTT11isConnectedEv>
 80a3556:	b1e8      	cbz	r0, 80a3594 <_ZN4MQTT9subscribeEPKcNS_9EMQTT_QOSE+0x4a>
        // Leave room in the buffer for header and variable length field
        uint16_t length = 5;
        nextMsgId++;
 80a3558:	8c23      	ldrh	r3, [r4, #32]
 80a355a:	3301      	adds	r3, #1
 80a355c:	b29b      	uxth	r3, r3
        if (nextMsgId == 0) {
 80a355e:	b903      	cbnz	r3, 80a3562 <_ZN4MQTT9subscribeEPKcNS_9EMQTT_QOSE+0x18>
            nextMsgId = 1;
 80a3560:	2301      	movs	r3, #1
 80a3562:	8423      	strh	r3, [r4, #32]
        }
        buffer[length++] = (nextMsgId >> 8);
 80a3564:	8c23      	ldrh	r3, [r4, #32]
 80a3566:	69e2      	ldr	r2, [r4, #28]
 80a3568:	121b      	asrs	r3, r3, #8
 80a356a:	7153      	strb	r3, [r2, #5]
        buffer[length++] = (nextMsgId & 0xFF);
 80a356c:	69e3      	ldr	r3, [r4, #28]
 80a356e:	8c22      	ldrh	r2, [r4, #32]
        length = writeString(topic, buffer,length);
 80a3570:	4631      	mov	r1, r6
        nextMsgId++;
        if (nextMsgId == 0) {
            nextMsgId = 1;
        }
        buffer[length++] = (nextMsgId >> 8);
        buffer[length++] = (nextMsgId & 0xFF);
 80a3572:	719a      	strb	r2, [r3, #6]
        length = writeString(topic, buffer,length);
 80a3574:	69e2      	ldr	r2, [r4, #28]
 80a3576:	2307      	movs	r3, #7
 80a3578:	4620      	mov	r0, r4
 80a357a:	f7ff fd1c 	bl	80a2fb6 <_ZN4MQTT11writeStringEPKcPht>
        buffer[length++] = qos;
 80a357e:	69e3      	ldr	r3, [r4, #28]
        return write(MQTTSUBSCRIBE | MQTTQOS1_HEADER_MASK,buffer,length-5);
 80a3580:	2182      	movs	r1, #130	; 0x82
            nextMsgId = 1;
        }
        buffer[length++] = (nextMsgId >> 8);
        buffer[length++] = (nextMsgId & 0xFF);
        length = writeString(topic, buffer,length);
        buffer[length++] = qos;
 80a3582:	541d      	strb	r5, [r3, r0]
        return write(MQTTSUBSCRIBE | MQTTQOS1_HEADER_MASK,buffer,length-5);
 80a3584:	1f03      	subs	r3, r0, #4
 80a3586:	69e2      	ldr	r2, [r4, #28]
 80a3588:	4620      	mov	r0, r4
    }
    return false;
}
 80a358a:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
        }
        buffer[length++] = (nextMsgId >> 8);
        buffer[length++] = (nextMsgId & 0xFF);
        length = writeString(topic, buffer,length);
        buffer[length++] = qos;
        return write(MQTTSUBSCRIBE | MQTTQOS1_HEADER_MASK,buffer,length-5);
 80a358e:	b29b      	uxth	r3, r3
 80a3590:	f7ff bcca 	b.w	80a2f28 <_ZN4MQTT5writeEhPht>
    }
    return false;
}
 80a3594:	bd70      	pop	{r4, r5, r6, pc}

080a3596 <_ZN4MQTT9subscribeEPKc>:
    lastOutActivity = millis();
    return (rc == 1+llen+length);
}

bool MQTT::subscribe(const char* topic) {
    return subscribe(topic, QOS0);
 80a3596:	2200      	movs	r2, #0
 80a3598:	f7ff bfd7 	b.w	80a354a <_ZN4MQTT9subscribeEPKcNS_9EMQTT_QOSE>

080a359c <_ZN4MQTTD1Ev>:

MQTT::MQTT(uint8_t *ip, uint16_t port, int keepalive, void (*callback)(char*,uint8_t*,unsigned int), int maxpacketsize) {
    this->initialize(NULL, ip, port, keepalive, callback, maxpacketsize);
}

MQTT::~MQTT() {
 80a359c:	b510      	push	{r4, lr}
 80a359e:	4604      	mov	r4, r0
    if (isConnected()) {
 80a35a0:	f7ff fd23 	bl	80a2fea <_ZN4MQTT11isConnectedEv>
 80a35a4:	b110      	cbz	r0, 80a35ac <_ZN4MQTTD1Ev+0x10>
        disconnect();
 80a35a6:	4620      	mov	r0, r4
 80a35a8:	f7ff fcf1 	bl	80a2f8e <_ZN4MQTT10disconnectEv>
    }

    if (buffer != NULL)
 80a35ac:	69e0      	ldr	r0, [r4, #28]
 80a35ae:	b108      	cbz	r0, 80a35b4 <_ZN4MQTTD1Ev+0x18>
      delete[] buffer;
 80a35b0:	f7fc fd79 	bl	80a00a6 <_ZdaPv>

MQTT::MQTT(uint8_t *ip, uint16_t port, int keepalive, void (*callback)(char*,uint8_t*,unsigned int), int maxpacketsize) {
    this->initialize(NULL, ip, port, keepalive, callback, maxpacketsize);
}

MQTT::~MQTT() {
 80a35b4:	f104 0038 	add.w	r0, r4, #56	; 0x38
 80a35b8:	f001 fbcb 	bl	80a4d52 <_ZN6StringD1Ev>
 80a35bc:	4620      	mov	r0, r4
 80a35be:	f7ff fbe3 	bl	80a2d88 <_ZN9TCPClientD1Ev>
        disconnect();
    }

    if (buffer != NULL)
      delete[] buffer;
}
 80a35c2:	4620      	mov	r0, r4
 80a35c4:	bd10      	pop	{r4, pc}

080a35c6 <_GLOBAL__sub_I__ZN4MQTTC2EPctPFvS0_PhjE>:
 80a35c6:	f000 b9cb 	b.w	80a3960 <HAL_Pin_Map>
	...

080a35cc <HAL_NET_SetNetWatchDog>:

DYNALIB_FN(14, hal_wlan, wlan_set_error_count, void(uint32_t))
DYNALIB_FN(15, hal_wlan, wlan_fetch_ipconfig, void(WLanConfig*))
DYNALIB_FN(16, hal_wlan, wlan_setup, void(void))

DYNALIB_FN(17, hal_wlan, HAL_NET_SetNetWatchDog, uint32_t(uint32_t))
 80a35cc:	b508      	push	{r3, lr}
 80a35ce:	4b02      	ldr	r3, [pc, #8]	; (80a35d8 <HAL_NET_SetNetWatchDog+0xc>)
 80a35d0:	681b      	ldr	r3, [r3, #0]
 80a35d2:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 80a35d4:	9301      	str	r3, [sp, #4]
 80a35d6:	bd08      	pop	{r3, pc}
 80a35d8:	080601c0 	.word	0x080601c0

080a35dc <inet_gethostbyname>:
DYNALIB_FN(18, hal_wlan, inet_gethostbyname, int(const char*, uint16_t, HAL_IPAddress*, network_interface_t, void*))
 80a35dc:	b508      	push	{r3, lr}
 80a35de:	4b02      	ldr	r3, [pc, #8]	; (80a35e8 <inet_gethostbyname+0xc>)
 80a35e0:	681b      	ldr	r3, [r3, #0]
 80a35e2:	6c9b      	ldr	r3, [r3, #72]	; 0x48
 80a35e4:	9301      	str	r3, [sp, #4]
 80a35e6:	bd08      	pop	{r3, pc}
 80a35e8:	080601c0 	.word	0x080601c0

080a35ec <HAL_USB_USART_Init>:
#endif

DYNALIB_BEGIN(hal_usb)

#ifdef USB_CDC_ENABLE
DYNALIB_FN(0, hal_usb, HAL_USB_USART_Init, void(HAL_USB_USART_Serial, const HAL_USB_USART_Config*))
 80a35ec:	b508      	push	{r3, lr}
 80a35ee:	4b02      	ldr	r3, [pc, #8]	; (80a35f8 <HAL_USB_USART_Init+0xc>)
 80a35f0:	681b      	ldr	r3, [r3, #0]
 80a35f2:	681b      	ldr	r3, [r3, #0]
 80a35f4:	9301      	str	r3, [sp, #4]
 80a35f6:	bd08      	pop	{r3, pc}
 80a35f8:	080601d8 	.word	0x080601d8

080a35fc <HAL_USB_USART_Begin>:
DYNALIB_FN(1, hal_usb, HAL_USB_USART_Begin, void(HAL_USB_USART_Serial, uint32_t, void *))
 80a35fc:	b508      	push	{r3, lr}
 80a35fe:	4b02      	ldr	r3, [pc, #8]	; (80a3608 <HAL_USB_USART_Begin+0xc>)
 80a3600:	681b      	ldr	r3, [r3, #0]
 80a3602:	685b      	ldr	r3, [r3, #4]
 80a3604:	9301      	str	r3, [sp, #4]
 80a3606:	bd08      	pop	{r3, pc}
 80a3608:	080601d8 	.word	0x080601d8

080a360c <HAL_USB_USART_Available_Data>:
DYNALIB_FN(2, hal_usb, HAL_USB_USART_End, void(HAL_USB_USART_Serial))
DYNALIB_FN(3, hal_usb, HAL_USB_USART_Baud_Rate, unsigned int(HAL_USB_USART_Serial))
DYNALIB_FN(4, hal_usb, HAL_USB_USART_Available_Data, int32_t(HAL_USB_USART_Serial))
 80a360c:	b508      	push	{r3, lr}
 80a360e:	4b02      	ldr	r3, [pc, #8]	; (80a3618 <HAL_USB_USART_Available_Data+0xc>)
 80a3610:	681b      	ldr	r3, [r3, #0]
 80a3612:	691b      	ldr	r3, [r3, #16]
 80a3614:	9301      	str	r3, [sp, #4]
 80a3616:	bd08      	pop	{r3, pc}
 80a3618:	080601d8 	.word	0x080601d8

080a361c <HAL_USB_USART_Available_Data_For_Write>:
DYNALIB_FN(5, hal_usb, HAL_USB_USART_Available_Data_For_Write, int32_t(HAL_USB_USART_Serial))
 80a361c:	b508      	push	{r3, lr}
 80a361e:	4b02      	ldr	r3, [pc, #8]	; (80a3628 <HAL_USB_USART_Available_Data_For_Write+0xc>)
 80a3620:	681b      	ldr	r3, [r3, #0]
 80a3622:	695b      	ldr	r3, [r3, #20]
 80a3624:	9301      	str	r3, [sp, #4]
 80a3626:	bd08      	pop	{r3, pc}
 80a3628:	080601d8 	.word	0x080601d8

080a362c <HAL_USB_USART_Receive_Data>:
DYNALIB_FN(6, hal_usb, HAL_USB_USART_Receive_Data, int32_t(HAL_USB_USART_Serial, uint8_t))
 80a362c:	b508      	push	{r3, lr}
 80a362e:	4b02      	ldr	r3, [pc, #8]	; (80a3638 <HAL_USB_USART_Receive_Data+0xc>)
 80a3630:	681b      	ldr	r3, [r3, #0]
 80a3632:	699b      	ldr	r3, [r3, #24]
 80a3634:	9301      	str	r3, [sp, #4]
 80a3636:	bd08      	pop	{r3, pc}
 80a3638:	080601d8 	.word	0x080601d8

080a363c <HAL_USB_USART_Send_Data>:
DYNALIB_FN(7, hal_usb, HAL_USB_USART_Send_Data, int32_t(HAL_USB_USART_Serial, uint8_t))
 80a363c:	b508      	push	{r3, lr}
 80a363e:	4b02      	ldr	r3, [pc, #8]	; (80a3648 <HAL_USB_USART_Send_Data+0xc>)
 80a3640:	681b      	ldr	r3, [r3, #0]
 80a3642:	69db      	ldr	r3, [r3, #28]
 80a3644:	9301      	str	r3, [sp, #4]
 80a3646:	bd08      	pop	{r3, pc}
 80a3648:	080601d8 	.word	0x080601d8

080a364c <HAL_USB_USART_Flush_Data>:
DYNALIB_FN(8, hal_usb, HAL_USB_USART_Flush_Data, void(HAL_USB_USART_Serial))
 80a364c:	b508      	push	{r3, lr}
 80a364e:	4b02      	ldr	r3, [pc, #8]	; (80a3658 <HAL_USB_USART_Flush_Data+0xc>)
 80a3650:	681b      	ldr	r3, [r3, #0]
 80a3652:	6a1b      	ldr	r3, [r3, #32]
 80a3654:	9301      	str	r3, [sp, #4]
 80a3656:	bd08      	pop	{r3, pc}
 80a3658:	080601d8 	.word	0x080601d8

080a365c <socket_active_status>:
// New HAL functions must be added to the end of this list.
// GNINRAW

DYNALIB_BEGIN(hal_socket)

DYNALIB_FN(0, hal_socket, socket_active_status, uint8_t(sock_handle_t))
 80a365c:	b508      	push	{r3, lr}
 80a365e:	4b02      	ldr	r3, [pc, #8]	; (80a3668 <socket_active_status+0xc>)
 80a3660:	681b      	ldr	r3, [r3, #0]
 80a3662:	681b      	ldr	r3, [r3, #0]
 80a3664:	9301      	str	r3, [sp, #4]
 80a3666:	bd08      	pop	{r3, pc}
 80a3668:	080601bc 	.word	0x080601bc

080a366c <socket_handle_valid>:
DYNALIB_FN(1, hal_socket, socket_handle_valid, uint8_t(sock_handle_t))
 80a366c:	b508      	push	{r3, lr}
 80a366e:	4b02      	ldr	r3, [pc, #8]	; (80a3678 <socket_handle_valid+0xc>)
 80a3670:	681b      	ldr	r3, [r3, #0]
 80a3672:	685b      	ldr	r3, [r3, #4]
 80a3674:	9301      	str	r3, [sp, #4]
 80a3676:	bd08      	pop	{r3, pc}
 80a3678:	080601bc 	.word	0x080601bc

080a367c <socket_create>:
DYNALIB_FN(2, hal_socket, socket_create, sock_handle_t(uint8_t, uint8_t, uint8_t, uint16_t, network_interface_t))
 80a367c:	b508      	push	{r3, lr}
 80a367e:	4b02      	ldr	r3, [pc, #8]	; (80a3688 <socket_create+0xc>)
 80a3680:	681b      	ldr	r3, [r3, #0]
 80a3682:	689b      	ldr	r3, [r3, #8]
 80a3684:	9301      	str	r3, [sp, #4]
 80a3686:	bd08      	pop	{r3, pc}
 80a3688:	080601bc 	.word	0x080601bc

080a368c <socket_connect>:
DYNALIB_FN(3, hal_socket, socket_connect, int32_t(sock_handle_t, const sockaddr_t*, long))
 80a368c:	b508      	push	{r3, lr}
 80a368e:	4b02      	ldr	r3, [pc, #8]	; (80a3698 <socket_connect+0xc>)
 80a3690:	681b      	ldr	r3, [r3, #0]
 80a3692:	68db      	ldr	r3, [r3, #12]
 80a3694:	9301      	str	r3, [sp, #4]
 80a3696:	bd08      	pop	{r3, pc}
 80a3698:	080601bc 	.word	0x080601bc

080a369c <socket_receive>:
DYNALIB_FN(4, hal_socket, socket_receive, sock_result_t(sock_handle_t, void*, socklen_t, system_tick_t))
 80a369c:	b508      	push	{r3, lr}
 80a369e:	4b02      	ldr	r3, [pc, #8]	; (80a36a8 <socket_receive+0xc>)
 80a36a0:	681b      	ldr	r3, [r3, #0]
 80a36a2:	691b      	ldr	r3, [r3, #16]
 80a36a4:	9301      	str	r3, [sp, #4]
 80a36a6:	bd08      	pop	{r3, pc}
 80a36a8:	080601bc 	.word	0x080601bc

080a36ac <socket_close>:
DYNALIB_FN(5, hal_socket, socket_receivefrom, sock_result_t(sock_handle_t, void*, socklen_t, uint32_t, sockaddr_t*, socklen_t*))
DYNALIB_FN(6, hal_socket, socket_send, sock_result_t(sock_handle_t, const void*, socklen_t))
DYNALIB_FN(7, hal_socket, socket_sendto, sock_result_t(sock_handle_t, const void*, socklen_t, uint32_t, sockaddr_t*, socklen_t))
DYNALIB_FN(8, hal_socket, socket_close, sock_result_t(sock_handle_t))
 80a36ac:	b508      	push	{r3, lr}
 80a36ae:	4b02      	ldr	r3, [pc, #8]	; (80a36b8 <socket_close+0xc>)
 80a36b0:	681b      	ldr	r3, [r3, #0]
 80a36b2:	6a1b      	ldr	r3, [r3, #32]
 80a36b4:	9301      	str	r3, [sp, #4]
 80a36b6:	bd08      	pop	{r3, pc}
 80a36b8:	080601bc 	.word	0x080601bc

080a36bc <socket_handle_invalid>:
DYNALIB_FN(9, hal_socket, socket_reset_blocking_call, sock_result_t(void))
DYNALIB_FN(10, hal_socket, socket_create_tcp_server, sock_result_t(uint16_t, network_interface_t))
DYNALIB_FN(11, hal_socket, socket_accept, sock_result_t(sock_handle_t))
DYNALIB_FN(12, hal_socket, socket_handle_invalid, sock_handle_t(void))
 80a36bc:	b508      	push	{r3, lr}
 80a36be:	4b02      	ldr	r3, [pc, #8]	; (80a36c8 <socket_handle_invalid+0xc>)
 80a36c0:	681b      	ldr	r3, [r3, #0]
 80a36c2:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80a36c4:	9301      	str	r3, [sp, #4]
 80a36c6:	bd08      	pop	{r3, pc}
 80a36c8:	080601bc 	.word	0x080601bc

080a36cc <socket_send_ex>:
DYNALIB_FN(13, hal_socket, socket_join_multicast, sock_result_t(const HAL_IPAddress*, network_interface_t, socket_multicast_info_t*))
DYNALIB_FN(14, hal_socket, socket_leave_multicast, sock_result_t(const HAL_IPAddress*, network_interface_t, socket_multicast_info_t*))
DYNALIB_FN(15, hal_socket, socket_peer, sock_result_t(sock_handle_t, sock_peer_t*, void*))
DYNALIB_FN(16, hal_socket, socket_shutdown, sock_result_t(sock_handle_t, int))
DYNALIB_FN(17, hal_socket, socket_send_ex, sock_result_t(sock_handle_t, const void*, socklen_t, uint32_t, system_tick_t, void*))
 80a36cc:	b508      	push	{r3, lr}
 80a36ce:	4b02      	ldr	r3, [pc, #8]	; (80a36d8 <socket_send_ex+0xc>)
 80a36d0:	681b      	ldr	r3, [r3, #0]
 80a36d2:	6c5b      	ldr	r3, [r3, #68]	; 0x44
 80a36d4:	9301      	str	r3, [sp, #4]
 80a36d6:	bd08      	pop	{r3, pc}
 80a36d8:	080601bc 	.word	0x080601bc

080a36dc <HAL_I2C_Write_Data>:
DYNALIB_FN(BASE_IDX + 3, hal_i2c, HAL_I2C_Begin, void(HAL_I2C_Interface, I2C_Mode, uint8_t, void*))
DYNALIB_FN(BASE_IDX + 4, hal_i2c, HAL_I2C_End, void(HAL_I2C_Interface, void*))
DYNALIB_FN(BASE_IDX + 5, hal_i2c, HAL_I2C_Request_Data, uint32_t(HAL_I2C_Interface, uint8_t, uint8_t, uint8_t, void*))
DYNALIB_FN(BASE_IDX + 6, hal_i2c, HAL_I2C_Begin_Transmission, void(HAL_I2C_Interface, uint8_t, void*))
DYNALIB_FN(BASE_IDX + 7, hal_i2c, HAL_I2C_End_Transmission, uint8_t(HAL_I2C_Interface, uint8_t, void*))
DYNALIB_FN(BASE_IDX + 8, hal_i2c, HAL_I2C_Write_Data, uint32_t(HAL_I2C_Interface, uint8_t, void*))
 80a36dc:	b508      	push	{r3, lr}
 80a36de:	4b02      	ldr	r3, [pc, #8]	; (80a36e8 <HAL_I2C_Write_Data+0xc>)
 80a36e0:	681b      	ldr	r3, [r3, #0]
 80a36e2:	6e1b      	ldr	r3, [r3, #96]	; 0x60
 80a36e4:	9301      	str	r3, [sp, #4]
 80a36e6:	bd08      	pop	{r3, pc}
 80a36e8:	080601ac 	.word	0x080601ac

080a36ec <HAL_I2C_Available_Data>:
DYNALIB_FN(BASE_IDX + 9, hal_i2c, HAL_I2C_Available_Data, int32_t(HAL_I2C_Interface, void*))
 80a36ec:	b508      	push	{r3, lr}
 80a36ee:	4b02      	ldr	r3, [pc, #8]	; (80a36f8 <HAL_I2C_Available_Data+0xc>)
 80a36f0:	681b      	ldr	r3, [r3, #0]
 80a36f2:	6e5b      	ldr	r3, [r3, #100]	; 0x64
 80a36f4:	9301      	str	r3, [sp, #4]
 80a36f6:	bd08      	pop	{r3, pc}
 80a36f8:	080601ac 	.word	0x080601ac

080a36fc <HAL_I2C_Read_Data>:
DYNALIB_FN(BASE_IDX + 10, hal_i2c, HAL_I2C_Read_Data, int32_t(HAL_I2C_Interface, void*))
 80a36fc:	b508      	push	{r3, lr}
 80a36fe:	4b02      	ldr	r3, [pc, #8]	; (80a3708 <HAL_I2C_Read_Data+0xc>)
 80a3700:	681b      	ldr	r3, [r3, #0]
 80a3702:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 80a3704:	9301      	str	r3, [sp, #4]
 80a3706:	bd08      	pop	{r3, pc}
 80a3708:	080601ac 	.word	0x080601ac

080a370c <HAL_I2C_Peek_Data>:
DYNALIB_FN(BASE_IDX + 11, hal_i2c, HAL_I2C_Peek_Data, int32_t(HAL_I2C_Interface, void*))
 80a370c:	b508      	push	{r3, lr}
 80a370e:	4b02      	ldr	r3, [pc, #8]	; (80a3718 <HAL_I2C_Peek_Data+0xc>)
 80a3710:	681b      	ldr	r3, [r3, #0]
 80a3712:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 80a3714:	9301      	str	r3, [sp, #4]
 80a3716:	bd08      	pop	{r3, pc}
 80a3718:	080601ac 	.word	0x080601ac

080a371c <HAL_I2C_Flush_Data>:
DYNALIB_FN(BASE_IDX + 12, hal_i2c, HAL_I2C_Flush_Data, void(HAL_I2C_Interface, void*))
 80a371c:	b508      	push	{r3, lr}
 80a371e:	4b02      	ldr	r3, [pc, #8]	; (80a3728 <HAL_I2C_Flush_Data+0xc>)
 80a3720:	681b      	ldr	r3, [r3, #0]
 80a3722:	6f1b      	ldr	r3, [r3, #112]	; 0x70
 80a3724:	9301      	str	r3, [sp, #4]
 80a3726:	bd08      	pop	{r3, pc}
 80a3728:	080601ac 	.word	0x080601ac

080a372c <HAL_I2C_Is_Enabled>:
DYNALIB_FN(BASE_IDX + 13, hal_i2c, HAL_I2C_Is_Enabled, bool(HAL_I2C_Interface, void*))
 80a372c:	b508      	push	{r3, lr}
 80a372e:	4b02      	ldr	r3, [pc, #8]	; (80a3738 <HAL_I2C_Is_Enabled+0xc>)
 80a3730:	681b      	ldr	r3, [r3, #0]
 80a3732:	6f5b      	ldr	r3, [r3, #116]	; 0x74
 80a3734:	9301      	str	r3, [sp, #4]
 80a3736:	bd08      	pop	{r3, pc}
 80a3738:	080601ac 	.word	0x080601ac

080a373c <HAL_I2C_Init>:
DYNALIB_FN(BASE_IDX + 14, hal_i2c, HAL_I2C_Set_Callback_On_Receive, void(HAL_I2C_Interface, void(*)(int), void*))
DYNALIB_FN(BASE_IDX + 15, hal_i2c, HAL_I2C_Set_Callback_On_Request, void(HAL_I2C_Interface, void(*)(void), void*))
DYNALIB_FN(BASE_IDX + 16, hal_i2c, HAL_I2C_Init, void(HAL_I2C_Interface, void*))
 80a373c:	b508      	push	{r3, lr}
 80a373e:	4b03      	ldr	r3, [pc, #12]	; (80a374c <HAL_I2C_Init+0x10>)
 80a3740:	681b      	ldr	r3, [r3, #0]
 80a3742:	f8d3 3080 	ldr.w	r3, [r3, #128]	; 0x80
 80a3746:	9301      	str	r3, [sp, #4]
 80a3748:	bd08      	pop	{r3, pc}
 80a374a:	0000      	.short	0x0000
 80a374c:	080601ac 	.word	0x080601ac

080a3750 <HAL_USART_Init>:
#define BASE_IDX 6 // Base index for all subsequent functions
#else
#define BASE_IDX 0
#endif

DYNALIB_FN(BASE_IDX + 0, hal_usart, HAL_USART_Init, void(HAL_USART_Serial, Ring_Buffer*, Ring_Buffer*))
 80a3750:	b508      	push	{r3, lr}
 80a3752:	4b02      	ldr	r3, [pc, #8]	; (80a375c <HAL_USART_Init+0xc>)
 80a3754:	681b      	ldr	r3, [r3, #0]
 80a3756:	699b      	ldr	r3, [r3, #24]
 80a3758:	9301      	str	r3, [sp, #4]
 80a375a:	bd08      	pop	{r3, pc}
 80a375c:	080601c4 	.word	0x080601c4

080a3760 <HAL_USART_Write_Data>:
DYNALIB_FN(BASE_IDX + 1, hal_usart, HAL_USART_Begin, void(HAL_USART_Serial, uint32_t))
DYNALIB_FN(BASE_IDX + 2, hal_usart, HAL_USART_End, void(HAL_USART_Serial))
DYNALIB_FN(BASE_IDX + 3, hal_usart, HAL_USART_Write_Data, uint32_t(HAL_USART_Serial, uint8_t))
 80a3760:	b508      	push	{r3, lr}
 80a3762:	4b02      	ldr	r3, [pc, #8]	; (80a376c <HAL_USART_Write_Data+0xc>)
 80a3764:	681b      	ldr	r3, [r3, #0]
 80a3766:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80a3768:	9301      	str	r3, [sp, #4]
 80a376a:	bd08      	pop	{r3, pc}
 80a376c:	080601c4 	.word	0x080601c4

080a3770 <HAL_USART_Available_Data>:
DYNALIB_FN(BASE_IDX + 4, hal_usart, HAL_USART_Available_Data, int32_t(HAL_USART_Serial))
 80a3770:	b508      	push	{r3, lr}
 80a3772:	4b02      	ldr	r3, [pc, #8]	; (80a377c <HAL_USART_Available_Data+0xc>)
 80a3774:	681b      	ldr	r3, [r3, #0]
 80a3776:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80a3778:	9301      	str	r3, [sp, #4]
 80a377a:	bd08      	pop	{r3, pc}
 80a377c:	080601c4 	.word	0x080601c4

080a3780 <HAL_USART_Read_Data>:
DYNALIB_FN(BASE_IDX + 5, hal_usart, HAL_USART_Read_Data, int32_t(HAL_USART_Serial))
 80a3780:	b508      	push	{r3, lr}
 80a3782:	4b02      	ldr	r3, [pc, #8]	; (80a378c <HAL_USART_Read_Data+0xc>)
 80a3784:	681b      	ldr	r3, [r3, #0]
 80a3786:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80a3788:	9301      	str	r3, [sp, #4]
 80a378a:	bd08      	pop	{r3, pc}
 80a378c:	080601c4 	.word	0x080601c4

080a3790 <HAL_USART_Peek_Data>:
DYNALIB_FN(BASE_IDX + 6, hal_usart, HAL_USART_Peek_Data, int32_t(HAL_USART_Serial))
 80a3790:	b508      	push	{r3, lr}
 80a3792:	4b02      	ldr	r3, [pc, #8]	; (80a379c <HAL_USART_Peek_Data+0xc>)
 80a3794:	681b      	ldr	r3, [r3, #0]
 80a3796:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80a3798:	9301      	str	r3, [sp, #4]
 80a379a:	bd08      	pop	{r3, pc}
 80a379c:	080601c4 	.word	0x080601c4

080a37a0 <HAL_USART_Flush_Data>:
DYNALIB_FN(BASE_IDX + 7, hal_usart, HAL_USART_Flush_Data, void(HAL_USART_Serial))
 80a37a0:	b508      	push	{r3, lr}
 80a37a2:	4b02      	ldr	r3, [pc, #8]	; (80a37ac <HAL_USART_Flush_Data+0xc>)
 80a37a4:	681b      	ldr	r3, [r3, #0]
 80a37a6:	6b5b      	ldr	r3, [r3, #52]	; 0x34
 80a37a8:	9301      	str	r3, [sp, #4]
 80a37aa:	bd08      	pop	{r3, pc}
 80a37ac:	080601c4 	.word	0x080601c4

080a37b0 <HAL_USART_Is_Enabled>:
DYNALIB_FN(BASE_IDX + 8, hal_usart, HAL_USART_Is_Enabled, bool(HAL_USART_Serial))
 80a37b0:	b508      	push	{r3, lr}
 80a37b2:	4b02      	ldr	r3, [pc, #8]	; (80a37bc <HAL_USART_Is_Enabled+0xc>)
 80a37b4:	681b      	ldr	r3, [r3, #0]
 80a37b6:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80a37b8:	9301      	str	r3, [sp, #4]
 80a37ba:	bd08      	pop	{r3, pc}
 80a37bc:	080601c4 	.word	0x080601c4

080a37c0 <HAL_USART_Available_Data_For_Write>:
DYNALIB_FN(BASE_IDX + 9, hal_usart, HAL_USART_Half_Duplex, void(HAL_USART_Serial, bool))
DYNALIB_FN(BASE_IDX + 10, hal_usart, HAL_USART_Available_Data_For_Write, int32_t(HAL_USART_Serial))
 80a37c0:	b508      	push	{r3, lr}
 80a37c2:	4b02      	ldr	r3, [pc, #8]	; (80a37cc <HAL_USART_Available_Data_For_Write+0xc>)
 80a37c4:	681b      	ldr	r3, [r3, #0]
 80a37c6:	6c1b      	ldr	r3, [r3, #64]	; 0x40
 80a37c8:	9301      	str	r3, [sp, #4]
 80a37ca:	bd08      	pop	{r3, pc}
 80a37cc:	080601c4 	.word	0x080601c4

080a37d0 <os_thread_create>:

DYNALIB_BEGIN(hal_concurrent)

#if PLATFORM_THREADING
DYNALIB_FN(0, hal_concurrent, __gthread_equal, bool(__gthread_t, __gthread_t))
DYNALIB_FN(1, hal_concurrent, os_thread_create, os_result_t(os_thread_t*, const char*, os_thread_prio_t, os_thread_fn_t, void*, size_t))
 80a37d0:	b508      	push	{r3, lr}
 80a37d2:	4b02      	ldr	r3, [pc, #8]	; (80a37dc <os_thread_create+0xc>)
 80a37d4:	681b      	ldr	r3, [r3, #0]
 80a37d6:	685b      	ldr	r3, [r3, #4]
 80a37d8:	9301      	str	r3, [sp, #4]
 80a37da:	bd08      	pop	{r3, pc}
 80a37dc:	080601d0 	.word	0x080601d0

080a37e0 <os_thread_is_current>:
DYNALIB_FN(2, hal_concurrent, os_thread_is_current, bool(os_thread_t))
 80a37e0:	b508      	push	{r3, lr}
 80a37e2:	4b02      	ldr	r3, [pc, #8]	; (80a37ec <os_thread_is_current+0xc>)
 80a37e4:	681b      	ldr	r3, [r3, #0]
 80a37e6:	689b      	ldr	r3, [r3, #8]
 80a37e8:	9301      	str	r3, [sp, #4]
 80a37ea:	bd08      	pop	{r3, pc}
 80a37ec:	080601d0 	.word	0x080601d0

080a37f0 <os_thread_yield>:
DYNALIB_FN(3, hal_concurrent, os_thread_yield, os_result_t(void))
 80a37f0:	b508      	push	{r3, lr}
 80a37f2:	4b02      	ldr	r3, [pc, #8]	; (80a37fc <os_thread_yield+0xc>)
 80a37f4:	681b      	ldr	r3, [r3, #0]
 80a37f6:	68db      	ldr	r3, [r3, #12]
 80a37f8:	9301      	str	r3, [sp, #4]
 80a37fa:	bd08      	pop	{r3, pc}
 80a37fc:	080601d0 	.word	0x080601d0

080a3800 <os_thread_join>:
DYNALIB_FN(4, hal_concurrent, os_thread_join, os_result_t(os_thread_t))
 80a3800:	b508      	push	{r3, lr}
 80a3802:	4b02      	ldr	r3, [pc, #8]	; (80a380c <os_thread_join+0xc>)
 80a3804:	681b      	ldr	r3, [r3, #0]
 80a3806:	691b      	ldr	r3, [r3, #16]
 80a3808:	9301      	str	r3, [sp, #4]
 80a380a:	bd08      	pop	{r3, pc}
 80a380c:	080601d0 	.word	0x080601d0

080a3810 <os_thread_cleanup>:
DYNALIB_FN(5, hal_concurrent, os_thread_cleanup, os_result_t(os_thread_t))
 80a3810:	b508      	push	{r3, lr}
 80a3812:	4b02      	ldr	r3, [pc, #8]	; (80a381c <os_thread_cleanup+0xc>)
 80a3814:	681b      	ldr	r3, [r3, #0]
 80a3816:	695b      	ldr	r3, [r3, #20]
 80a3818:	9301      	str	r3, [sp, #4]
 80a381a:	bd08      	pop	{r3, pc}
 80a381c:	080601d0 	.word	0x080601d0

080a3820 <os_timer_create>:
DYNALIB_FN(6, hal_concurrent, os_thread_delay_until, os_result_t(system_tick_t*, system_tick_t))
DYNALIB_FN(7, hal_concurrent, os_thread_scheduling, void(bool, void*))

DYNALIB_FN(8, hal_concurrent, os_timer_create, int(os_timer_t*, unsigned, void(*)(os_timer_t), void*, bool, void*))
 80a3820:	b508      	push	{r3, lr}
 80a3822:	4b02      	ldr	r3, [pc, #8]	; (80a382c <os_timer_create+0xc>)
 80a3824:	681b      	ldr	r3, [r3, #0]
 80a3826:	6a1b      	ldr	r3, [r3, #32]
 80a3828:	9301      	str	r3, [sp, #4]
 80a382a:	bd08      	pop	{r3, pc}
 80a382c:	080601d0 	.word	0x080601d0

080a3830 <os_timer_destroy>:
DYNALIB_FN(9, hal_concurrent, os_timer_destroy, int(os_timer_t, void*))
 80a3830:	b508      	push	{r3, lr}
 80a3832:	4b02      	ldr	r3, [pc, #8]	; (80a383c <os_timer_destroy+0xc>)
 80a3834:	681b      	ldr	r3, [r3, #0]
 80a3836:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80a3838:	9301      	str	r3, [sp, #4]
 80a383a:	bd08      	pop	{r3, pc}
 80a383c:	080601d0 	.word	0x080601d0

080a3840 <os_timer_get_id>:
DYNALIB_FN(10, hal_concurrent, os_timer_get_id, int(os_timer_t, void**))
 80a3840:	b508      	push	{r3, lr}
 80a3842:	4b02      	ldr	r3, [pc, #8]	; (80a384c <os_timer_get_id+0xc>)
 80a3844:	681b      	ldr	r3, [r3, #0]
 80a3846:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80a3848:	9301      	str	r3, [sp, #4]
 80a384a:	bd08      	pop	{r3, pc}
 80a384c:	080601d0 	.word	0x080601d0

080a3850 <os_timer_change>:
DYNALIB_FN(11, hal_concurrent, os_timer_change, int(os_timer_t, os_timer_change_t, bool, unsigned, unsigned, void*))
 80a3850:	b508      	push	{r3, lr}
 80a3852:	4b02      	ldr	r3, [pc, #8]	; (80a385c <os_timer_change+0xc>)
 80a3854:	681b      	ldr	r3, [r3, #0]
 80a3856:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80a3858:	9301      	str	r3, [sp, #4]
 80a385a:	bd08      	pop	{r3, pc}
 80a385c:	080601d0 	.word	0x080601d0

080a3860 <os_mutex_create>:

DYNALIB_FN(12, hal_concurrent, os_mutex_create, int(os_mutex_t*))
 80a3860:	b508      	push	{r3, lr}
 80a3862:	4b02      	ldr	r3, [pc, #8]	; (80a386c <os_mutex_create+0xc>)
 80a3864:	681b      	ldr	r3, [r3, #0]
 80a3866:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80a3868:	9301      	str	r3, [sp, #4]
 80a386a:	bd08      	pop	{r3, pc}
 80a386c:	080601d0 	.word	0x080601d0

080a3870 <os_thread_exit>:

DYNALIB_FN(23, hal_concurrent, os_queue_create, int(os_queue_t*, size_t, size_t, void*))
DYNALIB_FN(24, hal_concurrent, os_queue_destroy, int(os_queue_t, void*))
DYNALIB_FN(25, hal_concurrent, os_queue_put, int(os_queue_t, const void* item, system_tick_t, void*))
DYNALIB_FN(26, hal_concurrent, os_queue_take, int(os_queue_t, void* item, system_tick_t, void*))
DYNALIB_FN(27, hal_concurrent, os_thread_exit, os_result_t(os_thread_t))
 80a3870:	b508      	push	{r3, lr}
 80a3872:	4b02      	ldr	r3, [pc, #8]	; (80a387c <os_thread_exit+0xc>)
 80a3874:	681b      	ldr	r3, [r3, #0]
 80a3876:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 80a3878:	9301      	str	r3, [sp, #4]
 80a387a:	bd08      	pop	{r3, pc}
 80a387c:	080601d0 	.word	0x080601d0

080a3880 <HAL_Core_System_Reset_Ex>:
DYNALIB_FN(21, hal_core, HAL_Core_Runtime_Info, uint32_t(runtime_info_t*, void*))
DYNALIB_FN(22, hal_core, HAL_Set_System_Config, int(hal_system_config_t, const void*, unsigned))
DYNALIB_FN(23, hal_core, HAL_Core_Enter_Safe_Mode, void(void*))
DYNALIB_FN(24, hal_core, HAL_Feature_Get, bool(HAL_Feature))
DYNALIB_FN(25, hal_core, HAL_Feature_Set, int(HAL_Feature, bool))
DYNALIB_FN(26, hal_core, HAL_Core_System_Reset_Ex, void(int, uint32_t, void*))
 80a3880:	b508      	push	{r3, lr}
 80a3882:	4b02      	ldr	r3, [pc, #8]	; (80a388c <HAL_Core_System_Reset_Ex+0xc>)
 80a3884:	681b      	ldr	r3, [r3, #0]
 80a3886:	6e9b      	ldr	r3, [r3, #104]	; 0x68
 80a3888:	9301      	str	r3, [sp, #4]
 80a388a:	bd08      	pop	{r3, pc}
 80a388c:	080601b8 	.word	0x080601b8

080a3890 <HAL_Core_Get_Last_Reset_Info>:
DYNALIB_FN(27, hal_core, HAL_Core_Get_Last_Reset_Info, int(int*, uint32_t*, void*))
 80a3890:	b508      	push	{r3, lr}
 80a3892:	4b02      	ldr	r3, [pc, #8]	; (80a389c <HAL_Core_Get_Last_Reset_Info+0xc>)
 80a3894:	681b      	ldr	r3, [r3, #0]
 80a3896:	6edb      	ldr	r3, [r3, #108]	; 0x6c
 80a3898:	9301      	str	r3, [sp, #4]
 80a389a:	bd08      	pop	{r3, pc}
 80a389c:	080601b8 	.word	0x080601b8

080a38a0 <HAL_RNG_GetRandomNumber>:

DYNALIB_BEGIN(hal)

#if PLATFORM_ID > 3
DYNALIB_FN(0, hal, HAL_RNG_Configuration, void(void))
DYNALIB_FN(1, hal, HAL_RNG_GetRandomNumber, uint32_t(void))
 80a38a0:	b508      	push	{r3, lr}
 80a38a2:	4b02      	ldr	r3, [pc, #8]	; (80a38ac <HAL_RNG_GetRandomNumber+0xc>)
 80a38a4:	681b      	ldr	r3, [r3, #0]
 80a38a6:	685b      	ldr	r3, [r3, #4]
 80a38a8:	9301      	str	r3, [sp, #4]
 80a38aa:	bd08      	pop	{r3, pc}
 80a38ac:	0806019c 	.word	0x0806019c

080a38b0 <HAL_Delay_Milliseconds>:
#define BASE_IDX 2 // Base index for all subsequent functions
#else
#define BASE_IDX 0
#endif

DYNALIB_FN(BASE_IDX + 0, hal, HAL_Delay_Milliseconds, void(uint32_t))
 80a38b0:	b508      	push	{r3, lr}
 80a38b2:	4b02      	ldr	r3, [pc, #8]	; (80a38bc <HAL_Delay_Milliseconds+0xc>)
 80a38b4:	681b      	ldr	r3, [r3, #0]
 80a38b6:	689b      	ldr	r3, [r3, #8]
 80a38b8:	9301      	str	r3, [sp, #4]
 80a38ba:	bd08      	pop	{r3, pc}
 80a38bc:	0806019c 	.word	0x0806019c

080a38c0 <HAL_Delay_Microseconds>:
DYNALIB_FN(BASE_IDX + 1, hal, HAL_Delay_Microseconds, void(uint32_t))
 80a38c0:	b508      	push	{r3, lr}
 80a38c2:	4b02      	ldr	r3, [pc, #8]	; (80a38cc <HAL_Delay_Microseconds+0xc>)
 80a38c4:	681b      	ldr	r3, [r3, #0]
 80a38c6:	68db      	ldr	r3, [r3, #12]
 80a38c8:	9301      	str	r3, [sp, #4]
 80a38ca:	bd08      	pop	{r3, pc}
 80a38cc:	0806019c 	.word	0x0806019c

080a38d0 <HAL_Timer_Get_Micro_Seconds>:
DYNALIB_FN(BASE_IDX + 2, hal, HAL_Timer_Get_Micro_Seconds, system_tick_t(void))
 80a38d0:	b508      	push	{r3, lr}
 80a38d2:	4b02      	ldr	r3, [pc, #8]	; (80a38dc <HAL_Timer_Get_Micro_Seconds+0xc>)
 80a38d4:	681b      	ldr	r3, [r3, #0]
 80a38d6:	691b      	ldr	r3, [r3, #16]
 80a38d8:	9301      	str	r3, [sp, #4]
 80a38da:	bd08      	pop	{r3, pc}
 80a38dc:	0806019c 	.word	0x0806019c

080a38e0 <HAL_Timer_Get_Milli_Seconds>:
DYNALIB_FN(BASE_IDX + 3, hal, HAL_Timer_Get_Milli_Seconds, system_tick_t(void))
 80a38e0:	b508      	push	{r3, lr}
 80a38e2:	4b02      	ldr	r3, [pc, #8]	; (80a38ec <HAL_Timer_Get_Milli_Seconds+0xc>)
 80a38e4:	681b      	ldr	r3, [r3, #0]
 80a38e6:	695b      	ldr	r3, [r3, #20]
 80a38e8:	9301      	str	r3, [sp, #4]
 80a38ea:	bd08      	pop	{r3, pc}
 80a38ec:	0806019c 	.word	0x0806019c

080a38f0 <HAL_EEPROM_Init>:
DYNALIB_FN(BASE_IDX + 4, hal, HAL_RTC_Configuration, void(void))
DYNALIB_FN(BASE_IDX + 5, hal, HAL_RTC_Get_UnixTime, time_t(void))
DYNALIB_FN(BASE_IDX + 6, hal, HAL_RTC_Set_UnixTime, void(time_t))
DYNALIB_FN(BASE_IDX + 7, hal, HAL_RTC_Set_UnixAlarm, void(time_t))

DYNALIB_FN(BASE_IDX + 8, hal, HAL_EEPROM_Init, void(void))
 80a38f0:	b508      	push	{r3, lr}
 80a38f2:	4b02      	ldr	r3, [pc, #8]	; (80a38fc <HAL_EEPROM_Init+0xc>)
 80a38f4:	681b      	ldr	r3, [r3, #0]
 80a38f6:	6a9b      	ldr	r3, [r3, #40]	; 0x28
 80a38f8:	9301      	str	r3, [sp, #4]
 80a38fa:	bd08      	pop	{r3, pc}
 80a38fc:	0806019c 	.word	0x0806019c

080a3900 <HAL_EEPROM_Read>:
DYNALIB_FN(BASE_IDX + 9, hal, HAL_EEPROM_Read, uint8_t(uint32_t))
 80a3900:	b508      	push	{r3, lr}
 80a3902:	4b02      	ldr	r3, [pc, #8]	; (80a390c <HAL_EEPROM_Read+0xc>)
 80a3904:	681b      	ldr	r3, [r3, #0]
 80a3906:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80a3908:	9301      	str	r3, [sp, #4]
 80a390a:	bd08      	pop	{r3, pc}
 80a390c:	0806019c 	.word	0x0806019c

080a3910 <HAL_EEPROM_Write>:
DYNALIB_FN(BASE_IDX + 10, hal, HAL_EEPROM_Write, void(uint32_t, uint8_t))
 80a3910:	b508      	push	{r3, lr}
 80a3912:	4b02      	ldr	r3, [pc, #8]	; (80a391c <HAL_EEPROM_Write+0xc>)
 80a3914:	681b      	ldr	r3, [r3, #0]
 80a3916:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80a3918:	9301      	str	r3, [sp, #4]
 80a391a:	bd08      	pop	{r3, pc}
 80a391c:	0806019c 	.word	0x0806019c

080a3920 <HAL_disable_irq>:
DYNALIB_FN(BASE_IDX + 11, hal, HAL_EEPROM_Length, size_t(void))

DYNALIB_FN(BASE_IDX + 12, hal, HAL_disable_irq, int(void))
 80a3920:	b508      	push	{r3, lr}
 80a3922:	4b02      	ldr	r3, [pc, #8]	; (80a392c <HAL_disable_irq+0xc>)
 80a3924:	681b      	ldr	r3, [r3, #0]
 80a3926:	6b9b      	ldr	r3, [r3, #56]	; 0x38
 80a3928:	9301      	str	r3, [sp, #4]
 80a392a:	bd08      	pop	{r3, pc}
 80a392c:	0806019c 	.word	0x0806019c

080a3930 <HAL_enable_irq>:
DYNALIB_FN(BASE_IDX + 13, hal, HAL_enable_irq, void(int))
 80a3930:	b508      	push	{r3, lr}
 80a3932:	4b02      	ldr	r3, [pc, #8]	; (80a393c <HAL_enable_irq+0xc>)
 80a3934:	681b      	ldr	r3, [r3, #0]
 80a3936:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80a3938:	9301      	str	r3, [sp, #4]
 80a393a:	bd08      	pop	{r3, pc}
 80a393c:	0806019c 	.word	0x0806019c

080a3940 <HAL_SPI_Init>:
DYNALIB_FN(2, hal_spi, HAL_SPI_Set_Bit_Order, void(HAL_SPI_Interface, uint8_t))
DYNALIB_FN(3, hal_spi, HAL_SPI_Set_Data_Mode, void(HAL_SPI_Interface, uint8_t))
DYNALIB_FN(4, hal_spi, HAL_SPI_Set_Clock_Divider, void(HAL_SPI_Interface, uint8_t))
DYNALIB_FN(5, hal_spi, HAL_SPI_Send_Receive_Data, uint16_t(HAL_SPI_Interface, uint16_t))
DYNALIB_FN(6, hal_spi, HAL_SPI_Is_Enabled_Old, bool(void))
DYNALIB_FN(7, hal_spi, HAL_SPI_Init, void(HAL_SPI_Interface))
 80a3940:	b508      	push	{r3, lr}
 80a3942:	4b02      	ldr	r3, [pc, #8]	; (80a394c <HAL_SPI_Init+0xc>)
 80a3944:	681b      	ldr	r3, [r3, #0]
 80a3946:	69db      	ldr	r3, [r3, #28]
 80a3948:	9301      	str	r3, [sp, #4]
 80a394a:	bd08      	pop	{r3, pc}
 80a394c:	080601b4 	.word	0x080601b4

080a3950 <HAL_SPI_Is_Enabled>:
DYNALIB_FN(8, hal_spi, HAL_SPI_Is_Enabled, bool(HAL_SPI_Interface))
 80a3950:	b508      	push	{r3, lr}
 80a3952:	4b02      	ldr	r3, [pc, #8]	; (80a395c <HAL_SPI_Is_Enabled+0xc>)
 80a3954:	681b      	ldr	r3, [r3, #0]
 80a3956:	6a1b      	ldr	r3, [r3, #32]
 80a3958:	9301      	str	r3, [sp, #4]
 80a395a:	bd08      	pop	{r3, pc}
 80a395c:	080601b4 	.word	0x080601b4

080a3960 <HAL_Pin_Map>:
// New HAL functions must be added to the end of this list.
// GNINRAW

DYNALIB_BEGIN(hal_gpio)

DYNALIB_FN(0, hal_gpio, HAL_Pin_Map, STM32_Pin_Info*(void))
 80a3960:	b508      	push	{r3, lr}
 80a3962:	4b02      	ldr	r3, [pc, #8]	; (80a396c <HAL_Pin_Map+0xc>)
 80a3964:	681b      	ldr	r3, [r3, #0]
 80a3966:	681b      	ldr	r3, [r3, #0]
 80a3968:	9301      	str	r3, [sp, #4]
 80a396a:	bd08      	pop	{r3, pc}
 80a396c:	080601b0 	.word	0x080601b0

080a3970 <HAL_Validate_Pin_Function>:
DYNALIB_FN(1, hal_gpio, HAL_Validate_Pin_Function, PinFunction(pin_t, PinFunction))
 80a3970:	b508      	push	{r3, lr}
 80a3972:	4b02      	ldr	r3, [pc, #8]	; (80a397c <HAL_Validate_Pin_Function+0xc>)
 80a3974:	681b      	ldr	r3, [r3, #0]
 80a3976:	685b      	ldr	r3, [r3, #4]
 80a3978:	9301      	str	r3, [sp, #4]
 80a397a:	bd08      	pop	{r3, pc}
 80a397c:	080601b0 	.word	0x080601b0

080a3980 <HAL_Pin_Mode>:
DYNALIB_FN(2, hal_gpio, HAL_Pin_Mode, void(pin_t, PinMode))
 80a3980:	b508      	push	{r3, lr}
 80a3982:	4b02      	ldr	r3, [pc, #8]	; (80a398c <HAL_Pin_Mode+0xc>)
 80a3984:	681b      	ldr	r3, [r3, #0]
 80a3986:	689b      	ldr	r3, [r3, #8]
 80a3988:	9301      	str	r3, [sp, #4]
 80a398a:	bd08      	pop	{r3, pc}
 80a398c:	080601b0 	.word	0x080601b0

080a3990 <HAL_ADC_Read>:
DYNALIB_FN(8, hal_gpio, HAL_Interrupts_Enable_All, void(void))
DYNALIB_FN(9, hal_gpio, HAL_Interrupts_Disable_All, void(void))

DYNALIB_FN(10, hal_gpio, HAL_DAC_Write, void(pin_t, uint16_t))
DYNALIB_FN(11, hal_gpio, HAL_ADC_Set_Sample_Time, void(uint8_t))
DYNALIB_FN(12, hal_gpio, HAL_ADC_Read, int32_t(uint16_t))
 80a3990:	b508      	push	{r3, lr}
 80a3992:	4b02      	ldr	r3, [pc, #8]	; (80a399c <HAL_ADC_Read+0xc>)
 80a3994:	681b      	ldr	r3, [r3, #0]
 80a3996:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80a3998:	9301      	str	r3, [sp, #4]
 80a399a:	bd08      	pop	{r3, pc}
 80a399c:	080601b0 	.word	0x080601b0

080a39a0 <HAL_Pulse_In>:

DYNALIB_FN(16, hal_gpio, HAL_Set_System_Interrupt_Handler, uint8_t(hal_irq_t, const HAL_InterruptCallback*, HAL_InterruptCallback*, void*))
DYNALIB_FN(17, hal_gpio, HAL_Get_System_Interrupt_Handler, uint8_t(hal_irq_t, HAL_InterruptCallback*, void*))
DYNALIB_FN(18, hal_gpio, HAL_System_Interrupt_Trigger, void(hal_irq_t, void*))

DYNALIB_FN(19, hal_gpio, HAL_Pulse_In, uint32_t(pin_t, uint16_t))
 80a39a0:	b508      	push	{r3, lr}
 80a39a2:	4b02      	ldr	r3, [pc, #8]	; (80a39ac <HAL_Pulse_In+0xc>)
 80a39a4:	681b      	ldr	r3, [r3, #0]
 80a39a6:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 80a39a8:	9301      	str	r3, [sp, #4]
 80a39aa:	bd08      	pop	{r3, pc}
 80a39ac:	080601b0 	.word	0x080601b0

080a39b0 <log_message>:
DYNALIB_FN(16, services, log_print_, void(int, int, const char*, const char*, const char*, ...)) // Deprecated
DYNALIB_FN(17, services, LED_RGB_SetChangeHandler, void(led_update_handler_fn, void*))
DYNALIB_FN(18, services, log_print_direct_, void(int, void*, const char*, ...)) // Deprecated
DYNALIB_FN(19, services, LED_GetColor, uint32_t(uint32_t, void*))

DYNALIB_FN(20, services, log_message, void(int, const char*, LogAttributes*, void*, const char*, ...))
 80a39b0:	b508      	push	{r3, lr}
 80a39b2:	4b02      	ldr	r3, [pc, #8]	; (80a39bc <log_message+0xc>)
 80a39b4:	681b      	ldr	r3, [r3, #0]
 80a39b6:	6d1b      	ldr	r3, [r3, #80]	; 0x50
 80a39b8:	9301      	str	r3, [sp, #4]
 80a39ba:	bd08      	pop	{r3, pc}
 80a39bc:	080201a8 	.word	0x080201a8

080a39c0 <spark_deviceID>:
DYNALIB_FN(2, system_cloud, spark_process, void(void))
DYNALIB_FN(3, system_cloud, spark_cloud_flag_connect, void(void))
DYNALIB_FN(4, system_cloud, spark_cloud_flag_disconnect, void(void))
DYNALIB_FN(5, system_cloud, spark_cloud_flag_connected, bool(void))
DYNALIB_FN(6, system_cloud, system_cloud_protocol_instance, ProtocolFacade*(void))
DYNALIB_FN(7, system_cloud, spark_deviceID, String(void))
 80a39c0:	b508      	push	{r3, lr}
 80a39c2:	4b02      	ldr	r3, [pc, #8]	; (80a39cc <spark_deviceID+0xc>)
 80a39c4:	681b      	ldr	r3, [r3, #0]
 80a39c6:	69db      	ldr	r3, [r3, #28]
 80a39c8:	9301      	str	r3, [sp, #4]
 80a39ca:	bd08      	pop	{r3, pc}
 80a39cc:	080601cc 	.word	0x080601cc

080a39d0 <spark_send_event>:
DYNALIB_FN(8, system_cloud, spark_send_event, bool(const char*, const char*, int, uint32_t, void*))
 80a39d0:	b508      	push	{r3, lr}
 80a39d2:	4b02      	ldr	r3, [pc, #8]	; (80a39dc <spark_send_event+0xc>)
 80a39d4:	681b      	ldr	r3, [r3, #0]
 80a39d6:	6a1b      	ldr	r3, [r3, #32]
 80a39d8:	9301      	str	r3, [sp, #4]
 80a39da:	bd08      	pop	{r3, pc}
 80a39dc:	080601cc 	.word	0x080601cc

080a39e0 <spark_sync_time>:
DYNALIB_FN(9, system_cloud, spark_subscribe, bool(const char*, EventHandler, void*, Spark_Subscription_Scope_TypeDef, const char*, void*))
DYNALIB_FN(10, system_cloud, spark_unsubscribe, void(void*))
DYNALIB_FN(11, system_cloud, spark_sync_time, bool(void*))
 80a39e0:	b508      	push	{r3, lr}
 80a39e2:	4b02      	ldr	r3, [pc, #8]	; (80a39ec <spark_sync_time+0xc>)
 80a39e4:	681b      	ldr	r3, [r3, #0]
 80a39e6:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80a39e8:	9301      	str	r3, [sp, #4]
 80a39ea:	bd08      	pop	{r3, pc}
 80a39ec:	080601cc 	.word	0x080601cc

080a39f0 <spark_set_random_seed_from_cloud_handler>:
DYNALIB_FN(12, system_cloud, spark_sync_time_pending, bool(void*))
DYNALIB_FN(13, system_cloud, spark_sync_time_last, system_tick_t(time_t*, void*))
DYNALIB_FN(14, system_cloud, spark_set_connection_property, int(unsigned, unsigned, particle::protocol::connection_properties_t*, void*))
DYNALIB_FN(15, system_cloud, spark_set_random_seed_from_cloud_handler, int(void (*handler)(unsigned int), void*))
 80a39f0:	b508      	push	{r3, lr}
 80a39f2:	4b02      	ldr	r3, [pc, #8]	; (80a39fc <spark_set_random_seed_from_cloud_handler+0xc>)
 80a39f4:	681b      	ldr	r3, [r3, #0]
 80a39f6:	6bdb      	ldr	r3, [r3, #60]	; 0x3c
 80a39f8:	9301      	str	r3, [sp, #4]
 80a39fa:	bd08      	pop	{r3, pc}
 80a39fc:	080601cc 	.word	0x080601cc

080a3a00 <network_ready>:

DYNALIB_FN(0, system_net, network_config, const void*(network_handle_t, uint32_t, void*))
DYNALIB_FN(1, system_net, network_connect, void(network_handle_t, uint32_t, uint32_t, void*))
DYNALIB_FN(2, system_net, network_connecting, bool(network_handle_t, uint32_t, void*))
DYNALIB_FN(3, system_net, network_disconnect, void(network_handle_t, uint32_t, void*))
DYNALIB_FN(4, system_net, network_ready, bool(network_handle_t, uint32_t, void*))
 80a3a00:	b508      	push	{r3, lr}
 80a3a02:	4b02      	ldr	r3, [pc, #8]	; (80a3a0c <network_ready+0xc>)
 80a3a04:	681b      	ldr	r3, [r3, #0]
 80a3a06:	691b      	ldr	r3, [r3, #16]
 80a3a08:	9301      	str	r3, [sp, #4]
 80a3a0a:	bd08      	pop	{r3, pc}
 80a3a0c:	080601c8 	.word	0x080601c8

080a3a10 <set_system_mode>:
#endif

DYNALIB_BEGIN(system)

DYNALIB_FN(0, system, system_mode, System_Mode_TypeDef(void))
DYNALIB_FN(1, system, set_system_mode, void(System_Mode_TypeDef))
 80a3a10:	b508      	push	{r3, lr}
 80a3a12:	4b02      	ldr	r3, [pc, #8]	; (80a3a1c <set_system_mode+0xc>)
 80a3a14:	681b      	ldr	r3, [r3, #0]
 80a3a16:	685b      	ldr	r3, [r3, #4]
 80a3a18:	9301      	str	r3, [sp, #4]
 80a3a1a:	bd08      	pop	{r3, pc}
 80a3a1c:	080601a4 	.word	0x080601a4

080a3a20 <system_delay_ms>:

DYNALIB_FN(2, system, set_ymodem_serial_flash_update_handler, void(ymodem_serial_flash_update_handler))
DYNALIB_FN(3, system, system_firmwareUpdate, bool(Stream*, void*))
DYNALIB_FN(4, system, system_fileTransfer, bool(system_file_transfer_t*, void*))

DYNALIB_FN(5, system, system_delay_ms, void(unsigned long, bool))
 80a3a20:	b508      	push	{r3, lr}
 80a3a22:	4b02      	ldr	r3, [pc, #8]	; (80a3a2c <system_delay_ms+0xc>)
 80a3a24:	681b      	ldr	r3, [r3, #0]
 80a3a26:	695b      	ldr	r3, [r3, #20]
 80a3a28:	9301      	str	r3, [sp, #4]
 80a3a2a:	bd08      	pop	{r3, pc}
 80a3a2c:	080601a4 	.word	0x080601a4

080a3a30 <system_version_info>:
DYNALIB_FN(7, system, system_sleep_pin, void(uint16_t, uint16_t, long, uint32_t, void*))
DYNALIB_FN(8, system, system_subscribe_event, int(system_event_t, system_event_handler_t*, void*))
DYNALIB_FN(9, system, system_unsubscribe_event, void(system_event_t, system_event_handler_t*, void*))
DYNALIB_FN(10, system, system_button_pushed_duration, uint16_t(uint8_t, void*))
DYNALIB_FN(11, system, system_thread_set_state, void(spark::feature::State, void*))
DYNALIB_FN(12, system, system_version_info, int(SystemVersionInfo*, void*))
 80a3a30:	b508      	push	{r3, lr}
 80a3a32:	4b02      	ldr	r3, [pc, #8]	; (80a3a3c <system_version_info+0xc>)
 80a3a34:	681b      	ldr	r3, [r3, #0]
 80a3a36:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80a3a38:	9301      	str	r3, [sp, #4]
 80a3a3a:	bd08      	pop	{r3, pc}
 80a3a3c:	080601a4 	.word	0x080601a4

080a3a40 <application_thread_current>:
DYNALIB_FN(15, system, system_get_flag, int(system_flag_t, uint8_t*, void*))
DYNALIB_FN(16, system, Spark_Prepare_For_Firmware_Update, int(FileTransfer::Descriptor&, uint32_t, void*))
DYNALIB_FN(17, system, Spark_Save_Firmware_Chunk, int(FileTransfer::Descriptor&, const uint8_t*, void*))
DYNALIB_FN(18, system, Spark_Finish_Firmware_Update, int(FileTransfer::Descriptor&, uint32_t, void*))

DYNALIB_FN(19, system, application_thread_current, uint8_t(void*))
 80a3a40:	b508      	push	{r3, lr}
 80a3a42:	4b02      	ldr	r3, [pc, #8]	; (80a3a4c <application_thread_current+0xc>)
 80a3a44:	681b      	ldr	r3, [r3, #0]
 80a3a46:	6cdb      	ldr	r3, [r3, #76]	; 0x4c
 80a3a48:	9301      	str	r3, [sp, #4]
 80a3a4a:	bd08      	pop	{r3, pc}
 80a3a4c:	080601a4 	.word	0x080601a4

080a3a50 <application_thread_invoke>:
DYNALIB_FN(20, system, system_thread_current, uint8_t(void*))
DYNALIB_FN(21, system, application_thread_invoke, uint8_t(void(*)(void*), void*, void*))
 80a3a50:	b508      	push	{r3, lr}
 80a3a52:	4b02      	ldr	r3, [pc, #8]	; (80a3a5c <application_thread_invoke+0xc>)
 80a3a54:	681b      	ldr	r3, [r3, #0]
 80a3a56:	6d5b      	ldr	r3, [r3, #84]	; 0x54
 80a3a58:	9301      	str	r3, [sp, #4]
 80a3a5a:	bd08      	pop	{r3, pc}
 80a3a5c:	080601a4 	.word	0x080601a4

080a3a60 <system_ctrl_set_app_request_handler>:
DYNALIB_FN(BASE_IDX + 6, system, led_pattern_period, uint16_t(int, int, void*))
DYNALIB_FN(BASE_IDX + 7, system, system_set_tester_handlers, int(system_tester_handlers_t*, void*))
DYNALIB_FN(BASE_IDX + 8, system, system_format_diag_data, int(const uint16_t*, size_t, unsigned, appender_fn, void*, void*))

// Control requests
DYNALIB_FN(BASE_IDX + 9, system, system_ctrl_set_app_request_handler, int(ctrl_request_handler_fn, void*))
 80a3a60:	b508      	push	{r3, lr}
 80a3a62:	4b03      	ldr	r3, [pc, #12]	; (80a3a70 <system_ctrl_set_app_request_handler+0x10>)
 80a3a64:	681b      	ldr	r3, [r3, #0]
 80a3a66:	f8d3 3090 	ldr.w	r3, [r3, #144]	; 0x90
 80a3a6a:	9301      	str	r3, [sp, #4]
 80a3a6c:	bd08      	pop	{r3, pc}
 80a3a6e:	0000      	.short	0x0000
 80a3a70:	080601a4 	.word	0x080601a4

080a3a74 <system_ctrl_set_result>:
DYNALIB_FN(BASE_IDX + 10, system, system_ctrl_alloc_reply_data, int(ctrl_request*, size_t, void*))
DYNALIB_FN(BASE_IDX + 11, system, system_ctrl_free_request_data, void(ctrl_request*, void*))
DYNALIB_FN(BASE_IDX + 12, system, system_ctrl_set_result, void(ctrl_request*, int, ctrl_completion_handler_fn, void*, void*))
 80a3a74:	b508      	push	{r3, lr}
 80a3a76:	4b03      	ldr	r3, [pc, #12]	; (80a3a84 <system_ctrl_set_result+0x10>)
 80a3a78:	681b      	ldr	r3, [r3, #0]
 80a3a7a:	f8d3 309c 	ldr.w	r3, [r3, #156]	; 0x9c
 80a3a7e:	9301      	str	r3, [sp, #4]
 80a3a80:	bd08      	pop	{r3, pc}
 80a3a82:	0000      	.short	0x0000
 80a3a84:	080601a4 	.word	0x080601a4

080a3a88 <malloc>:

#include "dynalib.h"

DYNALIB_BEGIN(rt)

DYNALIB_FN(0, rt, malloc, void*(size_t))
 80a3a88:	b508      	push	{r3, lr}
 80a3a8a:	4b02      	ldr	r3, [pc, #8]	; (80a3a94 <malloc+0xc>)
 80a3a8c:	681b      	ldr	r3, [r3, #0]
 80a3a8e:	681b      	ldr	r3, [r3, #0]
 80a3a90:	9301      	str	r3, [sp, #4]
 80a3a92:	bd08      	pop	{r3, pc}
 80a3a94:	080601a0 	.word	0x080601a0

080a3a98 <free>:
DYNALIB_FN(1, rt, free, void(void*))
 80a3a98:	b508      	push	{r3, lr}
 80a3a9a:	4b02      	ldr	r3, [pc, #8]	; (80a3aa4 <free+0xc>)
 80a3a9c:	681b      	ldr	r3, [r3, #0]
 80a3a9e:	685b      	ldr	r3, [r3, #4]
 80a3aa0:	9301      	str	r3, [sp, #4]
 80a3aa2:	bd08      	pop	{r3, pc}
 80a3aa4:	080601a0 	.word	0x080601a0

080a3aa8 <realloc>:
DYNALIB_FN(2, rt, realloc, void*(void*, size_t))
 80a3aa8:	b508      	push	{r3, lr}
 80a3aaa:	4b02      	ldr	r3, [pc, #8]	; (80a3ab4 <realloc+0xc>)
 80a3aac:	681b      	ldr	r3, [r3, #0]
 80a3aae:	689b      	ldr	r3, [r3, #8]
 80a3ab0:	9301      	str	r3, [sp, #4]
 80a3ab2:	bd08      	pop	{r3, pc}
 80a3ab4:	080601a0 	.word	0x080601a0

080a3ab8 <vsnprintf>:
DYNALIB_FN(4, rt, siprintf, int(char*, const char*, ...))
DYNALIB_FN(5, rt, sscanf, int(const char*, const char*, ...))
DYNALIB_FN(6, rt, siscanf, int(const char*, const char*, ...))
DYNALIB_FN(7, rt, snprintf, int(char*, size_t, const char*, ...))
DYNALIB_FN(8, rt, sniprintf, int(char*, size_t, const char*, ...))
DYNALIB_FN(9, rt, vsnprintf, int(char*, size_t, const char*, va_list))
 80a3ab8:	b508      	push	{r3, lr}
 80a3aba:	4b02      	ldr	r3, [pc, #8]	; (80a3ac4 <vsnprintf+0xc>)
 80a3abc:	681b      	ldr	r3, [r3, #0]
 80a3abe:	6a5b      	ldr	r3, [r3, #36]	; 0x24
 80a3ac0:	9301      	str	r3, [sp, #4]
 80a3ac2:	bd08      	pop	{r3, pc}
 80a3ac4:	080601a0 	.word	0x080601a0

080a3ac8 <abort>:
DYNALIB_FN(10, rt, vsniprintf, int(char*, size_t, const char*, va_list))
DYNALIB_FN(11, rt, abort, void(void))
 80a3ac8:	b508      	push	{r3, lr}
 80a3aca:	4b02      	ldr	r3, [pc, #8]	; (80a3ad4 <abort+0xc>)
 80a3acc:	681b      	ldr	r3, [r3, #0]
 80a3ace:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80a3ad0:	9301      	str	r3, [sp, #4]
 80a3ad2:	bd08      	pop	{r3, pc}
 80a3ad4:	080601a0 	.word	0x080601a0

080a3ad8 <_malloc_r>:
DYNALIB_FN(12, rt, _malloc_r, void*(struct _reent*, size_t))
 80a3ad8:	b508      	push	{r3, lr}
 80a3ada:	4b02      	ldr	r3, [pc, #8]	; (80a3ae4 <_malloc_r+0xc>)
 80a3adc:	681b      	ldr	r3, [r3, #0]
 80a3ade:	6b1b      	ldr	r3, [r3, #48]	; 0x30
 80a3ae0:	9301      	str	r3, [sp, #4]
 80a3ae2:	bd08      	pop	{r3, pc}
 80a3ae4:	080601a0 	.word	0x080601a0

080a3ae8 <_ZNSt16_Sp_counted_baseILN9__gnu_cxx12_Lock_policyE0EE10_M_releaseEv.part.3.constprop.12>:
    _Sp_counted_base<_S_single>::_M_add_ref_copy()
    { ++_M_use_count; }

  template<>
    inline void
    _Sp_counted_base<_S_single>::_M_release() noexcept
 80a3ae8:	b510      	push	{r4, lr}
 80a3aea:	4604      	mov	r4, r0
    {
      if (--_M_use_count == 0)
        {
          _M_dispose();
 80a3aec:	6803      	ldr	r3, [r0, #0]
 80a3aee:	689b      	ldr	r3, [r3, #8]
 80a3af0:	4798      	blx	r3
          if (--_M_weak_count == 0)
 80a3af2:	68a3      	ldr	r3, [r4, #8]
 80a3af4:	3b01      	subs	r3, #1
 80a3af6:	60a3      	str	r3, [r4, #8]
 80a3af8:	b92b      	cbnz	r3, 80a3b06 <_ZNSt16_Sp_counted_baseILN9__gnu_cxx12_Lock_policyE0EE10_M_releaseEv.part.3.constprop.12+0x1e>
            _M_destroy();
 80a3afa:	6823      	ldr	r3, [r4, #0]
 80a3afc:	4620      	mov	r0, r4
        }
    }
 80a3afe:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    {
      if (--_M_use_count == 0)
        {
          _M_dispose();
          if (--_M_weak_count == 0)
            _M_destroy();
 80a3b02:	68db      	ldr	r3, [r3, #12]
 80a3b04:	4718      	bx	r3
 80a3b06:	bd10      	pop	{r4, pc}

080a3b08 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev>:
      explicit __shared_count(const __weak_count<_Lp>& __r);

      // Does not throw if __r._M_get_use_count() == 0, caller must check.
      explicit __shared_count(const __weak_count<_Lp>& __r, std::nothrow_t);

      ~__shared_count() noexcept
 80a3b08:	b510      	push	{r4, lr}
 80a3b0a:	4604      	mov	r4, r0
      {
	if (_M_pi != nullptr)
 80a3b0c:	6800      	ldr	r0, [r0, #0]
 80a3b0e:	b128      	cbz	r0, 80a3b1c <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev+0x14>

  template<>
    inline void
    _Sp_counted_base<_S_single>::_M_release() noexcept
    {
      if (--_M_use_count == 0)
 80a3b10:	6843      	ldr	r3, [r0, #4]
 80a3b12:	3b01      	subs	r3, #1
 80a3b14:	6043      	str	r3, [r0, #4]
 80a3b16:	b90b      	cbnz	r3, 80a3b1c <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev+0x14>
 80a3b18:	f7ff ffe6 	bl	80a3ae8 <_ZNSt16_Sp_counted_baseILN9__gnu_cxx12_Lock_policyE0EE10_M_releaseEv.part.3.constprop.12>

      ~__shared_count() noexcept
      {
	if (_M_pi != nullptr)
	  _M_pi->_M_release();
      }
 80a3b1c:	4620      	mov	r0, r4
 80a3b1e:	bd10      	pop	{r4, pc}

080a3b20 <_ZN5spark9WiFiClassD1Ev>:
        wlan_set_ipaddress_source(source, true, NULL);
    }

public:
    WiFiClass() {}
    ~WiFiClass() {}
 80a3b20:	4770      	bx	lr

080a3b22 <_ZN5spark9WiFiClass5readyEv>:
    bool connecting(void) {
        return network_connecting(*this, 0, NULL);
    }

    bool ready(void) {
        return network_ready(*this, 0, NULL);
 80a3b22:	2200      	movs	r2, #0
 80a3b24:	4611      	mov	r1, r2
 80a3b26:	4610      	mov	r0, r2
 80a3b28:	f7ff bf6a 	b.w	80a3a00 <network_ready>

080a3b2c <_GLOBAL__sub_I__ZN10WiFiSignalC2ERK21wlan_connected_info_t>:
    void setIPAddressSource(IPAddressSource source) {
        wlan_set_ipaddress_source(source, true, NULL);
    }

public:
    WiFiClass() {}
 80a3b2c:	4803      	ldr	r0, [pc, #12]	; (80a3b3c <_GLOBAL__sub_I__ZN10WiFiSignalC2ERK21wlan_connected_info_t+0x10>)
 80a3b2e:	4b04      	ldr	r3, [pc, #16]	; (80a3b40 <_GLOBAL__sub_I__ZN10WiFiSignalC2ERK21wlan_connected_info_t+0x14>)
one second timeout is reached). If the aforementioned "bug" is ever fixed by
TI, no changes need to be made to this function, as it would be implemented
the same way.
*****************************************************************************/

    WiFiClass WiFi;
 80a3b30:	4a04      	ldr	r2, [pc, #16]	; (80a3b44 <_GLOBAL__sub_I__ZN10WiFiSignalC2ERK21wlan_connected_info_t+0x18>)
 80a3b32:	4905      	ldr	r1, [pc, #20]	; (80a3b48 <_GLOBAL__sub_I__ZN10WiFiSignalC2ERK21wlan_connected_info_t+0x1c>)
 80a3b34:	6003      	str	r3, [r0, #0]
 80a3b36:	f001 bb29 	b.w	80a518c <__aeabi_atexit>
 80a3b3a:	bf00      	nop
 80a3b3c:	20000908 	.word	0x20000908
 80a3b40:	080a6978 	.word	0x080a6978
 80a3b44:	20000380 	.word	0x20000380
 80a3b48:	080a3b21 	.word	0x080a3b21

080a3b4c <_Z6randomi>:
#include "spark_wiring_random.h"
#include <stdlib.h>

int random(int max)
{
 80a3b4c:	b510      	push	{r4, lr}
  if (0 == max) {
 80a3b4e:	4604      	mov	r4, r0
 80a3b50:	b130      	cbz	r0, 80a3b60 <_Z6randomi+0x14>
    return 0;
  }
  return rand() % max;
 80a3b52:	f002 fb57 	bl	80a6204 <rand>
 80a3b56:	fb90 f3f4 	sdiv	r3, r0, r4
 80a3b5a:	fb03 0014 	mls	r0, r3, r4, r0
 80a3b5e:	bd10      	pop	{r4, pc}
}
 80a3b60:	bd10      	pop	{r4, pc}

080a3b62 <_Z6randomii>:

int random(int min, int max)
{
  if (min >= max) {
 80a3b62:	4288      	cmp	r0, r1
  }
  return rand() % max;
}

int random(int min, int max)
{
 80a3b64:	b510      	push	{r4, lr}
 80a3b66:	4604      	mov	r4, r0
  if (min >= max) {
 80a3b68:	da04      	bge.n	80a3b74 <_Z6randomii+0x12>
    return min;
  }
  return random(max - min) + min;
 80a3b6a:	1a08      	subs	r0, r1, r0
 80a3b6c:	f7ff ffee 	bl	80a3b4c <_Z6randomi>
 80a3b70:	4420      	add	r0, r4
 80a3b72:	bd10      	pop	{r4, pc}
}
 80a3b74:	bd10      	pop	{r4, pc}

080a3b76 <_Z10randomSeedj>:

void randomSeed(unsigned int seed)
{
  srand(seed);
 80a3b76:	f002 bb1d 	b.w	80a61b4 <srand>

080a3b7a <_ZN8particle6detail21futureCallbackWrapperEPv>:
 * License along with this library; if not, see <http://www.gnu.org/licenses/>.
 */

#include "spark_wiring_async.h"

void particle::detail::futureCallbackWrapper(void* data) {
 80a3b7a:	b510      	push	{r4, lr}
  template<typename _Res, typename... _ArgTypes>
    _Res
    function<_Res(_ArgTypes...)>::
    operator()(_ArgTypes... __args) const
    {
      if (_M_empty())
 80a3b7c:	6883      	ldr	r3, [r0, #8]
 80a3b7e:	4604      	mov	r4, r0
 80a3b80:	b90b      	cbnz	r3, 80a3b86 <_ZN8particle6detail21futureCallbackWrapperEPv+0xc>
	__throw_bad_function_call();
 80a3b82:	f001 fb20 	bl	80a51c6 <_ZSt25__throw_bad_function_callv>
      return _M_invoker(_M_functor, std::forward<_ArgTypes>(__args)...);
 80a3b86:	68c3      	ldr	r3, [r0, #12]
 80a3b88:	4798      	blx	r3

    _Function_base() : _M_manager(nullptr) { }

    ~_Function_base()
    {
      if (_M_manager)
 80a3b8a:	68a3      	ldr	r3, [r4, #8]
 80a3b8c:	b11b      	cbz	r3, 80a3b96 <_ZN8particle6detail21futureCallbackWrapperEPv+0x1c>
	_M_manager(_M_functor, _M_functor, __destroy_functor);
 80a3b8e:	2203      	movs	r2, #3
 80a3b90:	4621      	mov	r1, r4
 80a3b92:	4620      	mov	r0, r4
 80a3b94:	4798      	blx	r3
    auto callbackPtr = static_cast<const std::function<void()>*>(data);
    (*callbackPtr)();
    delete callbackPtr;
 80a3b96:	4620      	mov	r0, r4
}
 80a3b98:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
#include "spark_wiring_async.h"

void particle::detail::futureCallbackWrapper(void* data) {
    auto callbackPtr = static_cast<const std::function<void()>*>(data);
    (*callbackPtr)();
    delete callbackPtr;
 80a3b9c:	f7fc ba81 	b.w	80a00a2 <_ZdlPv>

080a3ba0 <_ZN7TwoWireD1Ev>:
private:
  HAL_I2C_Interface _i2c;

public:
  TwoWire(HAL_I2C_Interface i2c);
  virtual ~TwoWire() {};
 80a3ba0:	4770      	bx	lr

080a3ba2 <_ZN7TwoWire5writeEPKhj>:

// must be called in:
// slave tx event callback
// or after beginTransmission(address)
size_t TwoWire::write(const uint8_t *data, size_t quantity)
{
 80a3ba2:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80a3ba4:	4606      	mov	r6, r0
 80a3ba6:	4615      	mov	r5, r2
 80a3ba8:	460c      	mov	r4, r1
 80a3baa:	188f      	adds	r7, r1, r2
  // in master/slave transmitter mode
  for(size_t i = 0; i < quantity; ++i)
 80a3bac:	42bc      	cmp	r4, r7
 80a3bae:	d006      	beq.n	80a3bbe <_ZN7TwoWire5writeEPKhj+0x1c>
  {
    write(data[i]);
 80a3bb0:	6833      	ldr	r3, [r6, #0]
 80a3bb2:	f814 1b01 	ldrb.w	r1, [r4], #1
 80a3bb6:	689b      	ldr	r3, [r3, #8]
 80a3bb8:	4630      	mov	r0, r6
 80a3bba:	4798      	blx	r3
// slave tx event callback
// or after beginTransmission(address)
size_t TwoWire::write(const uint8_t *data, size_t quantity)
{
  // in master/slave transmitter mode
  for(size_t i = 0; i < quantity; ++i)
 80a3bbc:	e7f6      	b.n	80a3bac <_ZN7TwoWire5writeEPKhj+0xa>
  {
    write(data[i]);
  }

  return quantity;
}
 80a3bbe:	4628      	mov	r0, r5
 80a3bc0:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

080a3bc2 <_ZN7TwoWire5writeEh>:
// must be called in:
// slave tx event callback
// or after beginTransmission(address)
size_t TwoWire::write(uint8_t data)
{
  return HAL_I2C_Write_Data(_i2c, data, NULL);
 80a3bc2:	2200      	movs	r2, #0
 80a3bc4:	7c00      	ldrb	r0, [r0, #16]
 80a3bc6:	f7ff bd89 	b.w	80a36dc <HAL_I2C_Write_Data>

080a3bca <_ZN7TwoWire9availableEv>:
// must be called in:
// slave rx event callback
// or after requestFrom(address, numBytes)
int TwoWire::available(void)
{
  return HAL_I2C_Available_Data(_i2c, NULL);
 80a3bca:	2100      	movs	r1, #0
 80a3bcc:	7c00      	ldrb	r0, [r0, #16]
 80a3bce:	f7ff bd8d 	b.w	80a36ec <HAL_I2C_Available_Data>

080a3bd2 <_ZN7TwoWire4readEv>:
// must be called in:
// slave rx event callback
// or after requestFrom(address, numBytes)
int TwoWire::read(void)
{
  return HAL_I2C_Read_Data(_i2c, NULL);
 80a3bd2:	2100      	movs	r1, #0
 80a3bd4:	7c00      	ldrb	r0, [r0, #16]
 80a3bd6:	f7ff bd91 	b.w	80a36fc <HAL_I2C_Read_Data>

080a3bda <_ZN7TwoWire4peekEv>:
// must be called in:
// slave rx event callback
// or after requestFrom(address, numBytes)
int TwoWire::peek(void)
{
  return HAL_I2C_Peek_Data(_i2c, NULL);
 80a3bda:	2100      	movs	r1, #0
 80a3bdc:	7c00      	ldrb	r0, [r0, #16]
 80a3bde:	f7ff bd95 	b.w	80a370c <HAL_I2C_Peek_Data>

080a3be2 <_ZN7TwoWire5flushEv>:
}

void TwoWire::flush(void)
{
  HAL_I2C_Flush_Data(_i2c, NULL);
 80a3be2:	2100      	movs	r1, #0
 80a3be4:	7c00      	ldrb	r0, [r0, #16]
 80a3be6:	f7ff bd99 	b.w	80a371c <HAL_I2C_Flush_Data>

080a3bea <_ZN7TwoWireD0Ev>:
 80a3bea:	b510      	push	{r4, lr}
 80a3bec:	4604      	mov	r4, r0
 80a3bee:	f7fc fa58 	bl	80a00a2 <_ZdlPv>
 80a3bf2:	4620      	mov	r0, r4
 80a3bf4:	bd10      	pop	{r4, pc}
	...

080a3bf8 <_ZN7TwoWireC1E17HAL_I2C_Interface>:
#include "i2c_hal.h"
#include "spark_wiring_thread.h"

// Constructors ////////////////////////////////////////////////////////////////

TwoWire::TwoWire(HAL_I2C_Interface i2c)
 80a3bf8:	b510      	push	{r4, lr}
 80a3bfa:	4604      	mov	r4, r0
 80a3bfc:	4608      	mov	r0, r1
    virtual int available() = 0;
    virtual int read() = 0;
    virtual int peek() = 0;
    virtual void flush() = 0;

    Stream() {_timeout=1000;}
 80a3bfe:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 80a3c02:	60a3      	str	r3, [r4, #8]
 80a3c04:	4b04      	ldr	r3, [pc, #16]	; (80a3c18 <_ZN7TwoWireC1E17HAL_I2C_Interface+0x20>)
  protected:
    void setWriteError(int err = 1) { write_error = err; }
    size_t printf_impl(bool newline, const char* format, ...);

  public:
    Print() : write_error(0) {}
 80a3c06:	2100      	movs	r1, #0
{
  _i2c = i2c;
 80a3c08:	7420      	strb	r0, [r4, #16]
 80a3c0a:	6061      	str	r1, [r4, #4]
#include "i2c_hal.h"
#include "spark_wiring_thread.h"

// Constructors ////////////////////////////////////////////////////////////////

TwoWire::TwoWire(HAL_I2C_Interface i2c)
 80a3c0c:	6023      	str	r3, [r4, #0]
{
  _i2c = i2c;
  HAL_I2C_Init(_i2c, NULL);
 80a3c0e:	f7ff fd95 	bl	80a373c <HAL_I2C_Init>

}
 80a3c12:	4620      	mov	r0, r4
 80a3c14:	bd10      	pop	{r4, pc}
 80a3c16:	bf00      	nop
 80a3c18:	080a6988 	.word	0x080a6988

080a3c1c <_ZN7TwoWire9isEnabledEv>:
  HAL_I2C_Set_Callback_On_Request(_i2c, function, NULL);
}

bool TwoWire::isEnabled()
{
  return HAL_I2C_Is_Enabled(_i2c, NULL);
 80a3c1c:	2100      	movs	r1, #0
 80a3c1e:	7c00      	ldrb	r0, [r0, #16]
 80a3c20:	f7ff bd84 	b.w	80a372c <HAL_I2C_Is_Enabled>

080a3c24 <_ZN9USBSerial14blockOnOverrunEb>:
  HAL_USB_USART_Flush_Data(_serial);
}

void USBSerial::blockOnOverrun(bool block)
{
  _blocking = block;
 80a3c24:	7441      	strb	r1, [r0, #17]
 80a3c26:	4770      	bx	lr

080a3c28 <_ZN9USBSerialD1Ev>:
#include "spark_wiring_platform.h"
#include "usb_hal.h"
#include "system_task.h"
#include "spark_wiring_startup.h"

class USBSerial : public Stream
 80a3c28:	4770      	bx	lr

080a3c2a <_ZN9USBSerial4readEv>:


// Read data from buffer
int USBSerial::read()
{
	return HAL_USB_USART_Receive_Data(_serial, false);
 80a3c2a:	2100      	movs	r1, #0
 80a3c2c:	7c00      	ldrb	r0, [r0, #16]
 80a3c2e:	f7ff bcfd 	b.w	80a362c <HAL_USB_USART_Receive_Data>

080a3c32 <_ZN9USBSerial4peekEv>:
  _blocking = block;
}

int USBSerial::peek()
{
	return HAL_USB_USART_Receive_Data(_serial, true);
 80a3c32:	2101      	movs	r1, #1
 80a3c34:	7c00      	ldrb	r0, [r0, #16]
 80a3c36:	f7ff bcf9 	b.w	80a362c <HAL_USB_USART_Receive_Data>

080a3c3a <_ZN9USBSerial17availableForWriteEv>:
	return HAL_USB_USART_Receive_Data(_serial, false);
}

int USBSerial::availableForWrite()
{
  return HAL_USB_USART_Available_Data_For_Write(_serial);
 80a3c3a:	7c00      	ldrb	r0, [r0, #16]
 80a3c3c:	f7ff bcee 	b.w	80a361c <HAL_USB_USART_Available_Data_For_Write>

080a3c40 <_ZN9USBSerial9availableEv>:
}

int USBSerial::available()
{
	return HAL_USB_USART_Available_Data(_serial);
 80a3c40:	7c00      	ldrb	r0, [r0, #16]
 80a3c42:	f7ff bce3 	b.w	80a360c <HAL_USB_USART_Available_Data>

080a3c46 <_ZN9USBSerial5writeEh>:
}

size_t USBSerial::write(uint8_t byte)
{
 80a3c46:	b538      	push	{r3, r4, r5, lr}
 80a3c48:	4604      	mov	r4, r0
  if (HAL_USB_USART_Available_Data_For_Write(_serial) > 0 || _blocking) {
 80a3c4a:	7c00      	ldrb	r0, [r0, #16]
{
	return HAL_USB_USART_Available_Data(_serial);
}

size_t USBSerial::write(uint8_t byte)
{
 80a3c4c:	460d      	mov	r5, r1
  if (HAL_USB_USART_Available_Data_For_Write(_serial) > 0 || _blocking) {
 80a3c4e:	f7ff fce5 	bl	80a361c <HAL_USB_USART_Available_Data_For_Write>
 80a3c52:	2800      	cmp	r0, #0
 80a3c54:	dc01      	bgt.n	80a3c5a <_ZN9USBSerial5writeEh+0x14>
 80a3c56:	7c60      	ldrb	r0, [r4, #17]
 80a3c58:	b120      	cbz	r0, 80a3c64 <_ZN9USBSerial5writeEh+0x1e>
    HAL_USB_USART_Send_Data(_serial, byte);
 80a3c5a:	4629      	mov	r1, r5
 80a3c5c:	7c20      	ldrb	r0, [r4, #16]
 80a3c5e:	f7ff fced 	bl	80a363c <HAL_USB_USART_Send_Data>
    return 1;
 80a3c62:	2001      	movs	r0, #1
  }
  return 0;
}
 80a3c64:	bd38      	pop	{r3, r4, r5, pc}

080a3c66 <_ZN9USBSerial5flushEv>:

void USBSerial::flush()
{
  HAL_USB_USART_Flush_Data(_serial);
 80a3c66:	7c00      	ldrb	r0, [r0, #16]
 80a3c68:	f7ff bcf0 	b.w	80a364c <HAL_USB_USART_Flush_Data>

080a3c6c <_ZN9USBSerialD0Ev>:
 80a3c6c:	b510      	push	{r4, lr}
 80a3c6e:	4604      	mov	r4, r0
 80a3c70:	f7fc fa17 	bl	80a00a2 <_ZdlPv>
 80a3c74:	4620      	mov	r0, r4
 80a3c76:	bd10      	pop	{r4, pc}

080a3c78 <_ZN9USBSerialC1E20HAL_USB_USART_SerialRK20HAL_USB_USART_Config>:

  HAL_USB_USART_Config conf = acquireSerialBuffer();
  HAL_USB_USART_Init(_serial, &conf);
}

USBSerial::USBSerial(HAL_USB_USART_Serial serial, const HAL_USB_USART_Config& conf)
 80a3c78:	b510      	push	{r4, lr}
 80a3c7a:	4604      	mov	r4, r0
 80a3c7c:	2300      	movs	r3, #0
 80a3c7e:	6063      	str	r3, [r4, #4]
 80a3c80:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 80a3c84:	60a3      	str	r3, [r4, #8]
 80a3c86:	4b05      	ldr	r3, [pc, #20]	; (80a3c9c <_ZN9USBSerialC1E20HAL_USB_USART_SerialRK20HAL_USB_USART_Config+0x24>)
 80a3c88:	4608      	mov	r0, r1
 80a3c8a:	6023      	str	r3, [r4, #0]
{
  _serial = serial;
  _blocking = true;
 80a3c8c:	2301      	movs	r3, #1
  HAL_USB_USART_Init(_serial, &conf);
}

USBSerial::USBSerial(HAL_USB_USART_Serial serial, const HAL_USB_USART_Config& conf)
{
  _serial = serial;
 80a3c8e:	7421      	strb	r1, [r4, #16]
  _blocking = true;
 80a3c90:	7463      	strb	r3, [r4, #17]

  HAL_USB_USART_Init(_serial, &conf);
 80a3c92:	4611      	mov	r1, r2
 80a3c94:	f7ff fcaa 	bl	80a35ec <HAL_USB_USART_Init>
}
 80a3c98:	4620      	mov	r0, r4
 80a3c9a:	bd10      	pop	{r4, pc}
 80a3c9c:	080a69b0 	.word	0x080a69b0

080a3ca0 <_ZN9USBSerial5beginEl>:
// Public methods
//

void USBSerial::begin(long speed)
{
    HAL_USB_USART_Begin(_serial, speed, NULL);
 80a3ca0:	2200      	movs	r2, #0
 80a3ca2:	7c00      	ldrb	r0, [r0, #16]
 80a3ca4:	f7ff bcaa 	b.w	80a35fc <HAL_USB_USART_Begin>

080a3ca8 <_Z19acquireSerialBufferv>:

// Preinstantiate Objects //////////////////////////////////////////////////////
#ifdef SPARK_USB_SERIAL

HAL_USB_USART_Config __attribute__((weak)) acquireSerialBuffer()
{
 80a3ca8:	b510      	push	{r4, lr}
 80a3caa:	4604      	mov	r4, r0
  HAL_USB_USART_Config conf = {0};
 80a3cac:	2214      	movs	r2, #20
 80a3cae:	2100      	movs	r1, #0
 80a3cb0:	f002 fa77 	bl	80a61a2 <memset>

#if defined(USB_SERIAL_USERSPACE_BUFFERS) && ((MODULE_FUNCTION == MOD_FUNC_USER_PART) || (MODULE_FUNCTION == MOD_FUNC_MONO_FIRMWARE))
  static uint8_t serial_rx_buffer[USB_RX_BUFFER_SIZE];
  static uint8_t serial_tx_buffer[USB_TX_BUFFER_SIZE];

  conf.rx_buffer = serial_rx_buffer;
 80a3cb4:	4b05      	ldr	r3, [pc, #20]	; (80a3ccc <_Z19acquireSerialBufferv+0x24>)
  conf.rx_buffer_size = USB_RX_BUFFER_SIZE;
  conf.tx_buffer_size = USB_TX_BUFFER_SIZE;
#endif

  return conf;
}
 80a3cb6:	4620      	mov	r0, r4

#if defined(USB_SERIAL_USERSPACE_BUFFERS) && ((MODULE_FUNCTION == MOD_FUNC_USER_PART) || (MODULE_FUNCTION == MOD_FUNC_MONO_FIRMWARE))
  static uint8_t serial_rx_buffer[USB_RX_BUFFER_SIZE];
  static uint8_t serial_tx_buffer[USB_TX_BUFFER_SIZE];

  conf.rx_buffer = serial_rx_buffer;
 80a3cb8:	6063      	str	r3, [r4, #4]
  conf.tx_buffer = serial_tx_buffer;
 80a3cba:	4b05      	ldr	r3, [pc, #20]	; (80a3cd0 <_Z19acquireSerialBufferv+0x28>)
 80a3cbc:	60e3      	str	r3, [r4, #12]
  conf.rx_buffer_size = USB_RX_BUFFER_SIZE;
 80a3cbe:	f240 1301 	movw	r3, #257	; 0x101
 80a3cc2:	8123      	strh	r3, [r4, #8]
  conf.tx_buffer_size = USB_TX_BUFFER_SIZE;
 80a3cc4:	2381      	movs	r3, #129	; 0x81
 80a3cc6:	8223      	strh	r3, [r4, #16]
#endif

  return conf;
}
 80a3cc8:	bd10      	pop	{r4, pc}
 80a3cca:	bf00      	nop
 80a3ccc:	20000991 	.word	0x20000991
 80a3cd0:	20000910 	.word	0x20000910

080a3cd4 <_Z16_fetch_usbserialv>:

USBSerial& _fetch_usbserial()
{
 80a3cd4:	b530      	push	{r4, r5, lr}
  HAL_USB_USART_Config conf = acquireSerialBuffer();
	static USBSerial _usbserial(HAL_USB_USART_SERIAL, conf);
 80a3cd6:	4d0e      	ldr	r5, [pc, #56]	; (80a3d10 <_Z16_fetch_usbserialv+0x3c>)

  return conf;
}

USBSerial& _fetch_usbserial()
{
 80a3cd8:	b087      	sub	sp, #28
  HAL_USB_USART_Config conf = acquireSerialBuffer();
 80a3cda:	a801      	add	r0, sp, #4
 80a3cdc:	f7ff ffe4 	bl	80a3ca8 <_Z19acquireSerialBufferv>
	static USBSerial _usbserial(HAL_USB_USART_SERIAL, conf);
 80a3ce0:	6829      	ldr	r1, [r5, #0]
 80a3ce2:	f011 0401 	ands.w	r4, r1, #1
 80a3ce6:	d110      	bne.n	80a3d0a <_Z16_fetch_usbserialv+0x36>
 80a3ce8:	4628      	mov	r0, r5
 80a3cea:	f7fc f9de 	bl	80a00aa <__cxa_guard_acquire>
 80a3cee:	b160      	cbz	r0, 80a3d0a <_Z16_fetch_usbserialv+0x36>
 80a3cf0:	aa01      	add	r2, sp, #4
 80a3cf2:	4621      	mov	r1, r4
 80a3cf4:	4807      	ldr	r0, [pc, #28]	; (80a3d14 <_Z16_fetch_usbserialv+0x40>)
 80a3cf6:	f7ff ffbf 	bl	80a3c78 <_ZN9USBSerialC1E20HAL_USB_USART_SerialRK20HAL_USB_USART_Config>
 80a3cfa:	4628      	mov	r0, r5
 80a3cfc:	f7fc f9da 	bl	80a00b4 <__cxa_guard_release>
 80a3d00:	4a05      	ldr	r2, [pc, #20]	; (80a3d18 <_Z16_fetch_usbserialv+0x44>)
 80a3d02:	4906      	ldr	r1, [pc, #24]	; (80a3d1c <_Z16_fetch_usbserialv+0x48>)
 80a3d04:	4803      	ldr	r0, [pc, #12]	; (80a3d14 <_Z16_fetch_usbserialv+0x40>)
 80a3d06:	f001 fa41 	bl	80a518c <__aeabi_atexit>
	return _usbserial;
}
 80a3d0a:	4802      	ldr	r0, [pc, #8]	; (80a3d14 <_Z16_fetch_usbserialv+0x40>)
 80a3d0c:	b007      	add	sp, #28
 80a3d0e:	bd30      	pop	{r4, r5, pc}
 80a3d10:	2000090c 	.word	0x2000090c
 80a3d14:	20000a94 	.word	0x20000a94
 80a3d18:	20000380 	.word	0x20000380
 80a3d1c:	080a3c29 	.word	0x080a3c29

080a3d20 <_Z23acquireUSBSerial1Bufferv>:

#if Wiring_USBSerial1

HAL_USB_USART_Config __attribute__((weak)) acquireUSBSerial1Buffer()
{
 80a3d20:	b510      	push	{r4, lr}
 80a3d22:	4604      	mov	r4, r0
  HAL_USB_USART_Config conf = {0};
 80a3d24:	2214      	movs	r2, #20
 80a3d26:	2100      	movs	r1, #0
 80a3d28:	f002 fa3b 	bl	80a61a2 <memset>

#if defined(USB_SERIAL_USERSPACE_BUFFERS) && ((MODULE_FUNCTION == MOD_FUNC_USER_PART) || (MODULE_FUNCTION == MOD_FUNC_MONO_FIRMWARE))
  static uint8_t usbserial1_rx_buffer[USB_RX_BUFFER_SIZE];
  static uint8_t usbserial1_tx_buffer[USB_TX_BUFFER_SIZE];

  conf.rx_buffer = usbserial1_rx_buffer;
 80a3d2c:	4b05      	ldr	r3, [pc, #20]	; (80a3d44 <_Z23acquireUSBSerial1Bufferv+0x24>)
  conf.rx_buffer_size = USB_RX_BUFFER_SIZE;
  conf.tx_buffer_size = USB_TX_BUFFER_SIZE;
#endif

  return conf;
}
 80a3d2e:	4620      	mov	r0, r4

#if defined(USB_SERIAL_USERSPACE_BUFFERS) && ((MODULE_FUNCTION == MOD_FUNC_USER_PART) || (MODULE_FUNCTION == MOD_FUNC_MONO_FIRMWARE))
  static uint8_t usbserial1_rx_buffer[USB_RX_BUFFER_SIZE];
  static uint8_t usbserial1_tx_buffer[USB_TX_BUFFER_SIZE];

  conf.rx_buffer = usbserial1_rx_buffer;
 80a3d30:	6063      	str	r3, [r4, #4]
  conf.tx_buffer = usbserial1_tx_buffer;
 80a3d32:	4b05      	ldr	r3, [pc, #20]	; (80a3d48 <_Z23acquireUSBSerial1Bufferv+0x28>)
 80a3d34:	60e3      	str	r3, [r4, #12]
  conf.rx_buffer_size = USB_RX_BUFFER_SIZE;
 80a3d36:	f240 1301 	movw	r3, #257	; 0x101
 80a3d3a:	8123      	strh	r3, [r4, #8]
  conf.tx_buffer_size = USB_TX_BUFFER_SIZE;
 80a3d3c:	2381      	movs	r3, #129	; 0x81
 80a3d3e:	8223      	strh	r3, [r4, #16]
#endif

  return conf;
}
 80a3d40:	bd10      	pop	{r4, pc}
 80a3d42:	bf00      	nop
 80a3d44:	20000b44 	.word	0x20000b44
 80a3d48:	20000aac 	.word	0x20000aac

080a3d4c <_Z17_fetch_usbserial1v>:

USBSerial& _fetch_usbserial1()
{
 80a3d4c:	b510      	push	{r4, lr}
  HAL_USB_USART_Config conf = acquireUSBSerial1Buffer();
  static USBSerial _usbserial1(HAL_USB_USART_SERIAL1, conf);
 80a3d4e:	4c0e      	ldr	r4, [pc, #56]	; (80a3d88 <_Z17_fetch_usbserial1v+0x3c>)

  return conf;
}

USBSerial& _fetch_usbserial1()
{
 80a3d50:	b086      	sub	sp, #24
  HAL_USB_USART_Config conf = acquireUSBSerial1Buffer();
 80a3d52:	a801      	add	r0, sp, #4
 80a3d54:	f7ff ffe4 	bl	80a3d20 <_Z23acquireUSBSerial1Bufferv>
  static USBSerial _usbserial1(HAL_USB_USART_SERIAL1, conf);
 80a3d58:	6823      	ldr	r3, [r4, #0]
 80a3d5a:	07db      	lsls	r3, r3, #31
 80a3d5c:	d410      	bmi.n	80a3d80 <_Z17_fetch_usbserial1v+0x34>
 80a3d5e:	4620      	mov	r0, r4
 80a3d60:	f7fc f9a3 	bl	80a00aa <__cxa_guard_acquire>
 80a3d64:	b160      	cbz	r0, 80a3d80 <_Z17_fetch_usbserial1v+0x34>
 80a3d66:	aa01      	add	r2, sp, #4
 80a3d68:	2101      	movs	r1, #1
 80a3d6a:	4808      	ldr	r0, [pc, #32]	; (80a3d8c <_Z17_fetch_usbserial1v+0x40>)
 80a3d6c:	f7ff ff84 	bl	80a3c78 <_ZN9USBSerialC1E20HAL_USB_USART_SerialRK20HAL_USB_USART_Config>
 80a3d70:	4620      	mov	r0, r4
 80a3d72:	f7fc f99f 	bl	80a00b4 <__cxa_guard_release>
 80a3d76:	4a06      	ldr	r2, [pc, #24]	; (80a3d90 <_Z17_fetch_usbserial1v+0x44>)
 80a3d78:	4906      	ldr	r1, [pc, #24]	; (80a3d94 <_Z17_fetch_usbserial1v+0x48>)
 80a3d7a:	4804      	ldr	r0, [pc, #16]	; (80a3d8c <_Z17_fetch_usbserial1v+0x40>)
 80a3d7c:	f001 fa06 	bl	80a518c <__aeabi_atexit>
  return _usbserial1;
}
 80a3d80:	4802      	ldr	r0, [pc, #8]	; (80a3d8c <_Z17_fetch_usbserial1v+0x40>)
 80a3d82:	b006      	add	sp, #24
 80a3d84:	bd10      	pop	{r4, pc}
 80a3d86:	bf00      	nop
 80a3d88:	20000aa8 	.word	0x20000aa8
 80a3d8c:	20000b30 	.word	0x20000b30
 80a3d90:	20000380 	.word	0x20000380
 80a3d94:	080a3c29 	.word	0x080a3c29

080a3d98 <_ZN9IPAddressD1Ev>:
    IPAddress(uint8_t first_octet, uint8_t second_octet, uint8_t third_octet, uint8_t fourth_octet);
    IPAddress(uint32_t address);
    IPAddress(const uint8_t* address);
    IPAddress(const HAL_IPAddress& address);

    virtual ~IPAddress() {}
 80a3d98:	4770      	bx	lr

080a3d9a <_ZN9IPAddressD0Ev>:
 80a3d9a:	b510      	push	{r4, lr}
 80a3d9c:	4604      	mov	r4, r0
 80a3d9e:	f7fc f980 	bl	80a00a2 <_ZdlPv>
 80a3da2:	4620      	mov	r0, r4
 80a3da4:	bd10      	pop	{r4, pc}

080a3da6 <_ZNK9IPAddress7printToER5Print>:
#endif
	return address.ipv4==that.address.ipv4;
}

size_t IPAddress::printTo(Print& p) const
{
 80a3da6:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80a3da8:	460f      	mov	r7, r1
 80a3daa:	f100 0608 	add.w	r6, r0, #8
 80a3dae:	1d05      	adds	r5, r0, #4
 80a3db0:	2400      	movs	r4, #0
    size_t n = 0;
    for (int i = 0; i < 4; i++)
    {
        if (n)
            n += p.print('.');
        n += p.print((*this)[i], DEC);
 80a3db2:	f816 1d01 	ldrb.w	r1, [r6, #-1]!
 80a3db6:	220a      	movs	r2, #10
 80a3db8:	4638      	mov	r0, r7
 80a3dba:	f000 fc26 	bl	80a460a <_ZN5Print5printEhi>
}

size_t IPAddress::printTo(Print& p) const
{
    size_t n = 0;
    for (int i = 0; i < 4; i++)
 80a3dbe:	42ae      	cmp	r6, r5
    {
        if (n)
            n += p.print('.');
        n += p.print((*this)[i], DEC);
 80a3dc0:	4404      	add	r4, r0
}

size_t IPAddress::printTo(Print& p) const
{
    size_t n = 0;
    for (int i = 0; i < 4; i++)
 80a3dc2:	d007      	beq.n	80a3dd4 <_ZNK9IPAddress7printToER5Print+0x2e>
    {
        if (n)
 80a3dc4:	2c00      	cmp	r4, #0
 80a3dc6:	d0f4      	beq.n	80a3db2 <_ZNK9IPAddress7printToER5Print+0xc>
            n += p.print('.');
 80a3dc8:	212e      	movs	r1, #46	; 0x2e
 80a3dca:	4638      	mov	r0, r7
 80a3dcc:	f000 fbe4 	bl	80a4598 <_ZN5Print5printEc>
 80a3dd0:	4404      	add	r4, r0
 80a3dd2:	e7ee      	b.n	80a3db2 <_ZNK9IPAddress7printToER5Print+0xc>
        n += p.print((*this)[i], DEC);
    }
    return n;
}
 80a3dd4:	4620      	mov	r0, r4
 80a3dd6:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

080a3dd8 <_ZN9IPAddressC1Ev>:
#include "spark_wiring_ipaddress.h"
#include "spark_wiring_print.h"
#include "spark_wiring_platform.h"
#include "string.h"

IPAddress::IPAddress()
 80a3dd8:	b510      	push	{r4, lr}
 80a3dda:	4604      	mov	r4, r0
 80a3ddc:	4b04      	ldr	r3, [pc, #16]	; (80a3df0 <_ZN9IPAddressC1Ev+0x18>)
        return address;
    }

    virtual size_t printTo(Print& p) const;

    void clear() { memset(&address, 0, sizeof (address)); }
 80a3dde:	2211      	movs	r2, #17
 80a3de0:	f840 3b04 	str.w	r3, [r0], #4
 80a3de4:	2100      	movs	r1, #0
 80a3de6:	f002 f9dc 	bl	80a61a2 <memset>
{
    clear();
}
 80a3dea:	4620      	mov	r0, r4
 80a3dec:	bd10      	pop	{r4, pc}
 80a3dee:	bf00      	nop
 80a3df0:	080a69e0 	.word	0x080a69e0

080a3df4 <_ZN9IPAddress8set_ipv4Ehhhh>:
    return address.ipv4!=0;
#endif
}

void IPAddress::set_ipv4(uint8_t b0, uint8_t b1, uint8_t b2, uint8_t b3)
{
 80a3df4:	b510      	push	{r4, lr}
    address.ipv4 = b0<<24 | b1 << 16 | b2 << 8 | b3;
 80a3df6:	f89d 4008 	ldrb.w	r4, [sp, #8]
 80a3dfa:	ea44 2303 	orr.w	r3, r4, r3, lsl #8
 80a3dfe:	ea43 4202 	orr.w	r2, r3, r2, lsl #16
 80a3e02:	ea42 6101 	orr.w	r1, r2, r1, lsl #24
        return &address;
    }

    inline void setVersion(uint8_t version) {
#if HAL_IPv6
        address.v = version;
 80a3e06:	2304      	movs	r3, #4
 80a3e08:	6041      	str	r1, [r0, #4]
 80a3e0a:	7503      	strb	r3, [r0, #20]
 80a3e0c:	bd10      	pop	{r4, pc}
	...

080a3e10 <_ZN9IPAddressC1Ehhhh>:
{
    memcpy(&this->address, &address, sizeof(address));
}


IPAddress::IPAddress(uint8_t first_octet, uint8_t second_octet, uint8_t third_octet, uint8_t fourth_octet)
 80a3e10:	b537      	push	{r0, r1, r2, r4, r5, lr}
 80a3e12:	4d04      	ldr	r5, [pc, #16]	; (80a3e24 <_ZN9IPAddressC1Ehhhh+0x14>)
 80a3e14:	6005      	str	r5, [r0, #0]
{
    set_ipv4(first_octet, second_octet, third_octet, fourth_octet);
 80a3e16:	f89d 5018 	ldrb.w	r5, [sp, #24]
 80a3e1a:	9500      	str	r5, [sp, #0]
 80a3e1c:	f7ff ffea 	bl	80a3df4 <_ZN9IPAddress8set_ipv4Ehhhh>
}
 80a3e20:	b003      	add	sp, #12
 80a3e22:	bd30      	pop	{r4, r5, pc}
 80a3e24:	080a69e0 	.word	0x080a69e0

080a3e28 <_ZN9IPAddressaSEPKh>:
    address.ipv4 = b0<<24 | b1 << 16 | b2 << 8 | b3;
    setVersion(4);
}

IPAddress& IPAddress::operator=(const uint8_t* address)
{
 80a3e28:	b537      	push	{r0, r1, r2, r4, r5, lr}
    set_ipv4(address[0], address[1], address[2], address[3]);
 80a3e2a:	780d      	ldrb	r5, [r1, #0]
 80a3e2c:	788b      	ldrb	r3, [r1, #2]
 80a3e2e:	784a      	ldrb	r2, [r1, #1]
 80a3e30:	78c9      	ldrb	r1, [r1, #3]
 80a3e32:	9100      	str	r1, [sp, #0]
 80a3e34:	4629      	mov	r1, r5
 80a3e36:	f7ff ffdd 	bl	80a3df4 <_ZN9IPAddress8set_ipv4Ehhhh>
    return *this;
}
 80a3e3a:	b003      	add	sp, #12
 80a3e3c:	bd30      	pop	{r4, r5, pc}
	...

080a3e40 <_ZN9IPAddressC1EPKh>:
IPAddress::IPAddress(uint32_t address)
{
    *this = address;
}

IPAddress::IPAddress(const uint8_t* address)
 80a3e40:	b510      	push	{r4, lr}
 80a3e42:	4604      	mov	r4, r0
 80a3e44:	4b02      	ldr	r3, [pc, #8]	; (80a3e50 <_ZN9IPAddressC1EPKh+0x10>)
 80a3e46:	6003      	str	r3, [r0, #0]
{
    *this = address;
 80a3e48:	f7ff ffee 	bl	80a3e28 <_ZN9IPAddressaSEPKh>
}
 80a3e4c:	4620      	mov	r0, r4
 80a3e4e:	bd10      	pop	{r4, pc}
 80a3e50:	080a69e0 	.word	0x080a69e0

080a3e54 <_ZNSt15_Sp_counted_ptrIPN8particle6detail10FutureImplIbNS1_13FutureContextEEELN9__gnu_cxx12_Lock_policyE0EED1Ev>:
    class __shared_count;


  // Counted ptr with no deleter or allocator support
  template<typename _Ptr, _Lock_policy _Lp>
    class _Sp_counted_ptr final : public _Sp_counted_base<_Lp>
 80a3e54:	4770      	bx	lr

080a3e56 <_ZNSt15_Sp_counted_ptrIPN8particle6detail10FutureImplIbNS1_13FutureContextEEELN9__gnu_cxx12_Lock_policyE0EE14_M_get_deleterERKSt9type_info>:
      _M_destroy() noexcept
      { delete this; }

      virtual void*
      _M_get_deleter(const std::type_info&) noexcept
      { return nullptr; }
 80a3e56:	2000      	movs	r0, #0
 80a3e58:	4770      	bx	lr

080a3e5a <_ZNSt15_Sp_counted_ptrIPN8particle6detail10FutureImplIbNS1_13FutureContextEEELN9__gnu_cxx12_Lock_policyE0EED0Ev>:
    class __shared_count;


  // Counted ptr with no deleter or allocator support
  template<typename _Ptr, _Lock_policy _Lp>
    class _Sp_counted_ptr final : public _Sp_counted_base<_Lp>
 80a3e5a:	b510      	push	{r4, lr}
 80a3e5c:	4604      	mov	r4, r0
 80a3e5e:	f7fc f920 	bl	80a00a2 <_ZdlPv>
 80a3e62:	4620      	mov	r0, r4
 80a3e64:	bd10      	pop	{r4, pc}

080a3e66 <_ZNSt15_Sp_counted_ptrIPN8particle6detail10FutureImplIbNS1_13FutureContextEEELN9__gnu_cxx12_Lock_policyE0EE10_M_destroyEv>:
      virtual void
      _M_dispose() noexcept
      { delete _M_ptr; }

      virtual void
      _M_destroy() noexcept
 80a3e66:	b508      	push	{r3, lr}
      { delete this; }
 80a3e68:	b108      	cbz	r0, 80a3e6e <_ZNSt15_Sp_counted_ptrIPN8particle6detail10FutureImplIbNS1_13FutureContextEEELN9__gnu_cxx12_Lock_policyE0EE10_M_destroyEv+0x8>
 80a3e6a:	f7ff fff6 	bl	80a3e5a <_ZNSt15_Sp_counted_ptrIPN8particle6detail10FutureImplIbNS1_13FutureContextEEELN9__gnu_cxx12_Lock_policyE0EED0Ev>
 80a3e6e:	bd08      	pop	{r3, pc}

080a3e70 <_ZNSt15_Sp_counted_ptrIPN8particle6detail10FutureImplIbNS1_13FutureContextEEELN9__gnu_cxx12_Lock_policyE0EE10_M_disposeEv>:
      explicit
      _Sp_counted_ptr(_Ptr __p) noexcept
      : _M_ptr(__p) { }

      virtual void
      _M_dispose() noexcept
 80a3e70:	b538      	push	{r3, r4, r5, lr}
      { delete _M_ptr; }
 80a3e72:	68c4      	ldr	r4, [r0, #12]
 80a3e74:	b1d4      	cbz	r4, 80a3eac <_ZNSt15_Sp_counted_ptrIPN8particle6detail10FutureImplIbNS1_13FutureContextEEELN9__gnu_cxx12_Lock_policyE0EE10_M_disposeEv+0x3c>

      _Tp
      load(memory_order __m = memory_order_seq_cst) const noexcept
      { 
        _Tp tmp;
	__atomic_load(&_M_i, &tmp, __m);
 80a3e76:	7823      	ldrb	r3, [r4, #0]
    ~FutureImpl() {
        // Call destructor of the appropriate unnamed enum's field
        const State s = this->state();
        if (s == State::SUCCEEDED) {
            result_.~ResultT();
        } else if (s == State::FAILED) {
 80a3e78:	2b02      	cmp	r3, #2
 80a3e7a:	d102      	bne.n	80a3e82 <_ZNSt15_Sp_counted_ptrIPN8particle6detail10FutureImplIbNS1_13FutureContextEEELN9__gnu_cxx12_Lock_policyE0EE10_M_disposeEv+0x12>
        Error() {
    swap(*this, error);
}

inline particle::Error::~Error() {
    free((void*)msg_);
 80a3e7c:	68e0      	ldr	r0, [r4, #12]
 80a3e7e:	f7ff fe0b 	bl	80a3a98 <free>
      {
        memory_order __b = __m & __memory_order_mask;
	__glibcxx_assert(__b != memory_order_release);
	__glibcxx_assert(__b != memory_order_acq_rel);

	return __atomic_load_n(&_M_p, __m);
 80a3e82:	6865      	ldr	r5, [r4, #4]
    // Completion callback types
    typedef typename detail::FutureCallbackTypes<ResultT>::OnSuccess OnSuccessCallback;
    typedef typename detail::FutureCallbackTypes<ResultT>::OnError OnErrorCallback;

    ~FutureImplBase() {
        delete onSuccess_.load(std::memory_order_relaxed);
 80a3e84:	b12d      	cbz	r5, 80a3e92 <_ZNSt15_Sp_counted_ptrIPN8particle6detail10FutureImplIbNS1_13FutureContextEEELN9__gnu_cxx12_Lock_policyE0EE10_M_disposeEv+0x22>
   *  @ingroup functors
   *
   *  Polymorphic function wrapper.
   */
  template<typename _Res, typename... _ArgTypes>
    class function<_Res(_ArgTypes...)>
 80a3e86:	4628      	mov	r0, r5
 80a3e88:	f7fc fb04 	bl	80a0494 <_ZNSt14_Function_baseD1Ev>
 80a3e8c:	4628      	mov	r0, r5
 80a3e8e:	f7fc f908 	bl	80a00a2 <_ZdlPv>
 80a3e92:	68a5      	ldr	r5, [r4, #8]
        delete onError_.load(std::memory_order_relaxed);
 80a3e94:	b12d      	cbz	r5, 80a3ea2 <_ZNSt15_Sp_counted_ptrIPN8particle6detail10FutureImplIbNS1_13FutureContextEEELN9__gnu_cxx12_Lock_policyE0EE10_M_disposeEv+0x32>
 80a3e96:	4628      	mov	r0, r5
 80a3e98:	f7fc fafc 	bl	80a0494 <_ZNSt14_Function_baseD1Ev>
 80a3e9c:	4628      	mov	r0, r5
 80a3e9e:	f7fc f900 	bl	80a00a2 <_ZdlPv>
 80a3ea2:	4620      	mov	r0, r4
 80a3ea4:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
 80a3ea8:	f7fc b8fb 	b.w	80a00a2 <_ZdlPv>
 80a3eac:	bd38      	pop	{r3, r4, r5, pc}

080a3eae <_ZN8particle6FutureIbNS_6detail13FutureContextEEC1ESt10shared_ptrINS1_10FutureImplIbS2_EEE>:
};

template<typename ResultT, typename ContextT = detail::FutureContext>
class Future: public FutureBase<ResultT, ContextT> {
public:
    using FutureBase<ResultT, ContextT>::FutureBase;
 80a3eae:	b513      	push	{r0, r1, r4, lr}
 80a3eb0:	4604      	mov	r4, r0
      }

      void
      _M_swap(__shared_count& __r) noexcept
      {
	_Sp_counted_base<_Lp>* __tmp = __r._M_pi;
 80a3eb2:	e891 0005 	ldmia.w	r1, {r0, r2}
	__r._M_pi = _M_pi;
 80a3eb6:	2300      	movs	r3, #0
 80a3eb8:	604b      	str	r3, [r1, #4]

      __shared_ptr(__shared_ptr&& __r) noexcept
      : _M_ptr(__r._M_ptr), _M_refcount()
      {
	_M_refcount._M_swap(__r._M_refcount);
	__r._M_ptr = 0;
 80a3eba:	600b      	str	r3, [r1, #0]
	__shared_ptr(const __shared_ptr<_Tp1, _Lp>& __r) noexcept
	: _M_ptr(__r._M_ptr), _M_refcount(__r._M_refcount)
	{ }

      __shared_ptr(__shared_ptr&& __r) noexcept
      : _M_ptr(__r._M_ptr), _M_refcount()
 80a3ebc:	6020      	str	r0, [r4, #0]
      void
      _M_swap(__shared_count& __r) noexcept
      {
	_Sp_counted_base<_Lp>* __tmp = __r._M_pi;
	__r._M_pi = _M_pi;
	_M_pi = __tmp;
 80a3ebe:	6062      	str	r2, [r4, #4]
	: _M_ptr(__p), _M_refcount(__r._M_refcount) // never throws
	{ }

      __shared_ptr(const __shared_ptr&) noexcept = default;
      __shared_ptr& operator=(const __shared_ptr&) noexcept = default;
      ~__shared_ptr() = default;
 80a3ec0:	a801      	add	r0, sp, #4

      void
      _M_swap(__shared_count& __r) noexcept
      {
	_Sp_counted_base<_Lp>* __tmp = __r._M_pi;
	__r._M_pi = _M_pi;
 80a3ec2:	9301      	str	r3, [sp, #4]

      __shared_ptr(__shared_ptr&& __r) noexcept
      : _M_ptr(__r._M_ptr), _M_refcount()
      {
	_M_refcount._M_swap(__r._M_refcount);
	__r._M_ptr = 0;
 80a3ec4:	9300      	str	r3, [sp, #0]
	: _M_ptr(__p), _M_refcount(__r._M_refcount) // never throws
	{ }

      __shared_ptr(const __shared_ptr&) noexcept = default;
      __shared_ptr& operator=(const __shared_ptr&) noexcept = default;
      ~__shared_ptr() = default;
 80a3ec6:	f7ff fe1f 	bl	80a3b08 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev>
 80a3eca:	4620      	mov	r0, r4
 80a3ecc:	b002      	add	sp, #8
 80a3ece:	bd10      	pop	{r4, pc}

080a3ed0 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EEC1ERKS2_>:
	if (_M_pi != nullptr)
	  _M_pi->_M_release();
      }

      __shared_count(const __shared_count& __r) noexcept
      : _M_pi(__r._M_pi)
 80a3ed0:	680b      	ldr	r3, [r1, #0]
 80a3ed2:	6003      	str	r3, [r0, #0]
      {
	if (_M_pi != 0)
 80a3ed4:	b113      	cbz	r3, 80a3edc <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EEC1ERKS2_+0xc>
    }

  template<>
    inline void
    _Sp_counted_base<_S_single>::_M_add_ref_copy()
    { ++_M_use_count; }
 80a3ed6:	685a      	ldr	r2, [r3, #4]
 80a3ed8:	3201      	adds	r2, #1
 80a3eda:	605a      	str	r2, [r3, #4]
      __shared_count(const __shared_count& __r) noexcept
      : _M_pi(__r._M_pi)
      {
	if (_M_pi != 0)
	  _M_pi->_M_add_ref_copy();
      }
 80a3edc:	4770      	bx	lr

080a3ede <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE11fromDataPtrEPv>:
        // TODO: Use custom reference counting object to avoid unnecessary memory allocation
        return new detail::FutureImplPtr<ResultT, ContextT>(p_);
    }

    // Unwraps promise from an object pointer created via dataPtr() method
    static Promise<ResultT, ContextT> fromDataPtr(void* data) {
 80a3ede:	b5f7      	push	{r0, r1, r2, r4, r5, r6, r7, lr}
      template<typename _Tp1>
	__shared_ptr(const __shared_ptr<_Tp1, _Lp>& __r, _Tp* __p) noexcept
	: _M_ptr(__p), _M_refcount(__r._M_refcount) // never throws
	{ }

      __shared_ptr(const __shared_ptr&) noexcept = default;
 80a3ee0:	460c      	mov	r4, r1
 80a3ee2:	4606      	mov	r6, r0
 80a3ee4:	460f      	mov	r7, r1
 80a3ee6:	f854 3b04 	ldr.w	r3, [r4], #4
 80a3eea:	ad02      	add	r5, sp, #8
 80a3eec:	f845 3d08 	str.w	r3, [r5, #-8]!
 80a3ef0:	4621      	mov	r1, r4
 80a3ef2:	a801      	add	r0, sp, #4
 80a3ef4:	f7ff ffec 	bl	80a3ed0 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EEC1ERKS2_>
        auto d = static_cast<detail::FutureImplPtr<ResultT, ContextT>*>(data);
        const Promise<ResultT, ContextT> p(*d);
 80a3ef8:	4629      	mov	r1, r5
 80a3efa:	4630      	mov	r0, r6
 80a3efc:	f7ff ffd7 	bl	80a3eae <_ZN8particle6FutureIbNS_6detail13FutureContextEEC1ESt10shared_ptrINS1_10FutureImplIbS2_EEE>
      __shared_ptr& operator=(const __shared_ptr&) noexcept = default;
      ~__shared_ptr() = default;
 80a3f00:	a801      	add	r0, sp, #4
 80a3f02:	f7ff fe01 	bl	80a3b08 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev>
 80a3f06:	4620      	mov	r0, r4
 80a3f08:	f7ff fdfe 	bl	80a3b08 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev>
        delete d;
 80a3f0c:	4638      	mov	r0, r7
 80a3f0e:	f7fc f8c8 	bl	80a00a2 <_ZdlPv>
        return p;
    }
 80a3f12:	4630      	mov	r0, r6
 80a3f14:	b003      	add	sp, #12
 80a3f16:	bdf0      	pop	{r4, r5, r6, r7, pc}

080a3f18 <_ZSt4swapISt9_Any_dataEvRT_S2_>:
   *  @param  __b  Another thing of arbitrary type.
   *  @return   Nothing.
  */
  template<typename _Tp>
    inline void
    swap(_Tp& __a, _Tp& __b)
 80a3f18:	b513      	push	{r0, r1, r4, lr}
 80a3f1a:	460b      	mov	r3, r1
 80a3f1c:	4604      	mov	r4, r0
#endif
    {
      // concept requirements
      __glibcxx_function_requires(_SGIAssignableConcept<_Tp>)

      _Tp __tmp = _GLIBCXX_MOVE(__a);
 80a3f1e:	c803      	ldmia	r0, {r0, r1}
 80a3f20:	e88d 0003 	stmia.w	sp, {r0, r1}
      __a = _GLIBCXX_MOVE(__b);
 80a3f24:	e893 0003 	ldmia.w	r3, {r0, r1}
 80a3f28:	e884 0003 	stmia.w	r4, {r0, r1}
      __b = _GLIBCXX_MOVE(__tmp);
 80a3f2c:	e89d 0003 	ldmia.w	sp, {r0, r1}
 80a3f30:	e883 0003 	stmia.w	r3, {r0, r1}
    }
 80a3f34:	b002      	add	sp, #8
 80a3f36:	bd10      	pop	{r4, pc}

080a3f38 <_ZNKSt8functionIFvRKN8particle5ErrorEEEclES3_>:
  template<typename _Res, typename... _ArgTypes>
    _Res
    function<_Res(_ArgTypes...)>::
    operator()(_ArgTypes... __args) const
    {
      if (_M_empty())
 80a3f38:	6882      	ldr	r2, [r0, #8]
	  }
      }

  template<typename _Res, typename... _ArgTypes>
    _Res
    function<_Res(_ArgTypes...)>::
 80a3f3a:	b510      	push	{r4, lr}
    operator()(_ArgTypes... __args) const
    {
      if (_M_empty())
 80a3f3c:	b90a      	cbnz	r2, 80a3f42 <_ZNKSt8functionIFvRKN8particle5ErrorEEEclES3_+0xa>
	__throw_bad_function_call();
 80a3f3e:	f001 f942 	bl	80a51c6 <_ZSt25__throw_bad_function_callv>
      return _M_invoker(_M_functor, std::forward<_ArgTypes>(__args)...);
 80a3f42:	68c3      	ldr	r3, [r0, #12]
    }
 80a3f44:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    function<_Res(_ArgTypes...)>::
    operator()(_ArgTypes... __args) const
    {
      if (_M_empty())
	__throw_bad_function_call();
      return _M_invoker(_M_functor, std::forward<_ArgTypes>(__args)...);
 80a3f48:	4718      	bx	r3

080a3f4a <_ZNSt17_Function_handlerIFvvESt5_BindIFSt8functionIFvRKN8particle5ErrorEEES4_EEE9_M_invokeERKSt9_Any_data>:
    {
      typedef _Function_base::_Base_manager<_Functor> _Base;

     public:
      static void
      _M_invoke(const _Any_data& __functor, _ArgTypes&&... __args)
 80a3f4a:	b508      	push	{r3, lr}
	static _Functor*
	_M_get_pointer(const _Any_data& __source)
	{
	  const _Functor* __ptr =
	    __stored_locally? std::__addressof(__source._M_access<_Functor>())
	    /* have stored a pointer */ : __source._M_access<_Functor*>();
 80a3f4c:	6800      	ldr	r0, [r0, #0]
      template<typename _Result, typename... _Args, std::size_t... _Indexes>
	_Result
	__call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>)
	{
	  return _M_f(_Mu<_Bound_args>()
		      (std::get<_Indexes>(_M_bound_args), __args)...);
 80a3f4e:	f100 0110 	add.w	r1, r0, #16
 80a3f52:	f7ff fff1 	bl	80a3f38 <_ZNKSt8functionIFvRKN8particle5ErrorEEEclES3_>
 80a3f56:	bd08      	pop	{r3, pc}

080a3f58 <_ZNKSt8functionIFvRKbEEclES1_>:
  template<typename _Res, typename... _ArgTypes>
    _Res
    function<_Res(_ArgTypes...)>::
    operator()(_ArgTypes... __args) const
    {
      if (_M_empty())
 80a3f58:	6882      	ldr	r2, [r0, #8]
	  }
      }

  template<typename _Res, typename... _ArgTypes>
    _Res
    function<_Res(_ArgTypes...)>::
 80a3f5a:	b510      	push	{r4, lr}
    operator()(_ArgTypes... __args) const
    {
      if (_M_empty())
 80a3f5c:	b90a      	cbnz	r2, 80a3f62 <_ZNKSt8functionIFvRKbEEclES1_+0xa>
	__throw_bad_function_call();
 80a3f5e:	f001 f932 	bl	80a51c6 <_ZSt25__throw_bad_function_callv>
      return _M_invoker(_M_functor, std::forward<_ArgTypes>(__args)...);
 80a3f62:	68c3      	ldr	r3, [r0, #12]
    }
 80a3f64:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    function<_Res(_ArgTypes...)>::
    operator()(_ArgTypes... __args) const
    {
      if (_M_empty())
	__throw_bad_function_call();
      return _M_invoker(_M_functor, std::forward<_ArgTypes>(__args)...);
 80a3f68:	4718      	bx	r3

080a3f6a <_ZNSt17_Function_handlerIFvvESt5_BindIFSt8functionIFvRKbEEbEEE9_M_invokeERKSt9_Any_data>:
    {
      typedef _Function_base::_Base_manager<_Functor> _Base;

     public:
      static void
      _M_invoke(const _Any_data& __functor, _ArgTypes&&... __args)
 80a3f6a:	b508      	push	{r3, lr}
	static _Functor*
	_M_get_pointer(const _Any_data& __source)
	{
	  const _Functor* __ptr =
	    __stored_locally? std::__addressof(__source._M_access<_Functor>())
	    /* have stored a pointer */ : __source._M_access<_Functor*>();
 80a3f6c:	6800      	ldr	r0, [r0, #0]
      template<typename _Result, typename... _Args, std::size_t... _Indexes>
	_Result
	__call(tuple<_Args...>&& __args, _Index_tuple<_Indexes...>)
	{
	  return _M_f(_Mu<_Bound_args>()
		      (std::get<_Indexes>(_M_bound_args), __args)...);
 80a3f6e:	f100 0110 	add.w	r1, r0, #16
 80a3f72:	f7ff fff1 	bl	80a3f58 <_ZNKSt8functionIFvRKbEEclES1_>
 80a3f76:	bd08      	pop	{r3, pc}

080a3f78 <_ZNSt8functionIFvRKN8particle5ErrorEEEC1ERKS5_>:
      _Invoker_type _M_invoker;
  };

  // Out-of-line member definitions.
  template<typename _Res, typename... _ArgTypes>
    function<_Res(_ArgTypes...)>::
 80a3f78:	b538      	push	{r3, r4, r5, lr}
	{
	  _Base::_M_init_functor(__functor, std::__addressof(__f.get()));
	}
      };

    _Function_base() : _M_manager(nullptr) { }
 80a3f7a:	2300      	movs	r3, #0
 80a3f7c:	6083      	str	r3, [r0, #8]
 80a3f7e:	688b      	ldr	r3, [r1, #8]
      _Invoker_type _M_invoker;
  };

  // Out-of-line member definitions.
  template<typename _Res, typename... _ArgTypes>
    function<_Res(_ArgTypes...)>::
 80a3f80:	4604      	mov	r4, r0
 80a3f82:	460d      	mov	r5, r1
    function(const function& __x)
    : _Function_base()
    {
      if (static_cast<bool>(__x))
 80a3f84:	b12b      	cbz	r3, 80a3f92 <_ZNSt8functionIFvRKN8particle5ErrorEEEC1ERKS5_+0x1a>
	{
	  __x._M_manager(_M_functor, __x._M_functor, __clone_functor);
 80a3f86:	2202      	movs	r2, #2
 80a3f88:	4798      	blx	r3
	  _M_invoker = __x._M_invoker;
 80a3f8a:	68eb      	ldr	r3, [r5, #12]
 80a3f8c:	60e3      	str	r3, [r4, #12]
	  _M_manager = __x._M_manager;
 80a3f8e:	68ab      	ldr	r3, [r5, #8]
 80a3f90:	60a3      	str	r3, [r4, #8]
	}
    }
 80a3f92:	4620      	mov	r0, r4
 80a3f94:	bd38      	pop	{r3, r4, r5, pc}
	...

080a3f98 <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE8setErrorENS_5ErrorE>:

    explicit PromiseBase(detail::FutureImplPtr<ResultT, ContextT> ptr) :
            p_(std::move(ptr)) {
    }

    void setError(Error error) {
 80a3f98:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
      // concept requirements
      __glibcxx_function_requires(_SGIAssignableConcept<_Tp>)

      _Tp __tmp = _GLIBCXX_MOVE(__a);
      __a = _GLIBCXX_MOVE(__b);
      __b = _GLIBCXX_MOVE(__tmp);
 80a3f9c:	f64f 739c 	movw	r3, #65436	; 0xff9c
 80a3fa0:	6804      	ldr	r4, [r0, #0]

      bool
      compare_exchange_strong(_Tp& __e, _Tp __i, memory_order __s, 
			      memory_order __f) noexcept
      {
	return __atomic_compare_exchange(&_M_i, &__e, &__i, false, __s, __f);
 80a3fa2:	f04f 0002 	mov.w	r0, #2
 80a3fa6:	b086      	sub	sp, #24
    {
      // concept requirements
      __glibcxx_function_requires(_SGIAssignableConcept<_Tp>)

      _Tp __tmp = _GLIBCXX_MOVE(__a);
      __a = _GLIBCXX_MOVE(__b);
 80a3fa8:	f9b1 2004 	ldrsh.w	r2, [r1, #4]
      __b = _GLIBCXX_MOVE(__tmp);
 80a3fac:	808b      	strh	r3, [r1, #4]
 80a3fae:	2300      	movs	r3, #0
    {
      // concept requirements
      __glibcxx_function_requires(_SGIAssignableConcept<_Tp>)

      _Tp __tmp = _GLIBCXX_MOVE(__a);
      __a = _GLIBCXX_MOVE(__b);
 80a3fb0:	680f      	ldr	r7, [r1, #0]
            onSuccess_(nullptr),
            onError_(nullptr) {
    }

    bool changeState(State state) {
        State s = State::RUNNING; // Expected state
 80a3fb2:	f88d 3000 	strb.w	r3, [sp]
      __b = _GLIBCXX_MOVE(__tmp);
 80a3fb6:	600b      	str	r3, [r1, #0]
 80a3fb8:	e8d4 1f4f 	ldrexb	r1, [r4]
 80a3fbc:	4299      	cmp	r1, r3
 80a3fbe:	d103      	bne.n	80a3fc8 <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE8setErrorENS_5ErrorE+0x30>
 80a3fc0:	e8c4 0f45 	strexb	r5, r0, [r4]
 80a3fc4:	2d00      	cmp	r5, #0
 80a3fc6:	d1f7      	bne.n	80a3fb8 <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE8setErrorENS_5ErrorE+0x20>
 80a3fc8:	d002      	beq.n	80a3fd0 <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE8setErrorENS_5ErrorE+0x38>
 80a3fca:	f88d 1000 	strb.w	r1, [sp]
 80a3fce:	e06b      	b.n	80a40a8 <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE8setErrorENS_5ErrorE+0x110>
        return std::move(defaultValue);
    }

    void setError(Error error) {
        if (this->changeState(State::FAILED)) {
            new(&error_) Error(std::move(error));
 80a3fd0:	f114 050c 	adds.w	r5, r4, #12
    {
      // concept requirements
      __glibcxx_function_requires(_SGIAssignableConcept<_Tp>)

      _Tp __tmp = _GLIBCXX_MOVE(__a);
      __a = _GLIBCXX_MOVE(__b);
 80a3fd4:	bf1c      	itt	ne
 80a3fd6:	60e7      	strne	r7, [r4, #12]
 80a3fd8:	8222      	strhne	r2, [r4, #16]
        memory_order __b = __m & __memory_order_mask;
	__glibcxx_assert(__b != memory_order_acquire);
	__glibcxx_assert(__b != memory_order_acq_rel);
	__glibcxx_assert(__b != memory_order_consume);

	__atomic_store_n(&_M_i, __i, __m);
 80a3fda:	f3bf 8f5f 	dmb	sy
      __b = _GLIBCXX_MOVE(__tmp);
 80a3fde:	bf18      	it	ne
 80a3fe0:	461f      	movne	r7, r3
 80a3fe2:	2301      	movs	r3, #1
 80a3fe4:	7063      	strb	r3, [r4, #1]

      _GLIBCXX_ALWAYS_INLINE __pointer_type
      exchange(__pointer_type __p,
	       memory_order __m = memory_order_seq_cst) noexcept
      {
	return __atomic_exchange_n(&_M_p, __p, __m);
 80a3fe6:	f3bf 8f5f 	dmb	sy
 80a3fea:	f104 0308 	add.w	r3, r4, #8
 80a3fee:	2000      	movs	r0, #0
 80a3ff0:	e853 6f00 	ldrex	r6, [r3]
 80a3ff4:	e843 0200 	strex	r2, r0, [r3]
 80a3ff8:	2a00      	cmp	r2, #0
 80a3ffa:	d1f9      	bne.n	80a3ff0 <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE8setErrorENS_5ErrorE+0x58>
 80a3ffc:	f3bf 8f5f 	dmb	sy

    // Takes a callback from its atomic wrapper and invokes it
    template<typename FunctionT, typename... ArgsT>
    static void invokeCallback(std::atomic<std::function<FunctionT>*>& wrapper, ArgsT&&... args) {
        std::function<FunctionT>* callbackPtr = wrapper.exchange(nullptr, std::memory_order_acq_rel);
        if (callbackPtr) {
 80a4000:	2e00      	cmp	r6, #0
 80a4002:	d051      	beq.n	80a40a8 <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE8setErrorENS_5ErrorE+0x110>
        return (application_thread_invoke(callback, data, nullptr) == 0);
    }

    // Returns true if current thread is the application thread
    static bool isApplicationThreadCurrent() {
        return (application_thread_current(nullptr) != 0);
 80a4004:	f7ff fd1c 	bl	80a3a40 <application_thread_current>
    }

    // Invokes std::function in the application context
    template<typename FunctionT, typename... ArgsT>
    static void invokeCallback(const std::function<FunctionT>& callback, ArgsT&&... args) {
        if (ContextT::isApplicationThreadCurrent()) {
 80a4008:	b120      	cbz	r0, 80a4014 <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE8setErrorENS_5ErrorE+0x7c>
            callback(std::forward<ArgsT>(args)...); // Synchronous call
 80a400a:	4629      	mov	r1, r5
 80a400c:	4630      	mov	r0, r6
 80a400e:	f7ff ff93 	bl	80a3f38 <_ZNKSt8functionIFvRKN8particle5ErrorEEEclES3_>
 80a4012:	e043      	b.n	80a409c <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE8setErrorENS_5ErrorE+0x104>
	}

     public:
      template<typename... _Args>
	explicit _Bind(const _Functor& __f, _Args&&... __args)
	: _M_f(__f), _M_bound_args(std::forward<_Args>(__args)...)
 80a4014:	4631      	mov	r1, r6
 80a4016:	4668      	mov	r0, sp
 80a4018:	f7ff ffae 	bl	80a3f78 <_ZNSt8functionIFvRKN8particle5ErrorEEEC1ERKS5_>
inline particle::Error::Error(const char* msg) :
        Error(UNKNOWN, msg) {
}

inline particle::Error::Error(const Error& error) :
        Error(error.type_, error.msg_) {
 80a401c:	68e0      	ldr	r0, [r4, #12]
 80a401e:	f9b4 5010 	ldrsh.w	r5, [r4, #16]
        type_(type) {
}

inline particle::Error::Error(Type type, const char* msg) :
        msg_(msg ? (const char*)strdup(msg) : nullptr),
        type_(type) {
 80a4022:	b108      	cbz	r0, 80a4028 <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE8setErrorENS_5ErrorE+0x90>
 80a4024:	f002 f93a 	bl	80a629c <strdup>
 80a4028:	9004      	str	r0, [sp, #16]
        } else {
            // Bind all arguments and wrap resulting function into a pointer
            auto callbackPtr = new std::function<void()>(std::bind(callback, std::forward<ArgsT>(args)...));
 80a402a:	2010      	movs	r0, #16
 80a402c:	f8ad 5014 	strh.w	r5, [sp, #20]
 80a4030:	f7fc f833 	bl	80a009a <_Znwj>
 80a4034:	4605      	mov	r5, r0
 80a4036:	b330      	cbz	r0, 80a4086 <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE8setErrorENS_5ErrorE+0xee>
	{
	  _Base::_M_init_functor(__functor, std::__addressof(__f.get()));
	}
      };

    _Function_base() : _M_manager(nullptr) { }
 80a4038:	f04f 0800 	mov.w	r8, #0
 80a403c:	f8c0 8008 	str.w	r8, [r0, #8]
	_M_init_functor(_Any_data& __functor, _Functor&& __f, true_type)
	{ new (__functor._M_access()) _Functor(std::move(__f)); }

	static void
	_M_init_functor(_Any_data& __functor, _Functor&& __f, false_type)
	{ __functor._M_access<_Functor*>() = new _Functor(std::move(__f)); }
 80a4040:	2018      	movs	r0, #24
 80a4042:	f7fc f82a 	bl	80a009a <_Znwj>
 80a4046:	4604      	mov	r4, r0
 80a4048:	b1c0      	cbz	r0, 80a407c <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE8setErrorENS_5ErrorE+0xe4>
	{
	  _Base::_M_init_functor(__functor, std::__addressof(__f.get()));
	}
      };

    _Function_base() : _M_manager(nullptr) { }
 80a404a:	f8c0 8008 	str.w	r8, [r0, #8]
       *  Swap the targets of @c this function object and @a __f. This
       *  function will not throw an %exception.
       */
      void swap(function& __x)
      {
	std::swap(_M_functor, __x._M_functor);
 80a404e:	4601      	mov	r1, r0
 80a4050:	4668      	mov	r0, sp
 80a4052:	f7ff ff61 	bl	80a3f18 <_ZSt4swapISt9_Any_dataEvRT_S2_>
#endif
    {
      // concept requirements
      __glibcxx_function_requires(_SGIAssignableConcept<_Tp>)

      _Tp __tmp = _GLIBCXX_MOVE(__a);
 80a4056:	9b02      	ldr	r3, [sp, #8]
      __a = _GLIBCXX_MOVE(__b);
 80a4058:	68a2      	ldr	r2, [r4, #8]
      __b = _GLIBCXX_MOVE(__tmp);
 80a405a:	60a3      	str	r3, [r4, #8]
#endif
    {
      // concept requirements
      __glibcxx_function_requires(_SGIAssignableConcept<_Tp>)

      _Tp __tmp = _GLIBCXX_MOVE(__a);
 80a405c:	9b03      	ldr	r3, [sp, #12]
      __a = _GLIBCXX_MOVE(__b);
 80a405e:	9202      	str	r2, [sp, #8]
 80a4060:	68e2      	ldr	r2, [r4, #12]
      __b = _GLIBCXX_MOVE(__tmp);
 80a4062:	60e3      	str	r3, [r4, #12]
    {
      // concept requirements
      __glibcxx_function_requires(_SGIAssignableConcept<_Tp>)

      _Tp __tmp = _GLIBCXX_MOVE(__a);
      __a = _GLIBCXX_MOVE(__b);
 80a4064:	f8bd 3014 	ldrh.w	r3, [sp, #20]
 80a4068:	9203      	str	r2, [sp, #12]
 80a406a:	82a3      	strh	r3, [r4, #20]
      __b = _GLIBCXX_MOVE(__tmp);
 80a406c:	f64f 739c 	movw	r3, #65436	; 0xff9c
 80a4070:	f8ad 3014 	strh.w	r3, [sp, #20]
    {
      // concept requirements
      __glibcxx_function_requires(_SGIAssignableConcept<_Tp>)

      _Tp __tmp = _GLIBCXX_MOVE(__a);
      __a = _GLIBCXX_MOVE(__b);
 80a4074:	9b04      	ldr	r3, [sp, #16]
      __b = _GLIBCXX_MOVE(__tmp);
 80a4076:	f8cd 8010 	str.w	r8, [sp, #16]
    {
      // concept requirements
      __glibcxx_function_requires(_SGIAssignableConcept<_Tp>)

      _Tp __tmp = _GLIBCXX_MOVE(__a);
      __a = _GLIBCXX_MOVE(__b);
 80a407a:	6123      	str	r3, [r4, #16]
	typedef _Function_handler<_Signature_type, _Functor> _My_handler;

	if (_My_handler::_M_not_empty_function(__f))
	  {
	    _My_handler::_M_init_functor(_M_functor, std::move(__f));
	    _M_invoker = &_My_handler::_M_invoke;
 80a407c:	4b0d      	ldr	r3, [pc, #52]	; (80a40b4 <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE8setErrorENS_5ErrorE+0x11c>)
	_M_init_functor(_Any_data& __functor, _Functor&& __f, true_type)
	{ new (__functor._M_access()) _Functor(std::move(__f)); }

	static void
	_M_init_functor(_Any_data& __functor, _Functor&& __f, false_type)
	{ __functor._M_access<_Functor*>() = new _Functor(std::move(__f)); }
 80a407e:	602c      	str	r4, [r5, #0]
	typedef _Function_handler<_Signature_type, _Functor> _My_handler;

	if (_My_handler::_M_not_empty_function(__f))
	  {
	    _My_handler::_M_init_functor(_M_functor, std::move(__f));
	    _M_invoker = &_My_handler::_M_invoke;
 80a4080:	60eb      	str	r3, [r5, #12]
	    _M_manager = &_My_handler::_M_manager;
 80a4082:	4b0d      	ldr	r3, [pc, #52]	; (80a40b8 <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE8setErrorENS_5ErrorE+0x120>)
 80a4084:	60ab      	str	r3, [r5, #8]
        Error() {
    swap(*this, error);
}

inline particle::Error::~Error() {
    free((void*)msg_);
 80a4086:	9804      	ldr	r0, [sp, #16]
 80a4088:	f7ff fd06 	bl	80a3a98 <free>
   *  @ingroup functors
   *
   *  Polymorphic function wrapper.
   */
  template<typename _Res, typename... _ArgTypes>
    class function<_Res(_ArgTypes...)>
 80a408c:	4668      	mov	r0, sp
 80a408e:	f7fc fa01 	bl	80a0494 <_ZNSt14_Function_baseD1Ev>
        spark_process();
    }

    // Asynchronously invokes a callback in the application context
    static bool invokeApplicationCallback(void (*callback)(void* data), void* data) {
        return (application_thread_invoke(callback, data, nullptr) == 0);
 80a4092:	2200      	movs	r2, #0
 80a4094:	4629      	mov	r1, r5
 80a4096:	4809      	ldr	r0, [pc, #36]	; (80a40bc <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE8setErrorENS_5ErrorE+0x124>)
 80a4098:	f7ff fcda 	bl	80a3a50 <application_thread_invoke>
 80a409c:	4630      	mov	r0, r6
 80a409e:	f7fc f9f9 	bl	80a0494 <_ZNSt14_Function_baseD1Ev>
    template<typename FunctionT, typename... ArgsT>
    static void invokeCallback(std::atomic<std::function<FunctionT>*>& wrapper, ArgsT&&... args) {
        std::function<FunctionT>* callbackPtr = wrapper.exchange(nullptr, std::memory_order_acq_rel);
        if (callbackPtr) {
            invokeCallback(*callbackPtr, std::forward<ArgsT>(args)...);
            delete callbackPtr;
 80a40a2:	4630      	mov	r0, r6
 80a40a4:	f7fb fffd 	bl	80a00a2 <_ZdlPv>
 80a40a8:	4638      	mov	r0, r7
 80a40aa:	f7ff fcf5 	bl	80a3a98 <free>
            p_(std::move(ptr)) {
    }

    void setError(Error error) {
        p_->setError(std::move(error));
    }
 80a40ae:	b006      	add	sp, #24
 80a40b0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80a40b4:	080a3f4b 	.word	0x080a3f4b
 80a40b8:	080a41a9 	.word	0x080a41a9
 80a40bc:	080a3b7b 	.word	0x080a3b7b

080a40c0 <_ZN10CloudClass13publish_eventEPKcS1_iN8particle5FlagsI15PublishFlagTypehEE>:
    desc.data = (void*)data;
    desc.funcKey = funcKey;
    return spark_function(NULL, (user_function_int_str_t*)&desc, NULL);
}

Future<bool> CloudClass::publish_event(const char *eventName, const char *eventData, int ttl, PublishFlags flags) {
 80a40c0:	e92d 4ff0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, lr}
 80a40c4:	b08b      	sub	sp, #44	; 0x2c
#ifndef SPARK_NO_CLOUD
    spark_send_event_data d = { sizeof(spark_send_event_data) };
 80a40c6:	ad07      	add	r5, sp, #28
 80a40c8:	f04f 0b00 	mov.w	fp, #0
    desc.data = (void*)data;
    desc.funcKey = funcKey;
    return spark_function(NULL, (user_function_int_str_t*)&desc, NULL);
}

Future<bool> CloudClass::publish_event(const char *eventName, const char *eventData, int ttl, PublishFlags flags) {
 80a40cc:	4606      	mov	r6, r0
 80a40ce:	4699      	mov	r9, r3
// can be acquired via Future
template<typename ResultT, typename ContextT>
class PromiseBase {
public:
    PromiseBase() :
            p_(new detail::FutureImpl<ResultT, ContextT>(State::RUNNING)) {
 80a40d0:	2014      	movs	r0, #20
#ifndef SPARK_NO_CLOUD
    spark_send_event_data d = { sizeof(spark_send_event_data) };
 80a40d2:	230c      	movs	r3, #12
    desc.data = (void*)data;
    desc.funcKey = funcKey;
    return spark_function(NULL, (user_function_int_str_t*)&desc, NULL);
}

Future<bool> CloudClass::publish_event(const char *eventName, const char *eventData, int ttl, PublishFlags flags) {
 80a40d4:	460f      	mov	r7, r1
 80a40d6:	4690      	mov	r8, r2
 80a40d8:	f89d a050 	ldrb.w	sl, [sp, #80]	; 0x50
#ifndef SPARK_NO_CLOUD
    spark_send_event_data d = { sizeof(spark_send_event_data) };
 80a40dc:	f8c5 b004 	str.w	fp, [r5, #4]
 80a40e0:	f8c5 b008 	str.w	fp, [r5, #8]
 80a40e4:	9307      	str	r3, [sp, #28]
 80a40e6:	f7fb ffd8 	bl	80a009a <_Znwj>
 80a40ea:	4604      	mov	r4, r0
 80a40ec:	b138      	cbz	r0, 80a40fe <_ZN10CloudClass13publish_eventEPKcS1_iN8particle5FlagsI15PublishFlagTypehEE+0x3e>
      ~atomic() noexcept = default;
      atomic(const atomic&) = delete;
      atomic& operator=(const atomic&) = delete;
      atomic& operator=(const atomic&) volatile = delete;

      constexpr atomic(_Tp __i) noexcept : _M_i(__i) { }
 80a40ee:	f880 b000 	strb.w	fp, [r0]
      __atomic_base(const __atomic_base&) = delete;
      __atomic_base& operator=(const __atomic_base&) = delete;
      __atomic_base& operator=(const __atomic_base&) volatile = delete;

      // Requires __int_type convertible to _M_i.
      constexpr __atomic_base(__int_type __i) noexcept : _M_i (__i) { }
 80a40f2:	f880 b001 	strb.w	fp, [r0, #1]
      __atomic_base(const __atomic_base&) = delete;
      __atomic_base& operator=(const __atomic_base&) = delete;
      __atomic_base& operator=(const __atomic_base&) volatile = delete;

      // Requires __pointer_type convertible to _M_p.
      constexpr __atomic_base(__pointer_type __p) noexcept : _M_p (__p) { }
 80a40f6:	f8c0 b004 	str.w	fp, [r0, #4]
 80a40fa:	f8c0 b008 	str.w	fp, [r0, #8]
      constexpr __shared_count() noexcept : _M_pi(0)
      { }

      template<typename _Ptr>
        explicit
	__shared_count(_Ptr __p) : _M_pi(0)
 80a40fe:	2300      	movs	r3, #0
	{
	  __try
	    {
	      _M_pi = new _Sp_counted_ptr<_Ptr, _Lp>(__p);
 80a4100:	2010      	movs	r0, #16
      : _M_ptr(0), _M_refcount()
      { }

      template<typename _Tp1>
	explicit __shared_ptr(_Tp1* __p)
        : _M_ptr(__p), _M_refcount(__p)
 80a4102:	9403      	str	r4, [sp, #12]
      constexpr __shared_count() noexcept : _M_pi(0)
      { }

      template<typename _Ptr>
        explicit
	__shared_count(_Ptr __p) : _M_pi(0)
 80a4104:	9304      	str	r3, [sp, #16]
	{
	  __try
	    {
	      _M_pi = new _Sp_counted_ptr<_Ptr, _Lp>(__p);
 80a4106:	f7fb ffc8 	bl	80a009a <_Znwj>
 80a410a:	b128      	cbz	r0, 80a4118 <_ZN10CloudClass13publish_eventEPKcS1_iN8particle5FlagsI15PublishFlagTypehEE+0x58>
    class _Sp_counted_base
    : public _Mutex_base<_Lp>
    {
    public:  
      _Sp_counted_base() noexcept
      : _M_use_count(1), _M_weak_count(1) { }
 80a410c:	2301      	movs	r3, #1
 80a410e:	6043      	str	r3, [r0, #4]
 80a4110:	6083      	str	r3, [r0, #8]
    class _Sp_counted_ptr final : public _Sp_counted_base<_Lp>
    {
    public:
      explicit
      _Sp_counted_ptr(_Ptr __p) noexcept
      : _M_ptr(__p) { }
 80a4112:	4b23      	ldr	r3, [pc, #140]	; (80a41a0 <_ZN10CloudClass13publish_eventEPKcS1_iN8particle5FlagsI15PublishFlagTypehEE+0xe0>)
 80a4114:	60c4      	str	r4, [r0, #12]
 80a4116:	6003      	str	r3, [r0, #0]

    // Completion handler
    Promise<bool> p;
    d.handler_callback = publishCompletionCallback;
 80a4118:	4b22      	ldr	r3, [pc, #136]	; (80a41a4 <_ZN10CloudClass13publish_eventEPKcS1_iN8particle5FlagsI15PublishFlagTypehEE+0xe4>)
        explicit
	__shared_count(_Ptr __p) : _M_pi(0)
	{
	  __try
	    {
	      _M_pi = new _Sp_counted_ptr<_Ptr, _Lp>(__p);
 80a411a:	9004      	str	r0, [sp, #16]
    }

    // Wraps this promise into an object pointer that can be passed to a C function
    void* dataPtr() const {
        // TODO: Use custom reference counting object to avoid unnecessary memory allocation
        return new detail::FutureImplPtr<ResultT, ContextT>(p_);
 80a411c:	2008      	movs	r0, #8
 80a411e:	9308      	str	r3, [sp, #32]
 80a4120:	f7fb ffbb 	bl	80a009a <_Znwj>
 80a4124:	4604      	mov	r4, r0
 80a4126:	b128      	cbz	r0, 80a4134 <_ZN10CloudClass13publish_eventEPKcS1_iN8particle5FlagsI15PublishFlagTypehEE+0x74>
      template<typename _Tp1>
	__shared_ptr(const __shared_ptr<_Tp1, _Lp>& __r, _Tp* __p) noexcept
	: _M_ptr(__p), _M_refcount(__r._M_refcount) // never throws
	{ }

      __shared_ptr(const __shared_ptr&) noexcept = default;
 80a4128:	9b03      	ldr	r3, [sp, #12]
 80a412a:	a904      	add	r1, sp, #16
 80a412c:	f840 3b04 	str.w	r3, [r0], #4
 80a4130:	f7ff fece 	bl	80a3ed0 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EEC1ERKS2_>
    d.handler_data = p.dataPtr();

    if (!spark_send_event(eventName, eventData, ttl, flags.value(), &d) && !p.isDone()) {
 80a4134:	9500      	str	r5, [sp, #0]
 80a4136:	fa5f f38a 	uxtb.w	r3, sl
 80a413a:	464a      	mov	r2, r9
 80a413c:	4641      	mov	r1, r8
 80a413e:	4638      	mov	r0, r7
    spark_send_event_data d = { sizeof(spark_send_event_data) };

    // Completion handler
    Promise<bool> p;
    d.handler_callback = publishCompletionCallback;
    d.handler_data = p.dataPtr();
 80a4140:	9409      	str	r4, [sp, #36]	; 0x24

    if (!spark_send_event(eventName, eventData, ttl, flags.value(), &d) && !p.isDone()) {
 80a4142:	f7ff fc45 	bl	80a39d0 <spark_send_event>
 80a4146:	b9b8      	cbnz	r0, 80a4178 <_ZN10CloudClass13publish_eventEPKcS1_iN8particle5FlagsI15PublishFlagTypehEE+0xb8>
      {
       memory_order __b = __m & __memory_order_mask;
	__glibcxx_assert(__b != memory_order_release);
	__glibcxx_assert(__b != memory_order_acq_rel);

	return __atomic_load_n(&_M_i, __m);
 80a4148:	9b03      	ldr	r3, [sp, #12]
 80a414a:	785b      	ldrb	r3, [r3, #1]
 80a414c:	f003 02ff 	and.w	r2, r3, #255	; 0xff
 80a4150:	b993      	cbnz	r3, 80a4178 <_ZN10CloudClass13publish_eventEPKcS1_iN8particle5FlagsI15PublishFlagTypehEE+0xb8>

} // namespace particle

inline particle::Error::Error(Type type) :
        msg_(nullptr),
        type_(type) {
 80a4152:	f64f 739c 	movw	r3, #65436	; 0xff9c
        // Set generic error code in case completion callback wasn't invoked for some reason
        p.setError(Error::UNKNOWN);
 80a4156:	a905      	add	r1, sp, #20
 80a4158:	a803      	add	r0, sp, #12
 80a415a:	9205      	str	r2, [sp, #20]
 80a415c:	f8ad 3018 	strh.w	r3, [sp, #24]
 80a4160:	f7ff ff1a 	bl	80a3f98 <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE8setErrorENS_5ErrorE>
        Error() {
    swap(*this, error);
}

inline particle::Error::~Error() {
    free((void*)msg_);
 80a4164:	9805      	ldr	r0, [sp, #20]
 80a4166:	f7ff fc97 	bl	80a3a98 <free>
        p.fromDataPtr(d.handler_data); // Free wrapper object
 80a416a:	a805      	add	r0, sp, #20
 80a416c:	9909      	ldr	r1, [sp, #36]	; 0x24
 80a416e:	f7ff feb6 	bl	80a3ede <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE11fromDataPtrEPv>
      __shared_ptr& operator=(const __shared_ptr&) noexcept = default;
      ~__shared_ptr() = default;
 80a4172:	a806      	add	r0, sp, #24
 80a4174:	f7ff fcc8 	bl	80a3b08 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev>
      template<typename _Tp1>
	__shared_ptr(const __shared_ptr<_Tp1, _Lp>& __r, _Tp* __p) noexcept
	: _M_ptr(__p), _M_refcount(__r._M_refcount) // never throws
	{ }

      __shared_ptr(const __shared_ptr&) noexcept = default;
 80a4178:	9b03      	ldr	r3, [sp, #12]
 80a417a:	a904      	add	r1, sp, #16
 80a417c:	a806      	add	r0, sp, #24
 80a417e:	9305      	str	r3, [sp, #20]
 80a4180:	f7ff fea6 	bl	80a3ed0 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EEC1ERKS2_>
    bool isDone() const {
        return p_->isDone();
    }

    Future<ResultT, ContextT> future() const {
        return Future<ResultT, ContextT>(p_);
 80a4184:	a905      	add	r1, sp, #20
 80a4186:	4630      	mov	r0, r6
 80a4188:	f7ff fe91 	bl	80a3eae <_ZN8particle6FutureIbNS_6detail13FutureContextEEC1ESt10shared_ptrINS1_10FutureImplIbS2_EEE>
      __shared_ptr& operator=(const __shared_ptr&) noexcept = default;
      ~__shared_ptr() = default;
 80a418c:	a806      	add	r0, sp, #24
 80a418e:	f7ff fcbb 	bl	80a3b08 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev>
 80a4192:	a804      	add	r0, sp, #16
 80a4194:	f7ff fcb8 	bl	80a3b08 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev>

    return p.future();
#else
    return Future<bool>(Error::NOT_SUPPORTED);
#endif
}
 80a4198:	4630      	mov	r0, r6
 80a419a:	b00b      	add	sp, #44	; 0x2c
 80a419c:	e8bd 8ff0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, fp, pc}
 80a41a0:	080a69f4 	.word	0x080a69f4
 80a41a4:	080a4311 	.word	0x080a4311

080a41a8 <_ZNSt14_Function_base13_Base_managerISt5_BindIFSt8functionIFvRKN8particle5ErrorEEES4_EEE10_M_managerERSt9_Any_dataRKSC_St18_Manager_operation>:
      public:
	static bool
	_M_manager(_Any_data& __dest, const _Any_data& __source,
		   _Manager_operation __op)
	{
	  switch (__op)
 80a41a8:	2a02      	cmp	r2, #2
	  delete __victim._M_access<_Functor*>();
	}

      public:
	static bool
	_M_manager(_Any_data& __dest, const _Any_data& __source,
 80a41aa:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80a41ac:	4604      	mov	r4, r0
		   _Manager_operation __op)
	{
	  switch (__op)
 80a41ae:	d006      	beq.n	80a41be <_ZNSt14_Function_base13_Base_managerISt5_BindIFSt8functionIFvRKN8particle5ErrorEEES4_EEE10_M_managerERSt9_Any_dataRKSC_St18_Manager_operation+0x16>
 80a41b0:	2a03      	cmp	r2, #3
 80a41b2:	d017      	beq.n	80a41e4 <_ZNSt14_Function_base13_Base_managerISt5_BindIFSt8functionIFvRKN8particle5ErrorEEES4_EEE10_M_managerERSt9_Any_dataRKSC_St18_Manager_operation+0x3c>
 80a41b4:	2a01      	cmp	r2, #1
 80a41b6:	d120      	bne.n	80a41fa <_ZNSt14_Function_base13_Base_managerISt5_BindIFSt8functionIFvRKN8particle5ErrorEEES4_EEE10_M_managerERSt9_Any_dataRKSC_St18_Manager_operation+0x52>
	static _Functor*
	_M_get_pointer(const _Any_data& __source)
	{
	  const _Functor* __ptr =
	    __stored_locally? std::__addressof(__source._M_access<_Functor>())
	    /* have stored a pointer */ : __source._M_access<_Functor*>();
 80a41b8:	680b      	ldr	r3, [r1, #0]
	    case __get_type_info:
	      __dest._M_access<const type_info*>() = &typeid(_Functor);
	      break;
#endif
	    case __get_functor_ptr:
	      __dest._M_access<_Functor*>() = _M_get_pointer(__source);
 80a41ba:	6003      	str	r3, [r0, #0]
	      break;
 80a41bc:	e01d      	b.n	80a41fa <_ZNSt14_Function_base13_Base_managerISt5_BindIFSt8functionIFvRKN8particle5ErrorEEES4_EEE10_M_managerERSt9_Any_dataRKSC_St18_Manager_operation+0x52>
	// Clone a function object that is not location-invariant or
	// that cannot fit into an _Any_data structure.
	static void
	_M_clone(_Any_data& __dest, const _Any_data& __source, false_type)
	{
	  __dest._M_access<_Functor*>() =
 80a41be:	2018      	movs	r0, #24
 80a41c0:	680e      	ldr	r6, [r1, #0]
 80a41c2:	f7fb ff6a 	bl	80a009a <_Znwj>
 80a41c6:	4605      	mov	r5, r0
 80a41c8:	b150      	cbz	r0, 80a41e0 <_ZNSt14_Function_base13_Base_managerISt5_BindIFSt8functionIFvRKN8particle5ErrorEEES4_EEE10_M_managerERSt9_Any_dataRKSC_St18_Manager_operation+0x38>
      template<typename... _Args>
	explicit _Bind(_Functor&& __f, _Args&&... __args)
	: _M_f(std::move(__f)), _M_bound_args(std::forward<_Args>(__args)...)
	{ }

      _Bind(const _Bind&) = default;
 80a41ca:	4631      	mov	r1, r6
 80a41cc:	f7ff fed4 	bl	80a3f78 <_ZNSt8functionIFvRKN8particle5ErrorEEEC1ERKS5_>
inline particle::Error::Error(const char* msg) :
        Error(UNKNOWN, msg) {
}

inline particle::Error::Error(const Error& error) :
        Error(error.type_, error.msg_) {
 80a41d0:	6930      	ldr	r0, [r6, #16]
 80a41d2:	f9b6 7014 	ldrsh.w	r7, [r6, #20]
        type_(type) {
}

inline particle::Error::Error(Type type, const char* msg) :
        msg_(msg ? (const char*)strdup(msg) : nullptr),
        type_(type) {
 80a41d6:	b108      	cbz	r0, 80a41dc <_ZNSt14_Function_base13_Base_managerISt5_BindIFSt8functionIFvRKN8particle5ErrorEEES4_EEE10_M_managerERSt9_Any_dataRKSC_St18_Manager_operation+0x34>
 80a41d8:	f002 f860 	bl	80a629c <strdup>
 80a41dc:	6128      	str	r0, [r5, #16]
 80a41de:	82af      	strh	r7, [r5, #20]
	// Clone a function object that is not location-invariant or
	// that cannot fit into an _Any_data structure.
	static void
	_M_clone(_Any_data& __dest, const _Any_data& __source, false_type)
	{
	  __dest._M_access<_Functor*>() =
 80a41e0:	6025      	str	r5, [r4, #0]
 80a41e2:	e00a      	b.n	80a41fa <_ZNSt14_Function_base13_Base_managerISt5_BindIFSt8functionIFvRKN8particle5ErrorEEES4_EEE10_M_managerERSt9_Any_dataRKSC_St18_Manager_operation+0x52>

	// Destroying an object located on the heap.
	static void
	_M_destroy(_Any_data& __victim, false_type)
	{
	  delete __victim._M_access<_Functor*>();
 80a41e4:	6804      	ldr	r4, [r0, #0]
 80a41e6:	b144      	cbz	r4, 80a41fa <_ZNSt14_Function_base13_Base_managerISt5_BindIFSt8functionIFvRKN8particle5ErrorEEES4_EEE10_M_managerERSt9_Any_dataRKSC_St18_Manager_operation+0x52>
        Error() {
    swap(*this, error);
}

inline particle::Error::~Error() {
    free((void*)msg_);
 80a41e8:	6920      	ldr	r0, [r4, #16]
 80a41ea:	f7ff fc55 	bl	80a3a98 <free>
   *  @ingroup functors
   *
   *  Polymorphic function wrapper.
   */
  template<typename _Res, typename... _ArgTypes>
    class function<_Res(_ArgTypes...)>
 80a41ee:	4620      	mov	r0, r4
 80a41f0:	f7fc f950 	bl	80a0494 <_ZNSt14_Function_baseD1Ev>

	// Destroying an object located on the heap.
	static void
	_M_destroy(_Any_data& __victim, false_type)
	{
	  delete __victim._M_access<_Functor*>();
 80a41f4:	4620      	mov	r0, r4
 80a41f6:	f7fb ff54 	bl	80a00a2 <_ZdlPv>
	    case __destroy_functor:
	      _M_destroy(__dest, _Local_storage());
	      break;
	    }
	  return false;
	}
 80a41fa:	2000      	movs	r0, #0
 80a41fc:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

080a41fe <_ZNSt8functionIFvRKbEEC1ERKS3_>:
      _Invoker_type _M_invoker;
  };

  // Out-of-line member definitions.
  template<typename _Res, typename... _ArgTypes>
    function<_Res(_ArgTypes...)>::
 80a41fe:	b538      	push	{r3, r4, r5, lr}
	{
	  _Base::_M_init_functor(__functor, std::__addressof(__f.get()));
	}
      };

    _Function_base() : _M_manager(nullptr) { }
 80a4200:	2300      	movs	r3, #0
 80a4202:	6083      	str	r3, [r0, #8]
 80a4204:	688b      	ldr	r3, [r1, #8]
      _Invoker_type _M_invoker;
  };

  // Out-of-line member definitions.
  template<typename _Res, typename... _ArgTypes>
    function<_Res(_ArgTypes...)>::
 80a4206:	4604      	mov	r4, r0
 80a4208:	460d      	mov	r5, r1
    function(const function& __x)
    : _Function_base()
    {
      if (static_cast<bool>(__x))
 80a420a:	b12b      	cbz	r3, 80a4218 <_ZNSt8functionIFvRKbEEC1ERKS3_+0x1a>
	{
	  __x._M_manager(_M_functor, __x._M_functor, __clone_functor);
 80a420c:	2202      	movs	r2, #2
 80a420e:	4798      	blx	r3
	  _M_invoker = __x._M_invoker;
 80a4210:	68eb      	ldr	r3, [r5, #12]
 80a4212:	60e3      	str	r3, [r4, #12]
	  _M_manager = __x._M_manager;
 80a4214:	68ab      	ldr	r3, [r5, #8]
 80a4216:	60a3      	str	r3, [r4, #8]
	}
    }
 80a4218:	4620      	mov	r0, r4
 80a421a:	bd38      	pop	{r3, r4, r5, pc}

080a421c <_ZNSt14_Function_base13_Base_managerISt5_BindIFSt8functionIFvRKbEEbEEE10_M_managerERSt9_Any_dataRKSA_St18_Manager_operation>:
      public:
	static bool
	_M_manager(_Any_data& __dest, const _Any_data& __source,
		   _Manager_operation __op)
	{
	  switch (__op)
 80a421c:	2a02      	cmp	r2, #2
	  delete __victim._M_access<_Functor*>();
	}

      public:
	static bool
	_M_manager(_Any_data& __dest, const _Any_data& __source,
 80a421e:	b570      	push	{r4, r5, r6, lr}
 80a4220:	4604      	mov	r4, r0
		   _Manager_operation __op)
	{
	  switch (__op)
 80a4222:	d006      	beq.n	80a4232 <_ZNSt14_Function_base13_Base_managerISt5_BindIFSt8functionIFvRKbEEbEEE10_M_managerERSt9_Any_dataRKSA_St18_Manager_operation+0x16>
 80a4224:	2a03      	cmp	r2, #3
 80a4226:	d011      	beq.n	80a424c <_ZNSt14_Function_base13_Base_managerISt5_BindIFSt8functionIFvRKbEEbEEE10_M_managerERSt9_Any_dataRKSA_St18_Manager_operation+0x30>
 80a4228:	2a01      	cmp	r2, #1
 80a422a:	d117      	bne.n	80a425c <_ZNSt14_Function_base13_Base_managerISt5_BindIFSt8functionIFvRKbEEbEEE10_M_managerERSt9_Any_dataRKSA_St18_Manager_operation+0x40>
	static _Functor*
	_M_get_pointer(const _Any_data& __source)
	{
	  const _Functor* __ptr =
	    __stored_locally? std::__addressof(__source._M_access<_Functor>())
	    /* have stored a pointer */ : __source._M_access<_Functor*>();
 80a422c:	680b      	ldr	r3, [r1, #0]
	    case __get_type_info:
	      __dest._M_access<const type_info*>() = &typeid(_Functor);
	      break;
#endif
	    case __get_functor_ptr:
	      __dest._M_access<_Functor*>() = _M_get_pointer(__source);
 80a422e:	6003      	str	r3, [r0, #0]
	      break;
 80a4230:	e014      	b.n	80a425c <_ZNSt14_Function_base13_Base_managerISt5_BindIFSt8functionIFvRKbEEbEEE10_M_managerERSt9_Any_dataRKSA_St18_Manager_operation+0x40>
	// Clone a function object that is not location-invariant or
	// that cannot fit into an _Any_data structure.
	static void
	_M_clone(_Any_data& __dest, const _Any_data& __source, false_type)
	{
	  __dest._M_access<_Functor*>() =
 80a4232:	2014      	movs	r0, #20
 80a4234:	680e      	ldr	r6, [r1, #0]
 80a4236:	f7fb ff30 	bl	80a009a <_Znwj>
 80a423a:	4605      	mov	r5, r0
 80a423c:	b120      	cbz	r0, 80a4248 <_ZNSt14_Function_base13_Base_managerISt5_BindIFSt8functionIFvRKbEEbEEE10_M_managerERSt9_Any_dataRKSA_St18_Manager_operation+0x2c>
      template<typename... _Args>
	explicit _Bind(_Functor&& __f, _Args&&... __args)
	: _M_f(std::move(__f)), _M_bound_args(std::forward<_Args>(__args)...)
	{ }

      _Bind(const _Bind&) = default;
 80a423e:	4631      	mov	r1, r6
 80a4240:	f7ff ffdd 	bl	80a41fe <_ZNSt8functionIFvRKbEEC1ERKS3_>
 80a4244:	7c33      	ldrb	r3, [r6, #16]
 80a4246:	742b      	strb	r3, [r5, #16]
	// Clone a function object that is not location-invariant or
	// that cannot fit into an _Any_data structure.
	static void
	_M_clone(_Any_data& __dest, const _Any_data& __source, false_type)
	{
	  __dest._M_access<_Functor*>() =
 80a4248:	6025      	str	r5, [r4, #0]
 80a424a:	e007      	b.n	80a425c <_ZNSt14_Function_base13_Base_managerISt5_BindIFSt8functionIFvRKbEEbEEE10_M_managerERSt9_Any_dataRKSA_St18_Manager_operation+0x40>

	// Destroying an object located on the heap.
	static void
	_M_destroy(_Any_data& __victim, false_type)
	{
	  delete __victim._M_access<_Functor*>();
 80a424c:	6804      	ldr	r4, [r0, #0]
 80a424e:	b12c      	cbz	r4, 80a425c <_ZNSt14_Function_base13_Base_managerISt5_BindIFSt8functionIFvRKbEEbEEE10_M_managerERSt9_Any_dataRKSA_St18_Manager_operation+0x40>
   *  @ingroup functors
   *
   *  Polymorphic function wrapper.
   */
  template<typename _Res, typename... _ArgTypes>
    class function<_Res(_ArgTypes...)>
 80a4250:	4620      	mov	r0, r4
 80a4252:	f7fc f91f 	bl	80a0494 <_ZNSt14_Function_baseD1Ev>

	// Destroying an object located on the heap.
	static void
	_M_destroy(_Any_data& __victim, false_type)
	{
	  delete __victim._M_access<_Functor*>();
 80a4256:	4620      	mov	r0, r4
 80a4258:	f7fb ff23 	bl	80a00a2 <_ZdlPv>
	    case __destroy_functor:
	      _M_destroy(__dest, _Local_storage());
	      break;
	    }
	  return false;
	}
 80a425c:	2000      	movs	r0, #0
 80a425e:	bd70      	pop	{r4, r5, r6, pc}

080a4260 <_ZN8particle6detail14FutureImplBaseIbNS0_13FutureContextEE14invokeCallbackIFvRKbEIRbEEEvRSt6atomicIPSt8functionIT_EEDpOT0_>:
        delete callbackPtr; // Delete old callback
    }

    // Takes a callback from its atomic wrapper and invokes it
    template<typename FunctionT, typename... ArgsT>
    static void invokeCallback(std::atomic<std::function<FunctionT>*>& wrapper, ArgsT&&... args) {
 80a4260:	b5f0      	push	{r4, r5, r6, r7, lr}
 80a4262:	460c      	mov	r4, r1

      _GLIBCXX_ALWAYS_INLINE __pointer_type
      exchange(__pointer_type __p,
	       memory_order __m = memory_order_seq_cst) noexcept
      {
	return __atomic_exchange_n(&_M_p, __p, __m);
 80a4264:	f3bf 8f5f 	dmb	sy
 80a4268:	b087      	sub	sp, #28
 80a426a:	2300      	movs	r3, #0
 80a426c:	e850 6f00 	ldrex	r6, [r0]
 80a4270:	e840 3200 	strex	r2, r3, [r0]
 80a4274:	2a00      	cmp	r2, #0
 80a4276:	d1f9      	bne.n	80a426c <_ZN8particle6detail14FutureImplBaseIbNS0_13FutureContextEE14invokeCallbackIFvRKbEIRbEEEvRSt6atomicIPSt8functionIT_EEDpOT0_+0xc>
 80a4278:	f3bf 8f5f 	dmb	sy
        std::function<FunctionT>* callbackPtr = wrapper.exchange(nullptr, std::memory_order_acq_rel);
        if (callbackPtr) {
 80a427c:	2e00      	cmp	r6, #0
 80a427e:	d03e      	beq.n	80a42fe <_ZN8particle6detail14FutureImplBaseIbNS0_13FutureContextEE14invokeCallbackIFvRKbEIRbEEEvRSt6atomicIPSt8functionIT_EEDpOT0_+0x9e>
        return (application_thread_invoke(callback, data, nullptr) == 0);
    }

    // Returns true if current thread is the application thread
    static bool isApplicationThreadCurrent() {
        return (application_thread_current(nullptr) != 0);
 80a4280:	4618      	mov	r0, r3
 80a4282:	f7ff fbdd 	bl	80a3a40 <application_thread_current>
    }

    // Invokes std::function in the application context
    template<typename FunctionT, typename... ArgsT>
    static void invokeCallback(const std::function<FunctionT>& callback, ArgsT&&... args) {
        if (ContextT::isApplicationThreadCurrent()) {
 80a4286:	4607      	mov	r7, r0
 80a4288:	b120      	cbz	r0, 80a4294 <_ZN8particle6detail14FutureImplBaseIbNS0_13FutureContextEE14invokeCallbackIFvRKbEIRbEEEvRSt6atomicIPSt8functionIT_EEDpOT0_+0x34>
            callback(std::forward<ArgsT>(args)...); // Synchronous call
 80a428a:	4621      	mov	r1, r4
 80a428c:	4630      	mov	r0, r6
 80a428e:	f7ff fe63 	bl	80a3f58 <_ZNKSt8functionIFvRKbEEclES1_>
 80a4292:	e02e      	b.n	80a42f2 <_ZN8particle6detail14FutureImplBaseIbNS0_13FutureContextEE14invokeCallbackIFvRKbEIRbEEEvRSt6atomicIPSt8functionIT_EEDpOT0_+0x92>
	}

     public:
      template<typename... _Args>
	explicit _Bind(const _Functor& __f, _Args&&... __args)
	: _M_f(__f), _M_bound_args(std::forward<_Args>(__args)...)
 80a4294:	4631      	mov	r1, r6
 80a4296:	a801      	add	r0, sp, #4
 80a4298:	f7ff ffb1 	bl	80a41fe <_ZNSt8functionIFvRKbEEC1ERKS3_>
 80a429c:	7823      	ldrb	r3, [r4, #0]
        } else {
            // Bind all arguments and wrap resulting function into a pointer
            auto callbackPtr = new std::function<void()>(std::bind(callback, std::forward<ArgsT>(args)...));
 80a429e:	2010      	movs	r0, #16
 80a42a0:	f88d 3014 	strb.w	r3, [sp, #20]
 80a42a4:	f7fb fef9 	bl	80a009a <_Znwj>
 80a42a8:	4605      	mov	r5, r0
 80a42aa:	b1d0      	cbz	r0, 80a42e2 <_ZN8particle6detail14FutureImplBaseIbNS0_13FutureContextEE14invokeCallbackIFvRKbEIRbEEEvRSt6atomicIPSt8functionIT_EEDpOT0_+0x82>
	{
	  _Base::_M_init_functor(__functor, std::__addressof(__f.get()));
	}
      };

    _Function_base() : _M_manager(nullptr) { }
 80a42ac:	6087      	str	r7, [r0, #8]
	_M_init_functor(_Any_data& __functor, _Functor&& __f, true_type)
	{ new (__functor._M_access()) _Functor(std::move(__f)); }

	static void
	_M_init_functor(_Any_data& __functor, _Functor&& __f, false_type)
	{ __functor._M_access<_Functor*>() = new _Functor(std::move(__f)); }
 80a42ae:	2014      	movs	r0, #20
 80a42b0:	f7fb fef3 	bl	80a009a <_Znwj>
 80a42b4:	4604      	mov	r4, r0
 80a42b6:	b178      	cbz	r0, 80a42d8 <_ZN8particle6detail14FutureImplBaseIbNS0_13FutureContextEE14invokeCallbackIFvRKbEIRbEEEvRSt6atomicIPSt8functionIT_EEDpOT0_+0x78>
	{
	  _Base::_M_init_functor(__functor, std::__addressof(__f.get()));
	}
      };

    _Function_base() : _M_manager(nullptr) { }
 80a42b8:	6087      	str	r7, [r0, #8]
       *  Swap the targets of @c this function object and @a __f. This
       *  function will not throw an %exception.
       */
      void swap(function& __x)
      {
	std::swap(_M_functor, __x._M_functor);
 80a42ba:	4601      	mov	r1, r0
 80a42bc:	a801      	add	r0, sp, #4
 80a42be:	f7ff fe2b 	bl	80a3f18 <_ZSt4swapISt9_Any_dataEvRT_S2_>
#endif
    {
      // concept requirements
      __glibcxx_function_requires(_SGIAssignableConcept<_Tp>)

      _Tp __tmp = _GLIBCXX_MOVE(__a);
 80a42c2:	9b03      	ldr	r3, [sp, #12]
      __a = _GLIBCXX_MOVE(__b);
 80a42c4:	68a2      	ldr	r2, [r4, #8]
      __b = _GLIBCXX_MOVE(__tmp);
 80a42c6:	60a3      	str	r3, [r4, #8]
#endif
    {
      // concept requirements
      __glibcxx_function_requires(_SGIAssignableConcept<_Tp>)

      _Tp __tmp = _GLIBCXX_MOVE(__a);
 80a42c8:	9b04      	ldr	r3, [sp, #16]
      __a = _GLIBCXX_MOVE(__b);
 80a42ca:	9203      	str	r2, [sp, #12]
 80a42cc:	68e2      	ldr	r2, [r4, #12]
      __b = _GLIBCXX_MOVE(__tmp);
 80a42ce:	60e3      	str	r3, [r4, #12]
 80a42d0:	f89d 3014 	ldrb.w	r3, [sp, #20]
    {
      // concept requirements
      __glibcxx_function_requires(_SGIAssignableConcept<_Tp>)

      _Tp __tmp = _GLIBCXX_MOVE(__a);
      __a = _GLIBCXX_MOVE(__b);
 80a42d4:	9204      	str	r2, [sp, #16]
 80a42d6:	7423      	strb	r3, [r4, #16]
	typedef _Function_handler<_Signature_type, _Functor> _My_handler;

	if (_My_handler::_M_not_empty_function(__f))
	  {
	    _My_handler::_M_init_functor(_M_functor, std::move(__f));
	    _M_invoker = &_My_handler::_M_invoke;
 80a42d8:	4b0a      	ldr	r3, [pc, #40]	; (80a4304 <_ZN8particle6detail14FutureImplBaseIbNS0_13FutureContextEE14invokeCallbackIFvRKbEIRbEEEvRSt6atomicIPSt8functionIT_EEDpOT0_+0xa4>)
	_M_init_functor(_Any_data& __functor, _Functor&& __f, true_type)
	{ new (__functor._M_access()) _Functor(std::move(__f)); }

	static void
	_M_init_functor(_Any_data& __functor, _Functor&& __f, false_type)
	{ __functor._M_access<_Functor*>() = new _Functor(std::move(__f)); }
 80a42da:	602c      	str	r4, [r5, #0]
	typedef _Function_handler<_Signature_type, _Functor> _My_handler;

	if (_My_handler::_M_not_empty_function(__f))
	  {
	    _My_handler::_M_init_functor(_M_functor, std::move(__f));
	    _M_invoker = &_My_handler::_M_invoke;
 80a42dc:	60eb      	str	r3, [r5, #12]
	    _M_manager = &_My_handler::_M_manager;
 80a42de:	4b0a      	ldr	r3, [pc, #40]	; (80a4308 <_ZN8particle6detail14FutureImplBaseIbNS0_13FutureContextEE14invokeCallbackIFvRKbEIRbEEEvRSt6atomicIPSt8functionIT_EEDpOT0_+0xa8>)
 80a42e0:	60ab      	str	r3, [r5, #8]
   *  @ingroup functors
   *
   *  Polymorphic function wrapper.
   */
  template<typename _Res, typename... _ArgTypes>
    class function<_Res(_ArgTypes...)>
 80a42e2:	a801      	add	r0, sp, #4
 80a42e4:	f7fc f8d6 	bl	80a0494 <_ZNSt14_Function_baseD1Ev>
        spark_process();
    }

    // Asynchronously invokes a callback in the application context
    static bool invokeApplicationCallback(void (*callback)(void* data), void* data) {
        return (application_thread_invoke(callback, data, nullptr) == 0);
 80a42e8:	2200      	movs	r2, #0
 80a42ea:	4629      	mov	r1, r5
 80a42ec:	4807      	ldr	r0, [pc, #28]	; (80a430c <_ZN8particle6detail14FutureImplBaseIbNS0_13FutureContextEE14invokeCallbackIFvRKbEIRbEEEvRSt6atomicIPSt8functionIT_EEDpOT0_+0xac>)
 80a42ee:	f7ff fbaf 	bl	80a3a50 <application_thread_invoke>
 80a42f2:	4630      	mov	r0, r6
 80a42f4:	f7fc f8ce 	bl	80a0494 <_ZNSt14_Function_baseD1Ev>
    template<typename FunctionT, typename... ArgsT>
    static void invokeCallback(std::atomic<std::function<FunctionT>*>& wrapper, ArgsT&&... args) {
        std::function<FunctionT>* callbackPtr = wrapper.exchange(nullptr, std::memory_order_acq_rel);
        if (callbackPtr) {
            invokeCallback(*callbackPtr, std::forward<ArgsT>(args)...);
            delete callbackPtr;
 80a42f8:	4630      	mov	r0, r6
 80a42fa:	f7fb fed2 	bl	80a00a2 <_ZdlPv>
        }
    }
 80a42fe:	b007      	add	sp, #28
 80a4300:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80a4302:	bf00      	nop
 80a4304:	080a3f6b 	.word	0x080a3f6b
 80a4308:	080a421d 	.word	0x080a421d
 80a430c:	080a3b7b 	.word	0x080a3b7b

080a4310 <_ZN12_GLOBAL__N_125publishCompletionCallbackEiPKvPvS2_>:
namespace {

using namespace particle;

#ifndef SPARK_NO_CLOUD
void publishCompletionCallback(int error, const void* data, void* callbackData, void* reserved) {
 80a4310:	b530      	push	{r4, r5, lr}
 80a4312:	4604      	mov	r4, r0
 80a4314:	b085      	sub	sp, #20
 80a4316:	460d      	mov	r5, r1
    auto p = Promise<bool>::fromDataPtr(callbackData);
 80a4318:	4668      	mov	r0, sp
 80a431a:	4611      	mov	r1, r2
 80a431c:	f7ff fddf 	bl	80a3ede <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE11fromDataPtrEPv>
    if (error != Error::NONE) {
 80a4320:	b17c      	cbz	r4, 80a4342 <_ZN12_GLOBAL__N_125publishCompletionCallbackEiPKvPvS2_+0x32>
        p.setError(Error((Error::Type)error, (const char*)data));
 80a4322:	b224      	sxth	r4, r4
        type_(type) {
}

inline particle::Error::Error(Type type, const char* msg) :
        msg_(msg ? (const char*)strdup(msg) : nullptr),
        type_(type) {
 80a4324:	4628      	mov	r0, r5
 80a4326:	b10d      	cbz	r5, 80a432c <_ZN12_GLOBAL__N_125publishCompletionCallbackEiPKvPvS2_+0x1c>
 80a4328:	f001 ffb8 	bl	80a629c <strdup>
 80a432c:	9002      	str	r0, [sp, #8]
 80a432e:	a902      	add	r1, sp, #8
 80a4330:	4668      	mov	r0, sp
 80a4332:	f8ad 400c 	strh.w	r4, [sp, #12]
 80a4336:	f7ff fe2f 	bl	80a3f98 <_ZN8particle11PromiseBaseIbNS_6detail13FutureContextEE8setErrorENS_5ErrorE>
        Error() {
    swap(*this, error);
}

inline particle::Error::~Error() {
    free((void*)msg_);
 80a433a:	9802      	ldr	r0, [sp, #8]
 80a433c:	f7ff fbac 	bl	80a3a98 <free>
 80a4340:	e01d      	b.n	80a437e <_ZN12_GLOBAL__N_125publishCompletionCallbackEiPKvPvS2_+0x6e>

      bool
      compare_exchange_strong(_Tp& __e, _Tp __i, memory_order __s, 
			      memory_order __f) noexcept
      {
	return __atomic_compare_exchange(&_M_i, &__e, &__i, false, __s, __f);
 80a4342:	f04f 0201 	mov.w	r2, #1
 80a4346:	9800      	ldr	r0, [sp, #0]
            onSuccess_(nullptr),
            onError_(nullptr) {
    }

    bool changeState(State state) {
        State s = State::RUNNING; // Expected state
 80a4348:	f88d 4008 	strb.w	r4, [sp, #8]
 80a434c:	e8d0 3f4f 	ldrexb	r3, [r0]
 80a4350:	42a3      	cmp	r3, r4
 80a4352:	d103      	bne.n	80a435c <_ZN12_GLOBAL__N_125publishCompletionCallbackEiPKvPvS2_+0x4c>
 80a4354:	e8c0 2f41 	strexb	r1, r2, [r0]
 80a4358:	2900      	cmp	r1, #0
 80a435a:	d1f7      	bne.n	80a434c <_ZN12_GLOBAL__N_125publishCompletionCallbackEiPKvPvS2_+0x3c>
 80a435c:	d002      	beq.n	80a4364 <_ZN12_GLOBAL__N_125publishCompletionCallbackEiPKvPvS2_+0x54>
 80a435e:	f88d 3008 	strb.w	r3, [sp, #8]
 80a4362:	e00c      	b.n	80a437e <_ZN12_GLOBAL__N_125publishCompletionCallbackEiPKvPvS2_+0x6e>
        }
    }

    void setResult(ResultT result) {
        if (this->changeState(State::SUCCEEDED)) {
            new(&result_) ResultT(std::move(result));
 80a4364:	f110 010c 	adds.w	r1, r0, #12
 80a4368:	f04f 0301 	mov.w	r3, #1
 80a436c:	bf18      	it	ne
 80a436e:	7303      	strbne	r3, [r0, #12]
        memory_order __b = __m & __memory_order_mask;
	__glibcxx_assert(__b != memory_order_acquire);
	__glibcxx_assert(__b != memory_order_acq_rel);
	__glibcxx_assert(__b != memory_order_consume);

	__atomic_store_n(&_M_i, __i, __m);
 80a4370:	f3bf 8f5f 	dmb	sy
            this->releaseDone();
            this->invokeCallback(this->onSuccess_, result_);
 80a4374:	3004      	adds	r0, #4
 80a4376:	f800 3c03 	strb.w	r3, [r0, #-3]
 80a437a:	f7ff ff71 	bl	80a4260 <_ZN8particle6detail14FutureImplBaseIbNS0_13FutureContextEE14invokeCallbackIFvRKbEIRbEEEvRSt6atomicIPSt8functionIT_EEDpOT0_>
 80a437e:	a801      	add	r0, sp, #4
 80a4380:	f7ff fbc2 	bl	80a3b08 <_ZNSt14__shared_countILN9__gnu_cxx12_Lock_policyE0EED1Ev>
    } else {
        p.setResult(true);
    }
}
 80a4384:	b005      	add	sp, #20
 80a4386:	bd30      	pop	{r4, r5, pc}

080a4388 <delay>:
    return (value - fromStart) * (toEnd - toStart) / (fromEnd - fromStart) + toStart;
}

void delay(unsigned long ms)
{
    system_delay_ms(ms, false);
 80a4388:	2100      	movs	r1, #0
 80a438a:	f7ff bb49 	b.w	80a3a20 <system_delay_ms>
	...

080a4390 <serialEventRun>:

/**
 * Provides background processing of serial data.
 */
void serialEventRun()
{
 80a4390:	b508      	push	{r3, lr}
    if (serialEvent && Serial.available()>0)
 80a4392:	4b14      	ldr	r3, [pc, #80]	; (80a43e4 <serialEventRun+0x54>)
 80a4394:	b133      	cbz	r3, 80a43a4 <serialEventRun+0x14>
 80a4396:	f7ff fc9d 	bl	80a3cd4 <_Z16_fetch_usbserialv>
 80a439a:	6803      	ldr	r3, [r0, #0]
 80a439c:	691b      	ldr	r3, [r3, #16]
 80a439e:	4798      	blx	r3
 80a43a0:	2800      	cmp	r0, #0
 80a43a2:	dc16      	bgt.n	80a43d2 <serialEventRun+0x42>
        serialEvent();

    if (serialEvent1 && Serial1.available()>0)
 80a43a4:	4b10      	ldr	r3, [pc, #64]	; (80a43e8 <serialEventRun+0x58>)
 80a43a6:	b133      	cbz	r3, 80a43b6 <serialEventRun+0x26>
 80a43a8:	f000 f9b0 	bl	80a470c <_Z22__fetch_global_Serial1v>
 80a43ac:	6803      	ldr	r3, [r0, #0]
 80a43ae:	691b      	ldr	r3, [r3, #16]
 80a43b0:	4798      	blx	r3
 80a43b2:	2800      	cmp	r0, #0
 80a43b4:	dc10      	bgt.n	80a43d8 <serialEventRun+0x48>
        serialEvent1();

#if Wiring_Serial2
    if (serialEventRun2) serialEventRun2();
 80a43b6:	4b0d      	ldr	r3, [pc, #52]	; (80a43ec <serialEventRun+0x5c>)
 80a43b8:	b10b      	cbz	r3, 80a43be <serialEventRun+0x2e>
 80a43ba:	f3af 8000 	nop.w
#if Wiring_Serial5
    if (serialEventRun5) serialEventRun5();
#endif

#if Wiring_USBSerial1
    if (usbSerialEvent1 && USBSerial1.available()>0)
 80a43be:	4b0c      	ldr	r3, [pc, #48]	; (80a43f0 <serialEventRun+0x60>)
 80a43c0:	b17b      	cbz	r3, 80a43e2 <serialEventRun+0x52>
 80a43c2:	f7ff fcc3 	bl	80a3d4c <_Z17_fetch_usbserial1v>
 80a43c6:	6803      	ldr	r3, [r0, #0]
 80a43c8:	691b      	ldr	r3, [r3, #16]
 80a43ca:	4798      	blx	r3
 80a43cc:	2800      	cmp	r0, #0
 80a43ce:	dc06      	bgt.n	80a43de <serialEventRun+0x4e>
 80a43d0:	bd08      	pop	{r3, pc}
 * Provides background processing of serial data.
 */
void serialEventRun()
{
    if (serialEvent && Serial.available()>0)
        serialEvent();
 80a43d2:	f3af 8000 	nop.w
 80a43d6:	e7e5      	b.n	80a43a4 <serialEventRun+0x14>

    if (serialEvent1 && Serial1.available()>0)
        serialEvent1();
 80a43d8:	f3af 8000 	nop.w
 80a43dc:	e7eb      	b.n	80a43b6 <serialEventRun+0x26>
    if (serialEventRun5) serialEventRun5();
#endif

#if Wiring_USBSerial1
    if (usbSerialEvent1 && USBSerial1.available()>0)
        usbSerialEvent1();
 80a43de:	f3af 8000 	nop.w
 80a43e2:	bd08      	pop	{r3, pc}
	...

080a43f4 <_post_loop>:
#if Wiring_Serial5
void serialEvent5() __attribute__((weak));
#endif

void _post_loop()
{
 80a43f4:	b508      	push	{r3, lr}
	serialEventRun();
 80a43f6:	f7ff ffcb 	bl	80a4390 <serialEventRun>
		return !timeout_fn;
	}

	static inline system_tick_t current_time()
	{
		return HAL_Timer_Get_Milli_Seconds();
 80a43fa:	f7ff fa71 	bl	80a38e0 <HAL_Timer_Get_Milli_Seconds>
	/**
	 * Lifesign that the application is still working normally.
	 */
	static void checkin()
	{
		last_checkin = current_time();
 80a43fe:	4b01      	ldr	r3, [pc, #4]	; (80a4404 <_post_loop+0x10>)
 80a4400:	6018      	str	r0, [r3, #0]
 80a4402:	bd08      	pop	{r3, pc}
 80a4404:	20000dcc 	.word	0x20000dcc

080a4408 <_Z33system_initialize_user_backup_ramv>:
 * the dynamically linked application module.
 */
void system_initialize_user_backup_ram()
{
    size_t len = &link_global_retained_end-&link_global_retained_start;
    memcpy(&link_global_retained_start, &link_global_retained_initial_values, len);
 80a4408:	4802      	ldr	r0, [pc, #8]	; (80a4414 <_Z33system_initialize_user_backup_ramv+0xc>)
 80a440a:	4a03      	ldr	r2, [pc, #12]	; (80a4418 <_Z33system_initialize_user_backup_ramv+0x10>)
 80a440c:	4903      	ldr	r1, [pc, #12]	; (80a441c <_Z33system_initialize_user_backup_ramv+0x14>)
 80a440e:	1a12      	subs	r2, r2, r0
 80a4410:	f001 bebc 	b.w	80a618c <memcpy>
 80a4414:	40024000 	.word	0x40024000
 80a4418:	40024004 	.word	0x40024004
 80a441c:	080a6dd0 	.word	0x080a6dd0

080a4420 <_Z27ctrl_request_custom_handlerP12ctrl_request>:
bool __backup_ram_was_valid() { return false; }

#endif

// Default handler for CTRL_REQUEST_APP_CUSTOM requests
void __attribute((weak)) ctrl_request_custom_handler(ctrl_request* req) {
 80a4420:	b507      	push	{r0, r1, r2, lr}
    system_ctrl_set_result(req, SYSTEM_ERROR_NOT_SUPPORTED, nullptr, nullptr, nullptr);
 80a4422:	2300      	movs	r3, #0
 80a4424:	9300      	str	r3, [sp, #0]
 80a4426:	461a      	mov	r2, r3
 80a4428:	f06f 0177 	mvn.w	r1, #119	; 0x77
 80a442c:	f7ff fb22 	bl	80a3a74 <system_ctrl_set_result>
}
 80a4430:	b003      	add	sp, #12
 80a4432:	f85d fb04 	ldr.w	pc, [sp], #4
	...

080a4438 <_ZL20ctrl_request_handlerP12ctrl_request>:
// Callback invoked to process a logging configuration request
void(*log_process_ctrl_request_callback)(ctrl_request* req) = nullptr;
#endif

// Application handler for control requests
static void ctrl_request_handler(ctrl_request* req) {
 80a4438:	b507      	push	{r0, r1, r2, lr}
    switch (req->type) {
 80a443a:	8843      	ldrh	r3, [r0, #2]
 80a443c:	2b0a      	cmp	r3, #10
 80a443e:	d008      	beq.n	80a4452 <_ZL20ctrl_request_handlerP12ctrl_request+0x1a>
 80a4440:	2b50      	cmp	r3, #80	; 0x50
 80a4442:	d109      	bne.n	80a4458 <_ZL20ctrl_request_handlerP12ctrl_request+0x20>
#if Wiring_LogConfig
    case CTRL_REQUEST_LOG_CONFIG: {
        if (log_process_ctrl_request_callback) {
 80a4444:	4b09      	ldr	r3, [pc, #36]	; (80a446c <_ZL20ctrl_request_handlerP12ctrl_request+0x34>)
 80a4446:	681b      	ldr	r3, [r3, #0]
 80a4448:	b13b      	cbz	r3, 80a445a <_ZL20ctrl_request_handlerP12ctrl_request+0x22>
    }
    default:
        system_ctrl_set_result(req, SYSTEM_ERROR_NOT_SUPPORTED, nullptr, nullptr, nullptr);
        break;
    }
}
 80a444a:	b003      	add	sp, #12
 80a444c:	f85d eb04 	ldr.w	lr, [sp], #4
static void ctrl_request_handler(ctrl_request* req) {
    switch (req->type) {
#if Wiring_LogConfig
    case CTRL_REQUEST_LOG_CONFIG: {
        if (log_process_ctrl_request_callback) {
            log_process_ctrl_request_callback(req);
 80a4450:	4718      	bx	r3
        }
        break;
    }
#endif
    case CTRL_REQUEST_APP_CUSTOM: {
        ctrl_request_custom_handler(req);
 80a4452:	f7ff ffe5 	bl	80a4420 <_Z27ctrl_request_custom_handlerP12ctrl_request>
        break;
 80a4456:	e006      	b.n	80a4466 <_ZL20ctrl_request_handlerP12ctrl_request+0x2e>
    }
    default:
        system_ctrl_set_result(req, SYSTEM_ERROR_NOT_SUPPORTED, nullptr, nullptr, nullptr);
 80a4458:	2300      	movs	r3, #0
 80a445a:	9300      	str	r3, [sp, #0]
 80a445c:	461a      	mov	r2, r3
 80a445e:	f06f 0177 	mvn.w	r1, #119	; 0x77
 80a4462:	f7ff fb07 	bl	80a3a74 <system_ctrl_set_result>
        break;
    }
}
 80a4466:	b003      	add	sp, #12
 80a4468:	f85d fb04 	ldr.w	pc, [sp], #4
 80a446c:	20000c48 	.word	0x20000c48

080a4470 <module_user_init_hook>:

void module_user_init_hook()
{
 80a4470:	b538      	push	{r3, r4, r5, lr}
#if PLATFORM_BACKUP_RAM
    backup_ram_was_valid_ =  __backup_sram_signature==signature;
 80a4472:	4c10      	ldr	r4, [pc, #64]	; (80a44b4 <module_user_init_hook+0x44>)
 80a4474:	4d10      	ldr	r5, [pc, #64]	; (80a44b8 <module_user_init_hook+0x48>)
 80a4476:	6823      	ldr	r3, [r4, #0]
 80a4478:	42ab      	cmp	r3, r5
 80a447a:	4b10      	ldr	r3, [pc, #64]	; (80a44bc <module_user_init_hook+0x4c>)
 80a447c:	bf0c      	ite	eq
 80a447e:	2201      	moveq	r2, #1
 80a4480:	2200      	movne	r2, #0
 80a4482:	701a      	strb	r2, [r3, #0]
    if (!backup_ram_was_valid_) {
 80a4484:	d002      	beq.n	80a448c <module_user_init_hook+0x1c>
        system_initialize_user_backup_ram();
 80a4486:	f7ff ffbf 	bl	80a4408 <_Z33system_initialize_user_backup_ramv>
        __backup_sram_signature = signature;
 80a448a:	6025      	str	r5, [r4, #0]
#endif

    // todo - add a RNG define for that capability
#if defined(STM32F2XX)
    // Initialize the default stdlib PRNG using hardware RNG as a seed
    srand(HAL_RNG_GetRandomNumber());
 80a448c:	f7ff fa08 	bl	80a38a0 <HAL_RNG_GetRandomNumber>
 80a4490:	f001 fe90 	bl	80a61b4 <srand>

    // If the user defines random_seed_from_cloud, call it with a seed value
    // generated by a hardware RNG as well.
    if (random_seed_from_cloud) {
 80a4494:	4b0a      	ldr	r3, [pc, #40]	; (80a44c0 <module_user_init_hook+0x50>)
 80a4496:	b11b      	cbz	r3, 80a44a0 <module_user_init_hook+0x30>
        uint32_t seed = HAL_RNG_GetRandomNumber();
 80a4498:	f7ff fa02 	bl	80a38a0 <HAL_RNG_GetRandomNumber>
        random_seed_from_cloud(seed);
 80a449c:	f3af 8000 	nop.w
    }
#endif
    // Register the random_seed_from_cloud handler
    spark_set_random_seed_from_cloud_handler(&random_seed_from_cloud, nullptr);
 80a44a0:	2100      	movs	r1, #0
 80a44a2:	4807      	ldr	r0, [pc, #28]	; (80a44c0 <module_user_init_hook+0x50>)
 80a44a4:	f7ff faa4 	bl	80a39f0 <spark_set_random_seed_from_cloud_handler>

    // Register application handler for the control requests
    system_ctrl_set_app_request_handler(ctrl_request_handler, nullptr);
}
 80a44a8:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
#endif
    // Register the random_seed_from_cloud handler
    spark_set_random_seed_from_cloud_handler(&random_seed_from_cloud, nullptr);

    // Register application handler for the control requests
    system_ctrl_set_app_request_handler(ctrl_request_handler, nullptr);
 80a44ac:	2100      	movs	r1, #0
 80a44ae:	4805      	ldr	r0, [pc, #20]	; (80a44c4 <module_user_init_hook+0x54>)
 80a44b0:	f7ff bad6 	b.w	80a3a60 <system_ctrl_set_app_request_handler>
 80a44b4:	40024000 	.word	0x40024000
 80a44b8:	9a271c1e 	.word	0x9a271c1e
 80a44bc:	20000c4c 	.word	0x20000c4c
 80a44c0:	00000000 	.word	0x00000000
 80a44c4:	080a4439 	.word	0x080a4439

080a44c8 <_ZN8RGBClassD1Ev>:
#include "rgbled.h"

typedef void (raw_rgb_change_handler_t)(uint8_t, uint8_t, uint8_t);
typedef std::function<raw_rgb_change_handler_t> wiring_rgb_change_handler_t;

class RGBClass {
 80a44c8:	b510      	push	{r4, lr}
 80a44ca:	4604      	mov	r4, r0
 80a44cc:	f7fb ffe2 	bl	80a0494 <_ZNSt14_Function_baseD1Ev>
 80a44d0:	4620      	mov	r0, r4
 80a44d2:	bd10      	pop	{r4, pc}

080a44d4 <_GLOBAL__sub_I_RGB>:
	{
	  _Base::_M_init_functor(__functor, std::__addressof(__f.get()));
	}
      };

    _Function_base() : _M_manager(nullptr) { }
 80a44d4:	4803      	ldr	r0, [pc, #12]	; (80a44e4 <_GLOBAL__sub_I_RGB+0x10>)
 80a44d6:	2300      	movs	r3, #0
 80a44d8:	6083      	str	r3, [r0, #8]
#include "spark_wiring_rgb.h"
#include "spark_wiring_interrupts.h"

#include "core_hal.h"

RGBClass RGB;
 80a44da:	4a03      	ldr	r2, [pc, #12]	; (80a44e8 <_GLOBAL__sub_I_RGB+0x14>)
 80a44dc:	4903      	ldr	r1, [pc, #12]	; (80a44ec <_GLOBAL__sub_I_RGB+0x18>)
 80a44de:	f000 be55 	b.w	80a518c <__aeabi_atexit>
 80a44e2:	bf00      	nop
 80a44e4:	20000c50 	.word	0x20000c50
 80a44e8:	20000380 	.word	0x20000380
 80a44ec:	080a44c9 	.word	0x080a44c9

080a44f0 <_ZN9TimeClass4zoneEf>:
	return HAL_RTC_Get_UnixTime()+time_zone_cache+dst_current_cache;
}

/* set the time zone (+/-) offset from GMT */
void TimeClass::zone(float GMT_Offset)
{
 80a44f0:	b510      	push	{r4, lr}
	if(GMT_Offset < -12 || GMT_Offset > 14)
 80a44f2:	4909      	ldr	r1, [pc, #36]	; (80a4518 <_ZN9TimeClass4zoneEf+0x28>)
	return HAL_RTC_Get_UnixTime()+time_zone_cache+dst_current_cache;
}

/* set the time zone (+/-) offset from GMT */
void TimeClass::zone(float GMT_Offset)
{
 80a44f4:	4604      	mov	r4, r0
	if(GMT_Offset < -12 || GMT_Offset > 14)
 80a44f6:	f001 fde9 	bl	80a60cc <__aeabi_fcmplt>
 80a44fa:	b960      	cbnz	r0, 80a4516 <_ZN9TimeClass4zoneEf+0x26>
 80a44fc:	4907      	ldr	r1, [pc, #28]	; (80a451c <_ZN9TimeClass4zoneEf+0x2c>)
 80a44fe:	4620      	mov	r0, r4
 80a4500:	f001 fe02 	bl	80a6108 <__aeabi_fcmpgt>
 80a4504:	b938      	cbnz	r0, 80a4516 <_ZN9TimeClass4zoneEf+0x26>
	{
		return;
	}
	time_zone_cache = GMT_Offset * 3600;
 80a4506:	4906      	ldr	r1, [pc, #24]	; (80a4520 <_ZN9TimeClass4zoneEf+0x30>)
 80a4508:	4620      	mov	r0, r4
 80a450a:	f001 fc41 	bl	80a5d90 <__aeabi_fmul>
 80a450e:	f001 fe05 	bl	80a611c <__aeabi_f2iz>
 80a4512:	4b04      	ldr	r3, [pc, #16]	; (80a4524 <_ZN9TimeClass4zoneEf+0x34>)
 80a4514:	6018      	str	r0, [r3, #0]
 80a4516:	bd10      	pop	{r4, pc}
 80a4518:	c1400000 	.word	0xc1400000
 80a451c:	41600000 	.word	0x41600000
 80a4520:	45610000 	.word	0x45610000
 80a4524:	20000c64 	.word	0x20000c64

080a4528 <_GLOBAL__sub_I_TIME_FORMAT_DEFAULT>:
            calendar_time_cache = Convert_UnixTime_To_CalendarTime(unix_time);
            unix_time_cache = unix_time;
    }
}

const char* TimeClass::format_spec = TIME_FORMAT_DEFAULT;
 80a4528:	4b02      	ldr	r3, [pc, #8]	; (80a4534 <_GLOBAL__sub_I_TIME_FORMAT_DEFAULT+0xc>)
 80a452a:	681a      	ldr	r2, [r3, #0]
 80a452c:	4b02      	ldr	r3, [pc, #8]	; (80a4538 <_GLOBAL__sub_I_TIME_FORMAT_DEFAULT+0x10>)
 80a452e:	601a      	str	r2, [r3, #0]
 80a4530:	4770      	bx	lr
 80a4532:	bf00      	nop
 80a4534:	20000314 	.word	0x20000314
 80a4538:	20000c60 	.word	0x20000c60

080a453c <_GLOBAL__sub_I__ZN5spark3LogE>:
    // This handler doesn't support direct logging
}

// spark::Logger
inline spark::Logger::Logger(const char *name) :
        name_(name) {
 80a453c:	4a01      	ldr	r2, [pc, #4]	; (80a4544 <_GLOBAL__sub_I__ZN5spark3LogE+0x8>)
 80a453e:	4b02      	ldr	r3, [pc, #8]	; (80a4548 <_GLOBAL__sub_I__ZN5spark3LogE+0xc>)
 80a4540:	601a      	str	r2, [r3, #0]
 80a4542:	4770      	bx	lr
 80a4544:	080a6ae9 	.word	0x080a6ae9
 80a4548:	20000c68 	.word	0x20000c68

080a454c <_ZN5Print5writeEPKhj>:

// Public Methods //////////////////////////////////////////////////////////////

/* default implementation: may be overridden */
size_t Print::write(const uint8_t *buffer, size_t size)
{
 80a454c:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80a454e:	4606      	mov	r6, r0
 80a4550:	460d      	mov	r5, r1
 80a4552:	188f      	adds	r7, r1, r2
  size_t n = 0;
 80a4554:	2400      	movs	r4, #0
  while (size--) {
 80a4556:	42bd      	cmp	r5, r7
 80a4558:	d00c      	beq.n	80a4574 <_ZN5Print5writeEPKhj+0x28>
     int chunk = write(*buffer++);
 80a455a:	6833      	ldr	r3, [r6, #0]
 80a455c:	f815 1b01 	ldrb.w	r1, [r5], #1
 80a4560:	689b      	ldr	r3, [r3, #8]
 80a4562:	4630      	mov	r0, r6
 80a4564:	4798      	blx	r3
     if (chunk>=0)
 80a4566:	2800      	cmp	r0, #0
 80a4568:	db01      	blt.n	80a456e <_ZN5Print5writeEPKhj+0x22>
         n += chunk;
 80a456a:	4404      	add	r4, r0

/* default implementation: may be overridden */
size_t Print::write(const uint8_t *buffer, size_t size)
{
  size_t n = 0;
  while (size--) {
 80a456c:	e7f3      	b.n	80a4556 <_ZN5Print5writeEPKhj+0xa>
     int chunk = write(*buffer++);
 80a456e:	2c00      	cmp	r4, #0
 80a4570:	bf08      	it	eq
 80a4572:	4604      	moveq	r4, r0
             n = chunk;
         break;
     }
  }
  return n;
}
 80a4574:	4620      	mov	r0, r4
 80a4576:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

080a4578 <_ZN5Print5writeEPKc>:

    int getWriteError() { return write_error; }
    void clearWriteError() { setWriteError(0); }

    virtual size_t write(uint8_t) = 0;
    size_t write(const char *str) {
 80a4578:	b570      	push	{r4, r5, r6, lr}
 80a457a:	4605      	mov	r5, r0
      if (str == NULL) return 0;
 80a457c:	460c      	mov	r4, r1
      return write((const uint8_t *)str, strlen(str));
    }
 80a457e:	4608      	mov	r0, r1
    int getWriteError() { return write_error; }
    void clearWriteError() { setWriteError(0); }

    virtual size_t write(uint8_t) = 0;
    size_t write(const char *str) {
      if (str == NULL) return 0;
 80a4580:	b149      	cbz	r1, 80a4596 <_ZN5Print5writeEPKc+0x1e>
      return write((const uint8_t *)str, strlen(str));
 80a4582:	f001 fea6 	bl	80a62d2 <strlen>
 80a4586:	682b      	ldr	r3, [r5, #0]
 80a4588:	4602      	mov	r2, r0
 80a458a:	4621      	mov	r1, r4
 80a458c:	4628      	mov	r0, r5
    }
 80a458e:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
    void clearWriteError() { setWriteError(0); }

    virtual size_t write(uint8_t) = 0;
    size_t write(const char *str) {
      if (str == NULL) return 0;
      return write((const uint8_t *)str, strlen(str));
 80a4592:	68db      	ldr	r3, [r3, #12]
 80a4594:	4718      	bx	r3
    }
 80a4596:	bd70      	pop	{r4, r5, r6, pc}

080a4598 <_ZN5Print5printEc>:
  return write(str);
}

size_t Print::print(char c)
{
  return write(c);
 80a4598:	6803      	ldr	r3, [r0, #0]
 80a459a:	689b      	ldr	r3, [r3, #8]
 80a459c:	4718      	bx	r3

080a459e <_ZN5Print7printlnEv>:
{
  return print(reinterpret_cast<const char*>(str));
}

size_t Print::println(void)
{
 80a459e:	b538      	push	{r3, r4, r5, lr}
  size_t n = print('\r');
 80a45a0:	210d      	movs	r1, #13
{
  return print(reinterpret_cast<const char*>(str));
}

size_t Print::println(void)
{
 80a45a2:	4605      	mov	r5, r0
  size_t n = print('\r');
 80a45a4:	f7ff fff8 	bl	80a4598 <_ZN5Print5printEc>
  n += print('\n');
 80a45a8:	210a      	movs	r1, #10
  return print(reinterpret_cast<const char*>(str));
}

size_t Print::println(void)
{
  size_t n = print('\r');
 80a45aa:	4604      	mov	r4, r0
  n += print('\n');
 80a45ac:	4628      	mov	r0, r5
 80a45ae:	f7ff fff3 	bl	80a4598 <_ZN5Print5printEc>
  return n;
}
 80a45b2:	4420      	add	r0, r4
 80a45b4:	bd38      	pop	{r3, r4, r5, pc}

080a45b6 <_ZN5Print11printNumberEmh>:
  char *str = &buf[sizeof(buf) - 1];

  *str = '\0';

  // prevent crash if called with base == 1
  if (base < 2) base = 10;
 80a45b6:	2a01      	cmp	r2, #1
 80a45b8:	bf98      	it	ls
 80a45ba:	220a      	movls	r2, #10
  return println(reinterpret_cast<const char*>(str));
}

// Private Methods /////////////////////////////////////////////////////////////

size_t Print::printNumber(unsigned long n, uint8_t base) {
 80a45bc:	b530      	push	{r4, r5, lr}
 80a45be:	460b      	mov	r3, r1
 80a45c0:	b08b      	sub	sp, #44	; 0x2c
  char buf[8 * sizeof(long) + 1]; // Assumes 8-bit chars plus zero byte.
  char *str = &buf[sizeof(buf) - 1];

  *str = '\0';
 80a45c2:	2100      	movs	r1, #0
 80a45c4:	f88d 1024 	strb.w	r1, [sp, #36]	; 0x24
 80a45c8:	f10d 0423 	add.w	r4, sp, #35	; 0x23
  // prevent crash if called with base == 1
  if (base < 2) base = 10;

  do {
    unsigned long m = n;
    n /= base;
 80a45cc:	fbb3 f5f2 	udiv	r5, r3, r2
    char c = m - base * n;
 80a45d0:	fb05 3312 	mls	r3, r5, r2, r3
 80a45d4:	b2db      	uxtb	r3, r3
    *--str = c < 10 ? c + '0' : c + 'A' - 10;
 80a45d6:	2b09      	cmp	r3, #9
 80a45d8:	bf94      	ite	ls
 80a45da:	3330      	addls	r3, #48	; 0x30
 80a45dc:	3337      	addhi	r3, #55	; 0x37
 80a45de:	b2db      	uxtb	r3, r3
 80a45e0:	4621      	mov	r1, r4
 80a45e2:	f804 3901 	strb.w	r3, [r4], #-1
 80a45e6:	462b      	mov	r3, r5
  *str = '\0';

  // prevent crash if called with base == 1
  if (base < 2) base = 10;

  do {
 80a45e8:	2d00      	cmp	r5, #0
 80a45ea:	d1ef      	bne.n	80a45cc <_ZN5Print11printNumberEmh+0x16>
    n /= base;
    char c = m - base * n;
    *--str = c < 10 ? c + '0' : c + 'A' - 10;
  } while(n);

  return write(str);
 80a45ec:	f7ff ffc4 	bl	80a4578 <_ZN5Print5writeEPKc>
}
 80a45f0:	b00b      	add	sp, #44	; 0x2c
 80a45f2:	bd30      	pop	{r4, r5, pc}

080a45f4 <_ZN5Print5printEmi>:
    return printNumber(n, base);
  }
}

size_t Print::print(unsigned long n, int base)
{
 80a45f4:	b410      	push	{r4}
  if (base == 0) return write(n);
 80a45f6:	b922      	cbnz	r2, 80a4602 <_ZN5Print5printEmi+0xe>
 80a45f8:	6803      	ldr	r3, [r0, #0]
 80a45fa:	b2c9      	uxtb	r1, r1
 80a45fc:	689b      	ldr	r3, [r3, #8]
  else return printNumber(n, base);
}
 80a45fe:	bc10      	pop	{r4}
  }
}

size_t Print::print(unsigned long n, int base)
{
  if (base == 0) return write(n);
 80a4600:	4718      	bx	r3
  else return printNumber(n, base);
 80a4602:	b2d2      	uxtb	r2, r2
}
 80a4604:	bc10      	pop	{r4}
}

size_t Print::print(unsigned long n, int base)
{
  if (base == 0) return write(n);
  else return printNumber(n, base);
 80a4606:	f7ff bfd6 	b.w	80a45b6 <_ZN5Print11printNumberEmh>

080a460a <_ZN5Print5printEhi>:
  return write(c);
}

size_t Print::print(unsigned char b, int base)
{
  return print((unsigned long) b, base);
 80a460a:	f7ff bff3 	b.w	80a45f4 <_ZN5Print5printEmi>

080a460e <_ZN5Print11printf_implEbPKcz>:

  return n;
}

size_t Print::printf_impl(bool newline, const char* format, ...)
{
 80a460e:	b40c      	push	{r2, r3}
 80a4610:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 80a4614:	b087      	sub	sp, #28
 80a4616:	af00      	add	r7, sp, #0
 80a4618:	f107 0438 	add.w	r4, r7, #56	; 0x38
 80a461c:	f854 9b04 	ldr.w	r9, [r4], #4
 80a4620:	4605      	mov	r5, r0
 80a4622:	460e      	mov	r6, r1
    const int bufsize = 20;
    char test[bufsize];
    va_list marker;
    va_start(marker, format);
    size_t n = vsnprintf(test, bufsize, format, marker);
 80a4624:	4623      	mov	r3, r4
 80a4626:	464a      	mov	r2, r9
 80a4628:	2114      	movs	r1, #20
 80a462a:	1d38      	adds	r0, r7, #4
size_t Print::printf_impl(bool newline, const char* format, ...)
{
    const int bufsize = 20;
    char test[bufsize];
    va_list marker;
    va_start(marker, format);
 80a462c:	603c      	str	r4, [r7, #0]
    size_t n = vsnprintf(test, bufsize, format, marker);
 80a462e:	f7ff fa43 	bl	80a3ab8 <vsnprintf>
    va_end(marker);

    if (n<bufsize)
 80a4632:	2813      	cmp	r0, #19
 80a4634:	d805      	bhi.n	80a4642 <_ZN5Print11printf_implEbPKcz+0x34>
  return n;
}

size_t Print::print(const char str[])
{
  return write(str);
 80a4636:	1d39      	adds	r1, r7, #4
 80a4638:	4628      	mov	r0, r5
 80a463a:	f7ff ff9d 	bl	80a4578 <_ZN5Print5writeEPKc>
 80a463e:	4604      	mov	r4, r0
 80a4640:	e013      	b.n	80a466a <_ZN5Print11printf_implEbPKcz+0x5c>
    {
        n = print(test);
    }
    else
    {
        char bigger[n+1];
 80a4642:	f100 0308 	add.w	r3, r0, #8
 80a4646:	f023 0307 	bic.w	r3, r3, #7
        va_start(marker, format);
        n = vsnprintf(bigger, n+1, format, marker);
        va_end(marker);
        n = print(bigger);
 80a464a:	46e8      	mov	r8, sp
    {
        n = print(test);
    }
    else
    {
        char bigger[n+1];
 80a464c:	ebad 0d03 	sub.w	sp, sp, r3
        va_start(marker, format);
        n = vsnprintf(bigger, n+1, format, marker);
 80a4650:	1c41      	adds	r1, r0, #1
 80a4652:	4623      	mov	r3, r4
 80a4654:	464a      	mov	r2, r9
 80a4656:	4668      	mov	r0, sp
        n = print(test);
    }
    else
    {
        char bigger[n+1];
        va_start(marker, format);
 80a4658:	603c      	str	r4, [r7, #0]
        n = vsnprintf(bigger, n+1, format, marker);
 80a465a:	f7ff fa2d 	bl	80a3ab8 <vsnprintf>
  return n;
}

size_t Print::print(const char str[])
{
  return write(str);
 80a465e:	4669      	mov	r1, sp
 80a4660:	4628      	mov	r0, r5
 80a4662:	f7ff ff89 	bl	80a4578 <_ZN5Print5writeEPKc>
 80a4666:	4604      	mov	r4, r0
 80a4668:	46c5      	mov	sp, r8
        va_start(marker, format);
        n = vsnprintf(bigger, n+1, format, marker);
        va_end(marker);
        n = print(bigger);
    }
    if (newline)
 80a466a:	b11e      	cbz	r6, 80a4674 <_ZN5Print11printf_implEbPKcz+0x66>
        n += println();
 80a466c:	4628      	mov	r0, r5
 80a466e:	f7ff ff96 	bl	80a459e <_ZN5Print7printlnEv>
 80a4672:	4404      	add	r4, r0
    return n;
}
 80a4674:	4620      	mov	r0, r4
 80a4676:	371c      	adds	r7, #28
 80a4678:	46bd      	mov	sp, r7
 80a467a:	e8bd 43f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, lr}
 80a467e:	b002      	add	sp, #8
 80a4680:	4770      	bx	lr

080a4682 <_ZN11USARTSerialD1Ev>:
private:
  HAL_USART_Serial _serial;
  bool _blocking;
public:
  USARTSerial(HAL_USART_Serial serial, Ring_Buffer *rx_buffer, Ring_Buffer *tx_buffer);
  virtual ~USARTSerial() {};
 80a4682:	4770      	bx	lr

080a4684 <_ZN11USARTSerial14blockOnOverrunEb>:
    HAL_USART_Half_Duplex(_serial, Enable);
}

void USARTSerial::blockOnOverrun(bool block)
{
  _blocking = block;
 80a4684:	7441      	strb	r1, [r0, #17]
 80a4686:	4770      	bx	lr

080a4688 <_ZN11USARTSerial17availableForWriteEv>:
}


int USARTSerial::availableForWrite(void)
{
  return HAL_USART_Available_Data_For_Write(_serial);
 80a4688:	7c00      	ldrb	r0, [r0, #16]
 80a468a:	f7ff b899 	b.w	80a37c0 <HAL_USART_Available_Data_For_Write>

080a468e <_ZN11USARTSerial9availableEv>:
}

int USARTSerial::available(void)
{
  return HAL_USART_Available_Data(_serial);
 80a468e:	7c00      	ldrb	r0, [r0, #16]
 80a4690:	f7ff b86e 	b.w	80a3770 <HAL_USART_Available_Data>

080a4694 <_ZN11USARTSerial4peekEv>:
}

int USARTSerial::peek(void)
{
  return HAL_USART_Peek_Data(_serial);
 80a4694:	7c00      	ldrb	r0, [r0, #16]
 80a4696:	f7ff b87b 	b.w	80a3790 <HAL_USART_Peek_Data>

080a469a <_ZN11USARTSerial4readEv>:
}

int USARTSerial::read(void)
{
  return HAL_USART_Read_Data(_serial);
 80a469a:	7c00      	ldrb	r0, [r0, #16]
 80a469c:	f7ff b870 	b.w	80a3780 <HAL_USART_Read_Data>

080a46a0 <_ZN11USARTSerial5flushEv>:
}

void USARTSerial::flush()
{
  HAL_USART_Flush_Data(_serial);
 80a46a0:	7c00      	ldrb	r0, [r0, #16]
 80a46a2:	f7ff b87d 	b.w	80a37a0 <HAL_USART_Flush_Data>

080a46a6 <_ZN11USARTSerialD0Ev>:
 80a46a6:	b510      	push	{r4, lr}
 80a46a8:	4604      	mov	r4, r0
 80a46aa:	f7fb fcfa 	bl	80a00a2 <_ZdlPv>
 80a46ae:	4620      	mov	r0, r4
 80a46b0:	bd10      	pop	{r4, pc}

080a46b2 <_ZN11USARTSerial5writeEh>:
}

size_t USARTSerial::write(uint8_t c)
{
 80a46b2:	b570      	push	{r4, r5, r6, lr}
  // attempt a write if blocking, or for non-blocking if there is room.
  if (_blocking || HAL_USART_Available_Data_For_Write(_serial) > 0) {
 80a46b4:	7c45      	ldrb	r5, [r0, #17]
{
  HAL_USART_Flush_Data(_serial);
}

size_t USARTSerial::write(uint8_t c)
{
 80a46b6:	4604      	mov	r4, r0
 80a46b8:	460e      	mov	r6, r1
  // attempt a write if blocking, or for non-blocking if there is room.
  if (_blocking || HAL_USART_Available_Data_For_Write(_serial) > 0) {
 80a46ba:	b925      	cbnz	r5, 80a46c6 <_ZN11USARTSerial5writeEh+0x14>
 80a46bc:	7c00      	ldrb	r0, [r0, #16]
 80a46be:	f7ff f87f 	bl	80a37c0 <HAL_USART_Available_Data_For_Write>
 80a46c2:	2800      	cmp	r0, #0
 80a46c4:	dd05      	ble.n	80a46d2 <_ZN11USARTSerial5writeEh+0x20>
    // the HAL always blocks.
	  return HAL_USART_Write_Data(_serial, c);
 80a46c6:	4631      	mov	r1, r6
 80a46c8:	7c20      	ldrb	r0, [r4, #16]
  }
  return 0;
}
 80a46ca:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
size_t USARTSerial::write(uint8_t c)
{
  // attempt a write if blocking, or for non-blocking if there is room.
  if (_blocking || HAL_USART_Available_Data_For_Write(_serial) > 0) {
    // the HAL always blocks.
	  return HAL_USART_Write_Data(_serial, c);
 80a46ce:	f7ff b847 	b.w	80a3760 <HAL_USART_Write_Data>
  }
  return 0;
}
 80a46d2:	4628      	mov	r0, r5
 80a46d4:	bd70      	pop	{r4, r5, r6, pc}
	...

080a46d8 <_ZN11USARTSerialC1E16HAL_USART_SerialP11Ring_BufferS2_>:
#include "spark_wiring_constants.h"
#include "module_info.h"

// Constructors ////////////////////////////////////////////////////////////////

USARTSerial::USARTSerial(HAL_USART_Serial serial, Ring_Buffer *rx_buffer, Ring_Buffer *tx_buffer)
 80a46d8:	b510      	push	{r4, lr}
 80a46da:	4604      	mov	r4, r0
 80a46dc:	4608      	mov	r0, r1
 80a46de:	4611      	mov	r1, r2
  protected:
    void setWriteError(int err = 1) { write_error = err; }
    size_t printf_impl(bool newline, const char* format, ...);

  public:
    Print() : write_error(0) {}
 80a46e0:	2200      	movs	r2, #0
 80a46e2:	6062      	str	r2, [r4, #4]
 80a46e4:	f44f 727a 	mov.w	r2, #1000	; 0x3e8
 80a46e8:	60a2      	str	r2, [r4, #8]
 80a46ea:	4a05      	ldr	r2, [pc, #20]	; (80a4700 <_ZN11USARTSerialC1E16HAL_USART_SerialP11Ring_BufferS2_+0x28>)
{
  _serial = serial;
 80a46ec:	7420      	strb	r0, [r4, #16]
#include "spark_wiring_constants.h"
#include "module_info.h"

// Constructors ////////////////////////////////////////////////////////////////

USARTSerial::USARTSerial(HAL_USART_Serial serial, Ring_Buffer *rx_buffer, Ring_Buffer *tx_buffer)
 80a46ee:	6022      	str	r2, [r4, #0]
{
  _serial = serial;
  // Default is blocking mode
  _blocking = true;
 80a46f0:	2201      	movs	r2, #1
 80a46f2:	7462      	strb	r2, [r4, #17]
  HAL_USART_Init(serial, rx_buffer, tx_buffer);
 80a46f4:	461a      	mov	r2, r3
 80a46f6:	f7ff f82b 	bl	80a3750 <HAL_USART_Init>
}
 80a46fa:	4620      	mov	r0, r4
 80a46fc:	bd10      	pop	{r4, pc}
 80a46fe:	bf00      	nop
 80a4700:	080a6b1c 	.word	0x080a6b1c

080a4704 <_ZN11USARTSerial9isEnabledEv>:
USARTSerial::operator bool() {
  return true;
}

bool USARTSerial::isEnabled() {
  return HAL_USART_Is_Enabled(_serial);
 80a4704:	7c00      	ldrb	r0, [r0, #16]
 80a4706:	f7ff b853 	b.w	80a37b0 <HAL_USART_Is_Enabled>
	...

080a470c <_Z22__fetch_global_Serial1v>:
static Ring_Buffer* serial1_rx_buffer = NULL;
static Ring_Buffer* serial1_tx_buffer = NULL;
#endif

USARTSerial& __fetch_global_Serial1()
{
 80a470c:	b538      	push	{r3, r4, r5, lr}
#if ((MODULE_FUNCTION == MOD_FUNC_USER_PART) || (MODULE_FUNCTION == MOD_FUNC_MONO_FIRMWARE))
	static USARTSerial serial1(HAL_USART_SERIAL1, &serial1_rx_buffer, &serial1_tx_buffer);
 80a470e:	4d0c      	ldr	r5, [pc, #48]	; (80a4740 <_Z22__fetch_global_Serial1v+0x34>)
 80a4710:	6829      	ldr	r1, [r5, #0]
 80a4712:	f011 0401 	ands.w	r4, r1, #1
 80a4716:	d111      	bne.n	80a473c <_Z22__fetch_global_Serial1v+0x30>
 80a4718:	4628      	mov	r0, r5
 80a471a:	f7fb fcc6 	bl	80a00aa <__cxa_guard_acquire>
 80a471e:	b168      	cbz	r0, 80a473c <_Z22__fetch_global_Serial1v+0x30>
 80a4720:	4a08      	ldr	r2, [pc, #32]	; (80a4744 <_Z22__fetch_global_Serial1v+0x38>)
 80a4722:	4621      	mov	r1, r4
 80a4724:	4b08      	ldr	r3, [pc, #32]	; (80a4748 <_Z22__fetch_global_Serial1v+0x3c>)
 80a4726:	4809      	ldr	r0, [pc, #36]	; (80a474c <_Z22__fetch_global_Serial1v+0x40>)
 80a4728:	f7ff ffd6 	bl	80a46d8 <_ZN11USARTSerialC1E16HAL_USART_SerialP11Ring_BufferS2_>
 80a472c:	4628      	mov	r0, r5
 80a472e:	f7fb fcc1 	bl	80a00b4 <__cxa_guard_release>
 80a4732:	4a07      	ldr	r2, [pc, #28]	; (80a4750 <_Z22__fetch_global_Serial1v+0x44>)
 80a4734:	4907      	ldr	r1, [pc, #28]	; (80a4754 <_Z22__fetch_global_Serial1v+0x48>)
 80a4736:	4805      	ldr	r0, [pc, #20]	; (80a474c <_Z22__fetch_global_Serial1v+0x40>)
 80a4738:	f000 fd28 	bl	80a518c <__aeabi_atexit>
    serial1_tx_buffer = new Ring_Buffer();
  }
  static USARTSerial serial1(HAL_USART_SERIAL1, serial1_rx_buffer, serial1_tx_buffer);
#endif
	return serial1;
}
 80a473c:	4803      	ldr	r0, [pc, #12]	; (80a474c <_Z22__fetch_global_Serial1v+0x40>)
 80a473e:	bd38      	pop	{r3, r4, r5, pc}
 80a4740:	20000d04 	.word	0x20000d04
 80a4744:	20000d08 	.word	0x20000d08
 80a4748:	20000c80 	.word	0x20000c80
 80a474c:	20000c6c 	.word	0x20000c6c
 80a4750:	20000380 	.word	0x20000380
 80a4754:	080a4683 	.word	0x080a4683

080a4758 <_ZN9TCPClient5writeEh>:
        }
        return connected;
}

size_t TCPClient::write(uint8_t b)
{
 80a4758:	b537      	push	{r0, r1, r2, r4, r5, lr}
 80a475a:	ac02      	add	r4, sp, #8
    return write(&b, 1, SPARK_WIRING_TCPCLIENT_DEFAULT_SEND_TIMEOUT);
 80a475c:	6803      	ldr	r3, [r0, #0]
        }
        return connected;
}

size_t TCPClient::write(uint8_t b)
{
 80a475e:	f804 1d01 	strb.w	r1, [r4, #-1]!
    return write(&b, 1, SPARK_WIRING_TCPCLIENT_DEFAULT_SEND_TIMEOUT);
 80a4762:	6bdd      	ldr	r5, [r3, #60]	; 0x3c
 80a4764:	2201      	movs	r2, #1
 80a4766:	f247 5330 	movw	r3, #30000	; 0x7530
 80a476a:	4621      	mov	r1, r4
 80a476c:	47a8      	blx	r5
}
 80a476e:	b003      	add	sp, #12
 80a4770:	bd30      	pop	{r4, r5, pc}

080a4772 <_ZN9TCPClient5writeEPKhj>:

size_t TCPClient::write(const uint8_t *buffer, size_t size)
{
 80a4772:	b410      	push	{r4}
    return write(buffer, size, SPARK_WIRING_TCPCLIENT_DEFAULT_SEND_TIMEOUT);
 80a4774:	6803      	ldr	r3, [r0, #0]
 80a4776:	6bdc      	ldr	r4, [r3, #60]	; 0x3c
 80a4778:	f247 5330 	movw	r3, #30000	; 0x7530
 80a477c:	46a4      	mov	ip, r4
}
 80a477e:	bc10      	pop	{r4}
    return write(&b, 1, SPARK_WIRING_TCPCLIENT_DEFAULT_SEND_TIMEOUT);
}

size_t TCPClient::write(const uint8_t *buffer, size_t size)
{
    return write(buffer, size, SPARK_WIRING_TCPCLIENT_DEFAULT_SEND_TIMEOUT);
 80a4780:	4760      	bx	ip

080a4782 <_ZN9TCPClient5writeEhm>:
}

size_t TCPClient::write(uint8_t b, system_tick_t timeout)
{
 80a4782:	b537      	push	{r0, r1, r2, r4, r5, lr}
 80a4784:	ac02      	add	r4, sp, #8
    return write(&b, 1, timeout);
 80a4786:	6803      	ldr	r3, [r0, #0]
{
    return write(buffer, size, SPARK_WIRING_TCPCLIENT_DEFAULT_SEND_TIMEOUT);
}

size_t TCPClient::write(uint8_t b, system_tick_t timeout)
{
 80a4788:	f804 1d01 	strb.w	r1, [r4, #-1]!
    return write(&b, 1, timeout);
 80a478c:	6bdd      	ldr	r5, [r3, #60]	; 0x3c
 80a478e:	4621      	mov	r1, r4
 80a4790:	4613      	mov	r3, r2
 80a4792:	2201      	movs	r2, #1
 80a4794:	47a8      	blx	r5
}
 80a4796:	b003      	add	sp, #12
 80a4798:	bd30      	pop	{r4, r5, pc}

080a479a <_ZN9TCPClient5flushEv>:
  d_->offset = 0;
  d_->total = 0;
}

void TCPClient::flush()
{
 80a479a:	4770      	bx	lr

080a479c <_ZNSt19_Sp_counted_deleterIPN9TCPClient4DataENSt12__shared_ptrIS1_LN9__gnu_cxx12_Lock_policyE0EE8_DeleterISaIS1_EEES8_LS5_0EED1Ev>:

      // __d(__p) must not throw.
      _Sp_counted_deleter(_Ptr __p, _Deleter __d, const _Alloc& __a) noexcept
      : _M_impl(__p, __d, __a) { }

      ~_Sp_counted_deleter() noexcept { }
 80a479c:	4770      	bx	lr

080a479e <_ZNSt19_Sp_counted_deleterIPN9TCPClient4DataENSt12__shared_ptrIS1_LN9__gnu_cxx12_Lock_policyE0EE8_DeleterISaIS1_EEES8_LS5_0EE14_M_get_deleterERKSt9type_info>:
	  ? std::__addressof(_M_impl._M_del())
	  : nullptr;
#else
        return nullptr;
#endif
      }
 80a479e:	2000      	movs	r0, #0
 80a47a0:	4770      	bx	lr

080a47a2 <_ZNSt19_Sp_counted_deleterIPN9TCPClient4DataENSt12__shared_ptrIS1_LN9__gnu_cxx12_Lock_policyE0EE8_DeleterISaIS1_EEES8_LS5_0EED0Ev>:

      // __d(__p) must not throw.
      _Sp_counted_deleter(_Ptr __p, _Deleter __d, const _Alloc& __a) noexcept
      : _M_impl(__p, __d, __a) { }

      ~_Sp_counted_deleter() noexcept { }
 80a47a2:	b510      	push	{r4, lr}
 80a47a4:	4604      	mov	r4, r0
 80a47a6:	f7fb fc7c 	bl	80a00a2 <_ZdlPv>
 80a47aa:	4620      	mov	r0, r4
 80a47ac:	bd10      	pop	{r4, pc}

080a47ae <_ZNSt19_Sp_counted_deleterIPN9TCPClient4DataENSt12__shared_ptrIS1_LN9__gnu_cxx12_Lock_policyE0EE8_DeleterISaIS1_EEES8_LS5_0EE10_M_destroyEv>:
      }

      // __p is not permitted to be a null pointer.
      void
      deallocate(pointer __p, size_type)
      { ::operator delete(__p); }
 80a47ae:	f7fb bc78 	b.w	80a00a2 <_ZdlPv>
	...

080a47b4 <_ZN9TCPClient7connectEPKctm>:
{
  flush_buffer();
}

int TCPClient::connect(const char* host, uint16_t port, network_interface_t nif)
{
 80a47b4:	e92d 43f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, lr}
 80a47b8:	461f      	mov	r7, r3
    stop();
 80a47ba:	6803      	ldr	r3, [r0, #0]
{
  flush_buffer();
}

int TCPClient::connect(const char* host, uint16_t port, network_interface_t nif)
{
 80a47bc:	b08f      	sub	sp, #60	; 0x3c
    stop();
 80a47be:	6adb      	ldr	r3, [r3, #44]	; 0x2c
{
  flush_buffer();
}

int TCPClient::connect(const char* host, uint16_t port, network_interface_t nif)
{
 80a47c0:	4606      	mov	r6, r0
 80a47c2:	460c      	mov	r4, r1
 80a47c4:	4690      	mov	r8, r2
    stop();
 80a47c6:	4798      	blx	r3
      int rv = 0;
      if(Network.ready())
 80a47c8:	4b13      	ldr	r3, [pc, #76]	; (80a4818 <_ZN9TCPClient7connectEPKctm+0x64>)
 80a47ca:	6818      	ldr	r0, [r3, #0]
 80a47cc:	6803      	ldr	r3, [r0, #0]
 80a47ce:	681b      	ldr	r3, [r3, #0]
 80a47d0:	4798      	blx	r3
 80a47d2:	b1f0      	cbz	r0, 80a4812 <_ZN9TCPClient7connectEPKctm+0x5e>
      {
        IPAddress ip_addr;
 80a47d4:	a802      	add	r0, sp, #8
 80a47d6:	f7ff faff 	bl	80a3dd8 <_ZN9IPAddressC1Ev>

        if((rv = inet_gethostbyname(host, strlen(host), ip_addr, nif, NULL)) == 0)
 80a47da:	4620      	mov	r0, r4
 80a47dc:	f001 fd79 	bl	80a62d2 <strlen>
 80a47e0:	2300      	movs	r3, #0
 80a47e2:	9300      	str	r3, [sp, #0]
 80a47e4:	b281      	uxth	r1, r0
 80a47e6:	463b      	mov	r3, r7
 80a47e8:	aa03      	add	r2, sp, #12
 80a47ea:	4620      	mov	r0, r4
 80a47ec:	f7fe fef6 	bl	80a35dc <inet_gethostbyname>
 80a47f0:	b978      	cbnz	r0, 80a4812 <_ZN9TCPClient7connectEPKctm+0x5e>
        {
                return connect(ip_addr, port, nif);
 80a47f2:	6833      	ldr	r3, [r6, #0]

/**
 * The IP address stored in host order.
 *
 */
class IPAddress : public Printable {
 80a47f4:	ad09      	add	r5, sp, #36	; 0x24
 80a47f6:	f8d3 9020 	ldr.w	r9, [r3, #32]
 80a47fa:	4b08      	ldr	r3, [pc, #32]	; (80a481c <_ZN9TCPClient7connectEPKctm+0x68>)
 80a47fc:	ac03      	add	r4, sp, #12
 80a47fe:	9308      	str	r3, [sp, #32]
 80a4800:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 80a4802:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 80a4804:	6823      	ldr	r3, [r4, #0]
 80a4806:	4642      	mov	r2, r8
 80a4808:	702b      	strb	r3, [r5, #0]
 80a480a:	a908      	add	r1, sp, #32
 80a480c:	463b      	mov	r3, r7
 80a480e:	4630      	mov	r0, r6
 80a4810:	47c8      	blx	r9
        }
        else
            DEBUG("unable to get IP for hostname");
      }
      return rv;
}
 80a4812:	b00f      	add	sp, #60	; 0x3c
 80a4814:	e8bd 83f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, pc}
 80a4818:	080a697c 	.word	0x080a697c
 80a481c:	080a69e0 	.word	0x080a69e0

080a4820 <_ZNSt16_Sp_counted_baseILN9__gnu_cxx12_Lock_policyE0EE10_M_releaseEv.part.2.constprop.30>:
    _Sp_counted_base<_S_single>::_M_add_ref_copy()
    { ++_M_use_count; }

  template<>
    inline void
    _Sp_counted_base<_S_single>::_M_release() noexcept
 80a4820:	b510      	push	{r4, lr}
 80a4822:	4604      	mov	r4, r0
    {
      if (--_M_use_count == 0)
        {
          _M_dispose();
 80a4824:	6803      	ldr	r3, [r0, #0]
 80a4826:	689b      	ldr	r3, [r3, #8]
 80a4828:	4798      	blx	r3
          if (--_M_weak_count == 0)
 80a482a:	68a3      	ldr	r3, [r4, #8]
 80a482c:	3b01      	subs	r3, #1
 80a482e:	60a3      	str	r3, [r4, #8]
 80a4830:	b92b      	cbnz	r3, 80a483e <_ZNSt16_Sp_counted_baseILN9__gnu_cxx12_Lock_policyE0EE10_M_releaseEv.part.2.constprop.30+0x1e>
            _M_destroy();
 80a4832:	6823      	ldr	r3, [r4, #0]
 80a4834:	4620      	mov	r0, r4
        }
    }
 80a4836:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
    {
      if (--_M_use_count == 0)
        {
          _M_dispose();
          if (--_M_weak_count == 0)
            _M_destroy();
 80a483a:	68db      	ldr	r3, [r3, #12]
 80a483c:	4718      	bx	r3
 80a483e:	bd10      	pop	{r4, pc}

080a4840 <_ZN9TCPClient8remoteIPEv>:
{
   return (status()!=0);
}

IPAddress TCPClient::remoteIP()
{
 80a4840:	b570      	push	{r4, r5, r6, lr}
 80a4842:	4604      	mov	r4, r0
 80a4844:	4606      	mov	r6, r0
 80a4846:	694d      	ldr	r5, [r1, #20]
 80a4848:	4b04      	ldr	r3, [pc, #16]	; (80a485c <_ZN9TCPClient8remoteIPEv+0x1c>)
 80a484a:	358c      	adds	r5, #140	; 0x8c
 80a484c:	f844 3b04 	str.w	r3, [r4], #4
 80a4850:	cd0f      	ldmia	r5!, {r0, r1, r2, r3}
 80a4852:	c40f      	stmia	r4!, {r0, r1, r2, r3}
 80a4854:	682b      	ldr	r3, [r5, #0]
    return d_->remoteIP;
}
 80a4856:	4630      	mov	r0, r6
 80a4858:	7023      	strb	r3, [r4, #0]
 80a485a:	bd70      	pop	{r4, r5, r6, pc}
 80a485c:	080a69e0 	.word	0x080a69e0

080a4860 <_ZN9TCPClient4peekEv>:
        }
        return read;
}

int TCPClient::peek()
{
 80a4860:	b510      	push	{r4, lr}
 80a4862:	6943      	ldr	r3, [r0, #20]
 80a4864:	4604      	mov	r4, r0
  return  (bufferCount() || available()) ? d_->buffer[d_->offset] : -1;
 80a4866:	f8b3 2086 	ldrh.w	r2, [r3, #134]	; 0x86
 80a486a:	f8b3 3084 	ldrh.w	r3, [r3, #132]	; 0x84
 80a486e:	429a      	cmp	r2, r3
 80a4870:	d005      	beq.n	80a487e <_ZN9TCPClient4peekEv+0x1e>
 80a4872:	6962      	ldr	r2, [r4, #20]
 80a4874:	f8b2 3084 	ldrh.w	r3, [r2, #132]	; 0x84
 80a4878:	4413      	add	r3, r2
 80a487a:	7918      	ldrb	r0, [r3, #4]
 80a487c:	bd10      	pop	{r4, pc}
 80a487e:	6803      	ldr	r3, [r0, #0]
 80a4880:	691b      	ldr	r3, [r3, #16]
 80a4882:	4798      	blx	r3
 80a4884:	2800      	cmp	r0, #0
 80a4886:	d1f4      	bne.n	80a4872 <_ZN9TCPClient4peekEv+0x12>
 80a4888:	f04f 30ff 	mov.w	r0, #4294967295
}
 80a488c:	bd10      	pop	{r4, pc}

080a488e <_ZN9TCPClient4readEv>:
    avail = bufferCount();
    return avail;
}

int TCPClient::read()
{
 80a488e:	b510      	push	{r4, lr}
 80a4890:	6943      	ldr	r3, [r0, #20]
 80a4892:	4604      	mov	r4, r0
  return (bufferCount() || available()) ? d_->buffer[d_->offset++] : -1;
 80a4894:	f8b3 2086 	ldrh.w	r2, [r3, #134]	; 0x86
 80a4898:	f8b3 3084 	ldrh.w	r3, [r3, #132]	; 0x84
 80a489c:	429a      	cmp	r2, r3
 80a489e:	d008      	beq.n	80a48b2 <_ZN9TCPClient4readEv+0x24>
 80a48a0:	6962      	ldr	r2, [r4, #20]
 80a48a2:	f8b2 3084 	ldrh.w	r3, [r2, #132]	; 0x84
 80a48a6:	1c59      	adds	r1, r3, #1
 80a48a8:	f8a2 1084 	strh.w	r1, [r2, #132]	; 0x84
 80a48ac:	4413      	add	r3, r2
 80a48ae:	7918      	ldrb	r0, [r3, #4]
 80a48b0:	bd10      	pop	{r4, pc}
 80a48b2:	6803      	ldr	r3, [r0, #0]
 80a48b4:	691b      	ldr	r3, [r3, #16]
 80a48b6:	4798      	blx	r3
 80a48b8:	2800      	cmp	r0, #0
 80a48ba:	d1f1      	bne.n	80a48a0 <_ZN9TCPClient4readEv+0x12>
 80a48bc:	f04f 30ff 	mov.w	r0, #4294967295
}
 80a48c0:	bd10      	pop	{r4, pc}

080a48c2 <_ZNSt19_Sp_counted_deleterIPN9TCPClient4DataENSt12__shared_ptrIS1_LN9__gnu_cxx12_Lock_policyE0EE8_DeleterISaIS1_EEES8_LS5_0EE10_M_disposeEv>:
      : _M_impl(__p, __d, __a) { }

      ~_Sp_counted_deleter() noexcept { }

      virtual void
      _M_dispose() noexcept
 80a48c2:	b510      	push	{r4, lr}
      { _M_impl._M_del()(_M_impl._M_ptr); }
 80a48c4:	6904      	ldr	r4, [r0, #16]
                offset(0),
                total(0) {
        }

        ~Data() {
            if (socket_handle_valid(sock)) {
 80a48c6:	6820      	ldr	r0, [r4, #0]
 80a48c8:	f7fe fed0 	bl	80a366c <socket_handle_valid>
 80a48cc:	b110      	cbz	r0, 80a48d4 <_ZNSt19_Sp_counted_deleterIPN9TCPClient4DataENSt12__shared_ptrIS1_LN9__gnu_cxx12_Lock_policyE0EE8_DeleterISaIS1_EEES8_LS5_0EE10_M_disposeEv+0x12>
                socket_close(sock);
 80a48ce:	6820      	ldr	r0, [r4, #0]
 80a48d0:	f7fe feec 	bl	80a36ac <socket_close>
 80a48d4:	4620      	mov	r0, r4
 80a48d6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 80a48da:	f7fb bbe2 	b.w	80a00a2 <_ZdlPv>

080a48de <_ZN9TCPClient4readEPhj>:

int TCPClient::read(uint8_t *buffer, size_t size)
{
 80a48de:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80a48e0:	6943      	ldr	r3, [r0, #20]
 80a48e2:	4617      	mov	r7, r2
        int read = -1;
        if (bufferCount() || available())
 80a48e4:	f8b3 2086 	ldrh.w	r2, [r3, #134]	; 0x86
 80a48e8:	f8b3 3084 	ldrh.w	r3, [r3, #132]	; 0x84
{
  return (bufferCount() || available()) ? d_->buffer[d_->offset++] : -1;
}

int TCPClient::read(uint8_t *buffer, size_t size)
{
 80a48ec:	4605      	mov	r5, r0
        int read = -1;
        if (bufferCount() || available())
 80a48ee:	429a      	cmp	r2, r3
{
  return (bufferCount() || available()) ? d_->buffer[d_->offset++] : -1;
}

int TCPClient::read(uint8_t *buffer, size_t size)
{
 80a48f0:	460e      	mov	r6, r1
        int read = -1;
        if (bufferCount() || available())
 80a48f2:	d106      	bne.n	80a4902 <_ZN9TCPClient4readEPhj+0x24>
 80a48f4:	6803      	ldr	r3, [r0, #0]
 80a48f6:	691b      	ldr	r3, [r3, #16]
 80a48f8:	4798      	blx	r3
 80a48fa:	b910      	cbnz	r0, 80a4902 <_ZN9TCPClient4readEPhj+0x24>
  return (bufferCount() || available()) ? d_->buffer[d_->offset++] : -1;
}

int TCPClient::read(uint8_t *buffer, size_t size)
{
        int read = -1;
 80a48fc:	f04f 34ff 	mov.w	r4, #4294967295
 80a4900:	e014      	b.n	80a492c <_ZN9TCPClient4readEPhj+0x4e>
 80a4902:	6969      	ldr	r1, [r5, #20]
        if (bufferCount() || available())
        {
          read = (size > (size_t) bufferCount()) ? bufferCount() : size;
          memcpy(buffer, &d_->buffer[d_->offset], read);
 80a4904:	4630      	mov	r0, r6
    return ret;
}

int TCPClient::bufferCount()
{
  return d_->total - d_->offset;
 80a4906:	f8b1 3084 	ldrh.w	r3, [r1, #132]	; 0x84
 80a490a:	f8b1 4086 	ldrh.w	r4, [r1, #134]	; 0x86
{
        int read = -1;
        if (bufferCount() || available())
        {
          read = (size > (size_t) bufferCount()) ? bufferCount() : size;
          memcpy(buffer, &d_->buffer[d_->offset], read);
 80a490e:	4419      	add	r1, r3
    return ret;
}

int TCPClient::bufferCount()
{
  return d_->total - d_->offset;
 80a4910:	1ae4      	subs	r4, r4, r3
int TCPClient::read(uint8_t *buffer, size_t size)
{
        int read = -1;
        if (bufferCount() || available())
        {
          read = (size > (size_t) bufferCount()) ? bufferCount() : size;
 80a4912:	42bc      	cmp	r4, r7
 80a4914:	bf28      	it	cs
 80a4916:	463c      	movcs	r4, r7
          memcpy(buffer, &d_->buffer[d_->offset], read);
 80a4918:	3104      	adds	r1, #4
 80a491a:	4622      	mov	r2, r4
 80a491c:	f001 fc36 	bl	80a618c <memcpy>
 80a4920:	696a      	ldr	r2, [r5, #20]
          d_->offset += read;
 80a4922:	f8b2 3084 	ldrh.w	r3, [r2, #132]	; 0x84
 80a4926:	4423      	add	r3, r4
 80a4928:	f8a2 3084 	strh.w	r3, [r2, #132]	; 0x84
        }
        return read;
}
 80a492c:	4620      	mov	r0, r4
 80a492e:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}

080a4930 <_ZN9TCPClient12flush_bufferEv>:
{
  return  (bufferCount() || available()) ? d_->buffer[d_->offset] : -1;
}

void TCPClient::flush_buffer()
{
 80a4930:	6942      	ldr	r2, [r0, #20]
  d_->offset = 0;
 80a4932:	2300      	movs	r3, #0
 80a4934:	f8a2 3084 	strh.w	r3, [r2, #132]	; 0x84
 80a4938:	6942      	ldr	r2, [r0, #20]
  d_->total = 0;
 80a493a:	f8a2 3086 	strh.w	r3, [r2, #134]	; 0x86
 80a493e:	4770      	bx	lr

080a4940 <_ZN9TCPClient9availableEv>:
{
  return d_->total - d_->offset;
}

int TCPClient::available()
{
 80a4940:	b538      	push	{r3, r4, r5, lr}
 80a4942:	6942      	ldr	r2, [r0, #20]
 80a4944:	4604      	mov	r4, r0
    int avail = 0;

    // At EOB => Flush it
    if (d_->total && (d_->offset == d_->total))
 80a4946:	f8b2 3086 	ldrh.w	r3, [r2, #134]	; 0x86
 80a494a:	b11b      	cbz	r3, 80a4954 <_ZN9TCPClient9availableEv+0x14>
 80a494c:	f8b2 2084 	ldrh.w	r2, [r2, #132]	; 0x84
 80a4950:	429a      	cmp	r2, r3
 80a4952:	d00b      	beq.n	80a496c <_ZN9TCPClient9availableEv+0x2c>
    }


    static NetworkClass& from(network_interface_t nif) {
        // hard-code for now until multiple-networks are implemented.
        return Network;
 80a4954:	4b18      	ldr	r3, [pc, #96]	; (80a49b8 <_ZN9TCPClient9availableEv+0x78>)
 80a4956:	6818      	ldr	r0, [r3, #0]
    {
        flush_buffer();
    }

    if(Network.from(nif).ready() && isOpen(d_->sock))
 80a4958:	6803      	ldr	r3, [r0, #0]
 80a495a:	681b      	ldr	r3, [r3, #0]
 80a495c:	4798      	blx	r3
 80a495e:	b318      	cbz	r0, 80a49a8 <_ZN9TCPClient9availableEv+0x68>
 80a4960:	6963      	ldr	r3, [r4, #20]

using namespace spark;

static bool inline isOpen(sock_handle_t sd)
{
   return socket_handle_valid(sd);
 80a4962:	6818      	ldr	r0, [r3, #0]
 80a4964:	f7fe fe82 	bl	80a366c <socket_handle_valid>
    if (d_->total && (d_->offset == d_->total))
    {
        flush_buffer();
    }

    if(Network.from(nif).ready() && isOpen(d_->sock))
 80a4968:	b918      	cbnz	r0, 80a4972 <_ZN9TCPClient9availableEv+0x32>
 80a496a:	e01d      	b.n	80a49a8 <_ZN9TCPClient9availableEv+0x68>
    int avail = 0;

    // At EOB => Flush it
    if (d_->total && (d_->offset == d_->total))
    {
        flush_buffer();
 80a496c:	f7ff ffe0 	bl	80a4930 <_ZN9TCPClient12flush_bufferEv>
 80a4970:	e7f0      	b.n	80a4954 <_ZN9TCPClient9availableEv+0x14>
 80a4972:	6960      	ldr	r0, [r4, #20]
    }

    if(Network.from(nif).ready() && isOpen(d_->sock))
    {
        // Have room
        if ( d_->total < arraySize(d_->buffer))
 80a4974:	f8b0 1086 	ldrh.w	r1, [r0, #134]	; 0x86
 80a4978:	297f      	cmp	r1, #127	; 0x7f
 80a497a:	d815      	bhi.n	80a49a8 <_ZN9TCPClient9availableEv+0x68>
        {
            int ret = socket_receive(d_->sock, d_->buffer + d_->total , arraySize(d_->buffer)-d_->total, 0);
 80a497c:	1d05      	adds	r5, r0, #4
 80a497e:	f1c1 0280 	rsb	r2, r1, #128	; 0x80
 80a4982:	2300      	movs	r3, #0
 80a4984:	4429      	add	r1, r5
 80a4986:	6800      	ldr	r0, [r0, #0]
 80a4988:	f7fe fe88 	bl	80a369c <socket_receive>
            if (ret > 0)
 80a498c:	2800      	cmp	r0, #0
 80a498e:	dd0b      	ble.n	80a49a8 <_ZN9TCPClient9availableEv+0x68>
 80a4990:	6963      	ldr	r3, [r4, #20]
            {
                DEBUG("recv(=%d)",ret);
                if (d_->total == 0) d_->offset = 0;
 80a4992:	f8b3 2086 	ldrh.w	r2, [r3, #134]	; 0x86
 80a4996:	b90a      	cbnz	r2, 80a499c <_ZN9TCPClient9availableEv+0x5c>
 80a4998:	f8a3 2084 	strh.w	r2, [r3, #132]	; 0x84
 80a499c:	6962      	ldr	r2, [r4, #20]
                d_->total += ret;
 80a499e:	f8b2 3086 	ldrh.w	r3, [r2, #134]	; 0x86
 80a49a2:	4418      	add	r0, r3
 80a49a4:	f8a2 0086 	strh.w	r0, [r2, #134]	; 0x86
 80a49a8:	6962      	ldr	r2, [r4, #20]
            }
        } // Have Space
    } // WiFi.ready() && isOpen(d_->sock)
    avail = bufferCount();
    return avail;
 80a49aa:	f8b2 3086 	ldrh.w	r3, [r2, #134]	; 0x86
 80a49ae:	f8b2 0084 	ldrh.w	r0, [r2, #132]	; 0x84
 80a49b2:	1a18      	subs	r0, r3, r0
}
 80a49b4:	bd38      	pop	{r3, r4, r5, pc}
 80a49b6:	bf00      	nop
 80a49b8:	080a697c 	.word	0x080a697c

080a49bc <_ZN9TCPClient4stopEv>:
{
}


void TCPClient::stop()
{
 80a49bc:	b538      	push	{r3, r4, r5, lr}
  // This log line pollutes the log too much
  // DEBUG("sock %d closesocket", d_->sock);

  if (isOpen(d_->sock))
 80a49be:	6943      	ldr	r3, [r0, #20]
{
}


void TCPClient::stop()
{
 80a49c0:	4604      	mov	r4, r0

using namespace spark;

static bool inline isOpen(sock_handle_t sd)
{
   return socket_handle_valid(sd);
 80a49c2:	6818      	ldr	r0, [r3, #0]
 80a49c4:	f7fe fe52 	bl	80a366c <socket_handle_valid>
void TCPClient::stop()
{
  // This log line pollutes the log too much
  // DEBUG("sock %d closesocket", d_->sock);

  if (isOpen(d_->sock))
 80a49c8:	b118      	cbz	r0, 80a49d2 <_ZN9TCPClient4stopEv+0x16>
      socket_close(d_->sock);
 80a49ca:	6963      	ldr	r3, [r4, #20]
 80a49cc:	6818      	ldr	r0, [r3, #0]
 80a49ce:	f7fe fe6d 	bl	80a36ac <socket_close>
 80a49d2:	6965      	ldr	r5, [r4, #20]
  d_->sock = socket_handle_invalid();
 80a49d4:	f7fe fe72 	bl	80a36bc <socket_handle_invalid>
 80a49d8:	6028      	str	r0, [r5, #0]
        return address;
    }

    virtual size_t printTo(Print& p) const;

    void clear() { memset(&address, 0, sizeof (address)); }
 80a49da:	6960      	ldr	r0, [r4, #20]
 80a49dc:	2211      	movs	r2, #17
 80a49de:	2100      	movs	r1, #0
 80a49e0:	308c      	adds	r0, #140	; 0x8c
 80a49e2:	f001 fbde 	bl	80a61a2 <memset>
  d_->remoteIP.clear();
  flush_buffer();
 80a49e6:	4620      	mov	r0, r4
}
 80a49e8:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}

  if (isOpen(d_->sock))
      socket_close(d_->sock);
  d_->sock = socket_handle_invalid();
  d_->remoteIP.clear();
  flush_buffer();
 80a49ec:	f7ff bfa0 	b.w	80a4930 <_ZN9TCPClient12flush_bufferEv>

080a49f0 <_ZN9TCPClientC1Em>:

TCPClient::TCPClient() : TCPClient(socket_handle_invalid())
{
}

TCPClient::TCPClient(sock_handle_t sock) :
 80a49f0:	b5f8      	push	{r3, r4, r5, r6, r7, lr}
 80a49f2:	f44f 737a 	mov.w	r3, #1000	; 0x3e8
 80a49f6:	6083      	str	r3, [r0, #8]
        d_(std::make_shared<Data>(sock))
 80a49f8:	4b17      	ldr	r3, [pc, #92]	; (80a4a58 <_ZN9TCPClientC1Em+0x68>)
 80a49fa:	2600      	movs	r6, #0
 80a49fc:	6046      	str	r6, [r0, #4]
 80a49fe:	6003      	str	r3, [r0, #0]
        };

      template<typename _Alloc, typename... _Args>
	__shared_ptr(_Sp_make_shared_tag __tag, const _Alloc& __a,
		     _Args&&... __args)
	: _M_ptr(), _M_refcount()
 80a4a00:	6146      	str	r6, [r0, #20]

  template<_Lock_policy _Lp>
    class __shared_count
    {
    public:
      constexpr __shared_count() noexcept : _M_pi(0)
 80a4a02:	6186      	str	r6, [r0, #24]

TCPClient::TCPClient() : TCPClient(socket_handle_invalid())
{
}

TCPClient::TCPClient(sock_handle_t sock) :
 80a4a04:	4604      	mov	r4, r0
      allocate(size_type __n, const void* = 0)
      { 
	if (__n > this->max_size())
	  std::__throw_bad_alloc();

	return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp)));
 80a4a06:	20a0      	movs	r0, #160	; 0xa0
 80a4a08:	460f      	mov	r7, r1
 80a4a0a:	f7fb fb46 	bl	80a009a <_Znwj>

#if __cplusplus >= 201103L
      template<typename _Up, typename... _Args>
        void
        construct(_Up* __p, _Args&&... __args)
	{ ::new((void *)__p) _Up(std::forward<_Args>(__args)...); }
 80a4a0e:	4605      	mov	r5, r0
 80a4a10:	b138      	cbz	r0, 80a4a22 <_ZN9TCPClientC1Em+0x32>
        IPAddress remoteIP;

        explicit Data(sock_handle_t sock) :
                sock(sock),
                offset(0),
                total(0) {
 80a4a12:	6007      	str	r7, [r0, #0]
 80a4a14:	f8a0 6084 	strh.w	r6, [r0, #132]	; 0x84
 80a4a18:	f8a0 6086 	strh.w	r6, [r0, #134]	; 0x86
 80a4a1c:	3088      	adds	r0, #136	; 0x88
 80a4a1e:	f7ff f9db 	bl	80a3dd8 <_ZN9IPAddressC1Ev>
      allocate(size_type __n, const void* = 0)
      { 
	if (__n > this->max_size())
	  std::__throw_bad_alloc();

	return static_cast<_Tp*>(::operator new(__n * sizeof(_Tp)));
 80a4a22:	2014      	movs	r0, #20
 80a4a24:	f7fb fb39 	bl	80a009a <_Znwj>
	  __try
	    {
	      typename _Sp_cd_type::__allocator_type __a2(__a);
	      auto __guard = std::__allocate_guarded(__a2);
	      _Sp_cd_type* __mem = __guard.get();
	      ::new (__mem) _Sp_cd_type(__p, std::move(__d), std::move(__a));
 80a4a28:	4603      	mov	r3, r0
 80a4a2a:	b128      	cbz	r0, 80a4a38 <_ZN9TCPClientC1Em+0x48>
    class _Sp_counted_base
    : public _Mutex_base<_Lp>
    {
    public:  
      _Sp_counted_base() noexcept
      : _M_use_count(1), _M_weak_count(1) { }
 80a4a2c:	2201      	movs	r2, #1
 80a4a2e:	6042      	str	r2, [r0, #4]
 80a4a30:	6082      	str	r2, [r0, #8]
      _Sp_counted_deleter(_Ptr __p, _Deleter __d) noexcept
      : _M_impl(__p, __d, _Alloc()) { }

      // __d(__p) must not throw.
      _Sp_counted_deleter(_Ptr __p, _Deleter __d, const _Alloc& __a) noexcept
      : _M_impl(__p, __d, __a) { }
 80a4a32:	4a0a      	ldr	r2, [pc, #40]	; (80a4a5c <_ZN9TCPClientC1Em+0x6c>)
	typedef _Sp_ebo_helper<0, _Deleter>	_Del_base;
	typedef _Sp_ebo_helper<1, _Alloc>	_Alloc_base;

      public:
	_Impl(_Ptr __p, _Deleter __d, const _Alloc& __a) noexcept
	: _M_ptr(__p), _Del_base(__d), _Alloc_base(__a)
 80a4a34:	6105      	str	r5, [r0, #16]
      _Sp_counted_deleter(_Ptr __p, _Deleter __d) noexcept
      : _M_impl(__p, __d, _Alloc()) { }

      // __d(__p) must not throw.
      _Sp_counted_deleter(_Ptr __p, _Deleter __d, const _Alloc& __a) noexcept
      : _M_impl(__p, __d, __a) { }
 80a4a36:	6002      	str	r2, [r0, #0]

      void
      _M_swap(__shared_count& __r) noexcept
      {
	_Sp_counted_base<_Lp>* __tmp = __r._M_pi;
	__r._M_pi = _M_pi;
 80a4a38:	69a0      	ldr	r0, [r4, #24]
	  __traits::construct(__del._M_alloc, __ptr,
			      std::forward<_Args>(__args)...);
	  __guard = nullptr;
	  __shared_count<_Lp> __count(__ptr, __del, __del._M_alloc);
	  _M_refcount._M_swap(__count);
	  _M_ptr = __ptr;
 80a4a3a:	6165      	str	r5, [r4, #20]
      void
      _M_swap(__shared_count& __r) noexcept
      {
	_Sp_counted_base<_Lp>* __tmp = __r._M_pi;
	__r._M_pi = _M_pi;
	_M_pi = __tmp;
 80a4a3c:	61a3      	str	r3, [r4, #24]
      // Does not throw if __r._M_get_use_count() == 0, caller must check.
      explicit __shared_count(const __weak_count<_Lp>& __r, std::nothrow_t);

      ~__shared_count() noexcept
      {
	if (_M_pi != nullptr)
 80a4a3e:	b128      	cbz	r0, 80a4a4c <_ZN9TCPClientC1Em+0x5c>

  template<>
    inline void
    _Sp_counted_base<_S_single>::_M_release() noexcept
    {
      if (--_M_use_count == 0)
 80a4a40:	6843      	ldr	r3, [r0, #4]
 80a4a42:	3b01      	subs	r3, #1
 80a4a44:	6043      	str	r3, [r0, #4]
 80a4a46:	b90b      	cbnz	r3, 80a4a4c <_ZN9TCPClientC1Em+0x5c>
 80a4a48:	f7ff feea 	bl	80a4820 <_ZNSt16_Sp_counted_baseILN9__gnu_cxx12_Lock_policyE0EE10_M_releaseEv.part.2.constprop.30>
        d_(std::make_shared<Data>(sock))
{
  flush_buffer();
 80a4a4c:	4620      	mov	r0, r4
 80a4a4e:	f7ff ff6f 	bl	80a4930 <_ZN9TCPClient12flush_bufferEv>
}
 80a4a52:	4620      	mov	r0, r4
 80a4a54:	bdf8      	pop	{r3, r4, r5, r6, r7, pc}
 80a4a56:	bf00      	nop
 80a4a58:	080a6b68 	.word	0x080a6b68
 80a4a5c:	080a6b4c 	.word	0x080a6b4c

080a4a60 <_ZN9TCPClientC1Ev>:
static bool inline isOpen(sock_handle_t sd)
{
   return socket_handle_valid(sd);
}

TCPClient::TCPClient() : TCPClient(socket_handle_invalid())
 80a4a60:	b510      	push	{r4, lr}
 80a4a62:	4604      	mov	r4, r0
 80a4a64:	f7fe fe2a 	bl	80a36bc <socket_handle_invalid>
 80a4a68:	4601      	mov	r1, r0
 80a4a6a:	4620      	mov	r0, r4
 80a4a6c:	f7ff ffc0 	bl	80a49f0 <_ZN9TCPClientC1Em>
{
}
 80a4a70:	4620      	mov	r0, r4
 80a4a72:	bd10      	pop	{r4, pc}

080a4a74 <_ZN9TCPClient7connectE9IPAddresstm>:
      }
      return rv;
}

int TCPClient::connect(IPAddress ip, uint16_t port, network_interface_t nif)
{
 80a4a74:	e92d 41f0 	stmdb	sp!, {r4, r5, r6, r7, r8, lr}
 80a4a78:	4698      	mov	r8, r3
    stop();
 80a4a7a:	6803      	ldr	r3, [r0, #0]
      }
      return rv;
}

int TCPClient::connect(IPAddress ip, uint16_t port, network_interface_t nif)
{
 80a4a7c:	b08a      	sub	sp, #40	; 0x28
    stop();
 80a4a7e:	6adb      	ldr	r3, [r3, #44]	; 0x2c
      }
      return rv;
}

int TCPClient::connect(IPAddress ip, uint16_t port, network_interface_t nif)
{
 80a4a80:	4606      	mov	r6, r0
 80a4a82:	460c      	mov	r4, r1
 80a4a84:	4615      	mov	r5, r2
    stop();
 80a4a86:	4798      	blx	r3
 80a4a88:	4b2f      	ldr	r3, [pc, #188]	; (80a4b48 <_ZN9TCPClient7connectE9IPAddresstm+0xd4>)
 80a4a8a:	6818      	ldr	r0, [r3, #0]
        int connected = 0;
        if(Network.from(nif).ready())
 80a4a8c:	6803      	ldr	r3, [r0, #0]
 80a4a8e:	681b      	ldr	r3, [r3, #0]
 80a4a90:	4798      	blx	r3
 80a4a92:	2800      	cmp	r0, #0
 80a4a94:	d055      	beq.n	80a4b42 <_ZN9TCPClient7connectE9IPAddresstm+0xce>
        {
          sockaddr_t tSocketAddr;
          d_->sock = socket_create(AF_INET, SOCK_STREAM, IPPROTO_TCP, port, nif);
 80a4a96:	462b      	mov	r3, r5
 80a4a98:	2206      	movs	r2, #6
 80a4a9a:	2101      	movs	r1, #1
 80a4a9c:	f8cd 8000 	str.w	r8, [sp]
 80a4aa0:	2002      	movs	r0, #2
 80a4aa2:	6977      	ldr	r7, [r6, #20]
 80a4aa4:	f7fe fdea 	bl	80a367c <socket_create>
          LOG(TRACE, "TCPClient socket=%x", d_->sock);
 80a4aa8:	2320      	movs	r3, #32
    stop();
        int connected = 0;
        if(Network.from(nif).ready())
        {
          sockaddr_t tSocketAddr;
          d_->sock = socket_create(AF_INET, SOCK_STREAM, IPPROTO_TCP, port, nif);
 80a4aaa:	6038      	str	r0, [r7, #0]
          LOG(TRACE, "TCPClient socket=%x", d_->sock);
 80a4aac:	9302      	str	r3, [sp, #8]
 80a4aae:	2700      	movs	r7, #0
 80a4ab0:	6973      	ldr	r3, [r6, #20]
 80a4ab2:	9703      	str	r7, [sp, #12]
 80a4ab4:	681b      	ldr	r3, [r3, #0]
 80a4ab6:	2001      	movs	r0, #1
 80a4ab8:	9301      	str	r3, [sp, #4]
 80a4aba:	4b24      	ldr	r3, [pc, #144]	; (80a4b4c <_ZN9TCPClient7connectE9IPAddresstm+0xd8>)
 80a4abc:	aa02      	add	r2, sp, #8
 80a4abe:	9300      	str	r3, [sp, #0]
 80a4ac0:	4923      	ldr	r1, [pc, #140]	; (80a4b50 <_ZN9TCPClient7connectE9IPAddresstm+0xdc>)
 80a4ac2:	463b      	mov	r3, r7
 80a4ac4:	f7fe ff74 	bl	80a39b0 <log_message>

          if (socket_handle_valid(d_->sock))
 80a4ac8:	6973      	ldr	r3, [r6, #20]
 80a4aca:	6818      	ldr	r0, [r3, #0]
 80a4acc:	f7fe fdce 	bl	80a366c <socket_handle_valid>
 80a4ad0:	2800      	cmp	r0, #0
 80a4ad2:	d036      	beq.n	80a4b42 <_ZN9TCPClient7connectE9IPAddresstm+0xce>
          {
            flush_buffer();
 80a4ad4:	4630      	mov	r0, r6
 80a4ad6:	f7ff ff2b 	bl	80a4930 <_ZN9TCPClient12flush_bufferEv>

            tSocketAddr.sa_family = AF_INET;
 80a4ada:	2302      	movs	r3, #2
 80a4adc:	f8ad 3008 	strh.w	r3, [sp, #8]

            tSocketAddr.sa_data[0] = (port & 0xFF00) >> 8;
 80a4ae0:	0a2b      	lsrs	r3, r5, #8
 80a4ae2:	f88d 300a 	strb.w	r3, [sp, #10]
            tSocketAddr.sa_data[1] = (port & 0x00FF);

            tSocketAddr.sa_data[2] = ip[0];        // Todo IPv6
 80a4ae6:	79e3      	ldrb	r3, [r4, #7]
            tSocketAddr.sa_data[3] = ip[1];
            tSocketAddr.sa_data[4] = ip[2];
            tSocketAddr.sa_data[5] = ip[3];


            uint32_t ot = HAL_NET_SetNetWatchDog(S2M(MAX_SEC_WAIT_CONNECT));
 80a4ae8:	f44f 50fa 	mov.w	r0, #8000	; 0x1f40
            tSocketAddr.sa_family = AF_INET;

            tSocketAddr.sa_data[0] = (port & 0xFF00) >> 8;
            tSocketAddr.sa_data[1] = (port & 0x00FF);

            tSocketAddr.sa_data[2] = ip[0];        // Todo IPv6
 80a4aec:	f88d 300c 	strb.w	r3, [sp, #12]
            tSocketAddr.sa_data[3] = ip[1];
 80a4af0:	79a3      	ldrb	r3, [r4, #6]
            flush_buffer();

            tSocketAddr.sa_family = AF_INET;

            tSocketAddr.sa_data[0] = (port & 0xFF00) >> 8;
            tSocketAddr.sa_data[1] = (port & 0x00FF);
 80a4af2:	f88d 500b 	strb.w	r5, [sp, #11]

            tSocketAddr.sa_data[2] = ip[0];        // Todo IPv6
            tSocketAddr.sa_data[3] = ip[1];
 80a4af6:	f88d 300d 	strb.w	r3, [sp, #13]
            tSocketAddr.sa_data[4] = ip[2];
 80a4afa:	7963      	ldrb	r3, [r4, #5]
 80a4afc:	f88d 300e 	strb.w	r3, [sp, #14]
            tSocketAddr.sa_data[5] = ip[3];
 80a4b00:	f814 3f04 	ldrb.w	r3, [r4, #4]!
 80a4b04:	f88d 300f 	strb.w	r3, [sp, #15]


            uint32_t ot = HAL_NET_SetNetWatchDog(S2M(MAX_SEC_WAIT_CONNECT));
 80a4b08:	f7fe fd60 	bl	80a35cc <HAL_NET_SetNetWatchDog>
            DEBUG("sock %d connect",d_->sock);
            connected = (socket_connect(d_->sock, &tSocketAddr, sizeof(tSocketAddr)) == 0 ? 1 : 0);
 80a4b0c:	6973      	ldr	r3, [r6, #20]
            tSocketAddr.sa_data[3] = ip[1];
            tSocketAddr.sa_data[4] = ip[2];
            tSocketAddr.sa_data[5] = ip[3];


            uint32_t ot = HAL_NET_SetNetWatchDog(S2M(MAX_SEC_WAIT_CONNECT));
 80a4b0e:	4605      	mov	r5, r0
            DEBUG("sock %d connect",d_->sock);
            connected = (socket_connect(d_->sock, &tSocketAddr, sizeof(tSocketAddr)) == 0 ? 1 : 0);
 80a4b10:	2210      	movs	r2, #16
 80a4b12:	a902      	add	r1, sp, #8
 80a4b14:	6818      	ldr	r0, [r3, #0]
 80a4b16:	f7fe fdb9 	bl	80a368c <socket_connect>
 80a4b1a:	4680      	mov	r8, r0
            DEBUG("sock %d connected=%d",d_->sock, connected);
            HAL_NET_SetNetWatchDog(ot);
 80a4b1c:	4628      	mov	r0, r5
 80a4b1e:	f7fe fd55 	bl	80a35cc <HAL_NET_SetNetWatchDog>

/**
 * The IP address stored in host order.
 *
 */
class IPAddress : public Printable {
 80a4b22:	cc0f      	ldmia	r4!, {r0, r1, r2, r3}
 80a4b24:	6975      	ldr	r5, [r6, #20]
 80a4b26:	358c      	adds	r5, #140	; 0x8c
 80a4b28:	c50f      	stmia	r5!, {r0, r1, r2, r3}
 80a4b2a:	6823      	ldr	r3, [r4, #0]
 80a4b2c:	702b      	strb	r3, [r5, #0]
            d_->remoteIP = ip;
            if(!connected)
 80a4b2e:	f1b8 0f00 	cmp.w	r8, #0
 80a4b32:	d005      	beq.n	80a4b40 <_ZN9TCPClient7connectE9IPAddresstm+0xcc>
            {
                stop();
 80a4b34:	6833      	ldr	r3, [r6, #0]
 80a4b36:	4630      	mov	r0, r6
 80a4b38:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80a4b3a:	4798      	blx	r3
 80a4b3c:	4638      	mov	r0, r7
 80a4b3e:	e000      	b.n	80a4b42 <_ZN9TCPClient7connectE9IPAddresstm+0xce>
            DEBUG("sock %d connect",d_->sock);
            connected = (socket_connect(d_->sock, &tSocketAddr, sizeof(tSocketAddr)) == 0 ? 1 : 0);
            DEBUG("sock %d connected=%d",d_->sock, connected);
            HAL_NET_SetNetWatchDog(ot);
            d_->remoteIP = ip;
            if(!connected)
 80a4b40:	2001      	movs	r0, #1
                stop();
            }
          }
        }
        return connected;
}
 80a4b42:	b00a      	add	sp, #40	; 0x28
 80a4b44:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}
 80a4b48:	080a697c 	.word	0x080a697c
 80a4b4c:	080a6bb3 	.word	0x080a6bb3
 80a4b50:	080a6bac 	.word	0x080a6bac

080a4b54 <_ZN9TCPClient6statusEv>:
  }
  return rv;
}

uint8_t TCPClient::status()
{
 80a4b54:	b510      	push	{r4, lr}
  return (isOpen(d_->sock) && Network.from(nif).ready() && (SOCKET_STATUS_ACTIVE == socket_active_status(d_->sock)));
 80a4b56:	6943      	ldr	r3, [r0, #20]
  }
  return rv;
}

uint8_t TCPClient::status()
{
 80a4b58:	4604      	mov	r4, r0

using namespace spark;

static bool inline isOpen(sock_handle_t sd)
{
   return socket_handle_valid(sd);
 80a4b5a:	6818      	ldr	r0, [r3, #0]
 80a4b5c:	f7fe fd86 	bl	80a366c <socket_handle_valid>
  return rv;
}

uint8_t TCPClient::status()
{
  return (isOpen(d_->sock) && Network.from(nif).ready() && (SOCKET_STATUS_ACTIVE == socket_active_status(d_->sock)));
 80a4b60:	b908      	cbnz	r0, 80a4b66 <_ZN9TCPClient6statusEv+0x12>
 80a4b62:	2000      	movs	r0, #0
 80a4b64:	bd10      	pop	{r4, pc}
 80a4b66:	4b07      	ldr	r3, [pc, #28]	; (80a4b84 <_ZN9TCPClient6statusEv+0x30>)
 80a4b68:	6818      	ldr	r0, [r3, #0]
 80a4b6a:	6803      	ldr	r3, [r0, #0]
 80a4b6c:	681b      	ldr	r3, [r3, #0]
 80a4b6e:	4798      	blx	r3
 80a4b70:	2800      	cmp	r0, #0
 80a4b72:	d0f6      	beq.n	80a4b62 <_ZN9TCPClient6statusEv+0xe>
 80a4b74:	6963      	ldr	r3, [r4, #20]
 80a4b76:	6818      	ldr	r0, [r3, #0]
 80a4b78:	f7fe fd70 	bl	80a365c <socket_active_status>
 80a4b7c:	fab0 f080 	clz	r0, r0
 80a4b80:	0940      	lsrs	r0, r0, #5
}
 80a4b82:	bd10      	pop	{r4, pc}
 80a4b84:	080a697c 	.word	0x080a697c

080a4b88 <_ZN9TCPClient5writeEPKhjm>:
{
    return write(&b, 1, timeout);
}

size_t TCPClient::write(const uint8_t *buffer, size_t size, system_tick_t timeout)
{
 80a4b88:	e92d 41f3 	stmdb	sp!, {r0, r1, r4, r5, r6, r7, r8, lr}
  private:
    int write_error;
    size_t printNumber(unsigned long, uint8_t);
    size_t printFloat(double, uint8_t);
  protected:
    void setWriteError(int err = 1) { write_error = err; }
 80a4b8c:	2500      	movs	r5, #0
 80a4b8e:	6045      	str	r5, [r0, #4]
 80a4b90:	4604      	mov	r4, r0
 80a4b92:	460e      	mov	r6, r1
 80a4b94:	4617      	mov	r7, r2
 80a4b96:	4698      	mov	r8, r3
    clearWriteError();
    int ret = status() ? socket_send_ex(d_->sock, buffer, size, 0, timeout, nullptr) : -1;
 80a4b98:	f7ff ffdc 	bl	80a4b54 <_ZN9TCPClient6statusEv>
 80a4b9c:	b160      	cbz	r0, 80a4bb8 <_ZN9TCPClient5writeEPKhjm+0x30>
 80a4b9e:	6960      	ldr	r0, [r4, #20]
 80a4ba0:	9501      	str	r5, [sp, #4]
 80a4ba2:	f8cd 8000 	str.w	r8, [sp]
 80a4ba6:	462b      	mov	r3, r5
 80a4ba8:	463a      	mov	r2, r7
 80a4baa:	4631      	mov	r1, r6
 80a4bac:	6800      	ldr	r0, [r0, #0]
 80a4bae:	f7fe fd8d 	bl	80a36cc <socket_send_ex>
    if (ret < 0) {
 80a4bb2:	2800      	cmp	r0, #0
 80a4bb4:	da03      	bge.n	80a4bbe <_ZN9TCPClient5writeEPKhjm+0x36>
 80a4bb6:	e001      	b.n	80a4bbc <_ZN9TCPClient5writeEPKhjm+0x34>
}

size_t TCPClient::write(const uint8_t *buffer, size_t size, system_tick_t timeout)
{
    clearWriteError();
    int ret = status() ? socket_send_ex(d_->sock, buffer, size, 0, timeout, nullptr) : -1;
 80a4bb8:	f04f 30ff 	mov.w	r0, #4294967295
 80a4bbc:	6060      	str	r0, [r4, #4]

    /*
     * FIXME: We should not be returning negative numbers here
     */
    return ret;
}
 80a4bbe:	b002      	add	sp, #8
 80a4bc0:	e8bd 81f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, pc}

080a4bc4 <_ZN9TCPClient9connectedEv>:
  d_->remoteIP.clear();
  flush_buffer();
}

uint8_t TCPClient::connected()
{
 80a4bc4:	b538      	push	{r3, r4, r5, lr}
 80a4bc6:	4604      	mov	r4, r0
  // Wlan up, open and not in CLOSE_WAIT or data still in the local buffer
  bool rv = (status() || bufferCount());
 80a4bc8:	f7ff ffc4 	bl	80a4b54 <_ZN9TCPClient6statusEv>
 80a4bcc:	bb00      	cbnz	r0, 80a4c10 <_ZN9TCPClient9connectedEv+0x4c>
 80a4bce:	6963      	ldr	r3, [r4, #20]
 80a4bd0:	f8b3 1086 	ldrh.w	r1, [r3, #134]	; 0x86
 80a4bd4:	f8b3 2084 	ldrh.w	r2, [r3, #132]	; 0x84
 80a4bd8:	4291      	cmp	r1, r2
 80a4bda:	d119      	bne.n	80a4c10 <_ZN9TCPClient9connectedEv+0x4c>

using namespace spark;

static bool inline isOpen(sock_handle_t sd)
{
   return socket_handle_valid(sd);
 80a4bdc:	6818      	ldr	r0, [r3, #0]
 80a4bde:	f7fe fd45 	bl	80a366c <socket_handle_valid>
uint8_t TCPClient::connected()
{
  // Wlan up, open and not in CLOSE_WAIT or data still in the local buffer
  bool rv = (status() || bufferCount());
  // no data in the local buffer, Socket open but my be in CLOSE_WAIT yet the CC3000 may have data in its buffer
  if(!rv && isOpen(d_->sock) && (SOCKET_STATUS_INACTIVE == socket_active_status(d_->sock)))
 80a4be2:	b128      	cbz	r0, 80a4bf0 <_ZN9TCPClient9connectedEv+0x2c>
 80a4be4:	6963      	ldr	r3, [r4, #20]
 80a4be6:	6818      	ldr	r0, [r3, #0]
 80a4be8:	f7fe fd38 	bl	80a365c <socket_active_status>
 80a4bec:	2801      	cmp	r0, #1
 80a4bee:	d001      	beq.n	80a4bf4 <_ZN9TCPClient9connectedEv+0x30>
}

uint8_t TCPClient::connected()
{
  // Wlan up, open and not in CLOSE_WAIT or data still in the local buffer
  bool rv = (status() || bufferCount());
 80a4bf0:	2500      	movs	r5, #0
 80a4bf2:	e00e      	b.n	80a4c12 <_ZN9TCPClient9connectedEv+0x4e>
  // no data in the local buffer, Socket open but my be in CLOSE_WAIT yet the CC3000 may have data in its buffer
  if(!rv && isOpen(d_->sock) && (SOCKET_STATUS_INACTIVE == socket_active_status(d_->sock)))
    {
      rv = available(); // Try CC3000
 80a4bf4:	6823      	ldr	r3, [r4, #0]
 80a4bf6:	4620      	mov	r0, r4
 80a4bf8:	691b      	ldr	r3, [r3, #16]
 80a4bfa:	4798      	blx	r3
 80a4bfc:	2800      	cmp	r0, #0
 80a4bfe:	bf14      	ite	ne
 80a4c00:	2501      	movne	r5, #1
 80a4c02:	2500      	moveq	r5, #0
      if (!rv) {        // No more Data and CLOSE_WAIT
 80a4c04:	d105      	bne.n	80a4c12 <_ZN9TCPClient9connectedEv+0x4e>
          DEBUG("caling Stop No more Data and in CLOSE_WAIT");
          stop();       // Close our side
 80a4c06:	6823      	ldr	r3, [r4, #0]
 80a4c08:	4620      	mov	r0, r4
 80a4c0a:	6adb      	ldr	r3, [r3, #44]	; 0x2c
 80a4c0c:	4798      	blx	r3
 80a4c0e:	e000      	b.n	80a4c12 <_ZN9TCPClient9connectedEv+0x4e>
 80a4c10:	2501      	movs	r5, #1
      }
  }
  return rv;
}
 80a4c12:	4628      	mov	r0, r5
 80a4c14:	bd38      	pop	{r3, r4, r5, pc}

080a4c16 <_ZN9TCPClientcvbEv>:
{
  return (isOpen(d_->sock) && Network.from(nif).ready() && (SOCKET_STATUS_ACTIVE == socket_active_status(d_->sock)));
}

TCPClient::operator bool()
{
 80a4c16:	b508      	push	{r3, lr}
   return (status()!=0);
 80a4c18:	f7ff ff9c 	bl	80a4b54 <_ZN9TCPClient6statusEv>
}
 80a4c1c:	3000      	adds	r0, #0
 80a4c1e:	bf18      	it	ne
 80a4c20:	2001      	movne	r0, #1
 80a4c22:	bd08      	pop	{r3, pc}

080a4c24 <_Z11str_reversePc>:

//------------------------------------------------------------------------------------------
#define BUFSIZE (sizeof(long) * 8 + 1)

//utility function used by ultoa()
__attribute__((weak)) void str_reverse(char* buffer){
 80a4c24:	b510      	push	{r4, lr}
 80a4c26:	4604      	mov	r4, r0
	char *i, *j;
	char c;
	i=buffer;
	j=buffer + strlen(buffer)-1;
 80a4c28:	f001 fb53 	bl	80a62d2 <strlen>
 80a4c2c:	3801      	subs	r0, #1
 80a4c2e:	1823      	adds	r3, r4, r0
 80a4c30:	4620      	mov	r0, r4
	while(i<j){
 80a4c32:	4298      	cmp	r0, r3
 80a4c34:	d206      	bcs.n	80a4c44 <_Z11str_reversePc+0x20>
		c = *i;
 80a4c36:	7802      	ldrb	r2, [r0, #0]
		*i = *j;
 80a4c38:	7819      	ldrb	r1, [r3, #0]
 80a4c3a:	f800 1b01 	strb.w	r1, [r0], #1
		*j = c;
 80a4c3e:	f803 2901 	strb.w	r2, [r3], #-1
__attribute__((weak)) void str_reverse(char* buffer){
	char *i, *j;
	char c;
	i=buffer;
	j=buffer + strlen(buffer)-1;
	while(i<j){
 80a4c42:	e7f6      	b.n	80a4c32 <_Z11str_reversePc+0xe>
 80a4c44:	bd10      	pop	{r4, pc}

080a4c46 <ultoa>:
      memcpy(head, ++tail, i);
      return str;
}

//convert unsigned long to string
__attribute__((weak)) char* ultoa(unsigned long a, char* buffer, int radix, char pad){
 80a4c46:	b570      	push	{r4, r5, r6, lr}
 80a4c48:	460c      	mov	r4, r1
	if(radix<2 || radix>36){
 80a4c4a:	1e91      	subs	r1, r2, #2
 80a4c4c:	2922      	cmp	r1, #34	; 0x22
 80a4c4e:	d820      	bhi.n	80a4c92 <ultoa+0x4c>
 80a4c50:	4625      	mov	r5, r4
 80a4c52:	4629      	mov	r1, r5
		return NULL;
	}
	char* ptr=buffer;

	div_t result;
	while(a){
 80a4c54:	b910      	cbnz	r0, 80a4c5c <ultoa+0x16>
                *ptr += 'a'-10;
            }
            ++ptr;
            a = result.quot;
	}
        while (ptr < buffer+pad)
 80a4c56:	4423      	add	r3, r4
            *ptr++ = '0';
 80a4c58:	2230      	movs	r2, #48	; 0x30
 80a4c5a:	e00e      	b.n	80a4c7a <ultoa+0x34>
	div_t result;
	while(a){
            /* toolchain bug??
            result = div(a, radix);
            */
            result.quot = a/radix;
 80a4c5c:	fbb0 f6f2 	udiv	r6, r0, r2
            result.rem = a%radix;
 80a4c60:	fb02 0016 	mls	r0, r2, r6, r0
            *ptr = result.rem;
 80a4c64:	b2c1      	uxtb	r1, r0
            if(result.rem<10){
 80a4c66:	2809      	cmp	r0, #9
            /* toolchain bug??
            result = div(a, radix);
            */
            result.quot = a/radix;
            result.rem = a%radix;
            *ptr = result.rem;
 80a4c68:	f805 1b01 	strb.w	r1, [r5], #1
            if(result.rem<10){
                *ptr += '0';
 80a4c6c:	bf94      	ite	ls
 80a4c6e:	3130      	addls	r1, #48	; 0x30
            }else{
                *ptr += 'a'-10;
 80a4c70:	3157      	addhi	r1, #87	; 0x57
 80a4c72:	f805 1c01 	strb.w	r1, [r5, #-1]
            }
            ++ptr;
            a = result.quot;
 80a4c76:	4630      	mov	r0, r6
		return NULL;
	}
	char* ptr=buffer;

	div_t result;
	while(a){
 80a4c78:	e7eb      	b.n	80a4c52 <ultoa+0xc>
                *ptr += 'a'-10;
            }
            ++ptr;
            a = result.quot;
	}
        while (ptr < buffer+pad)
 80a4c7a:	4299      	cmp	r1, r3
 80a4c7c:	d202      	bcs.n	80a4c84 <ultoa+0x3e>
            *ptr++ = '0';
 80a4c7e:	f801 2b01 	strb.w	r2, [r1], #1
                *ptr += 'a'-10;
            }
            ++ptr;
            a = result.quot;
	}
        while (ptr < buffer+pad)
 80a4c82:	e7fa      	b.n	80a4c7a <ultoa+0x34>
            *ptr++ = '0';

	*ptr = '\0';
 80a4c84:	2300      	movs	r3, #0
	str_reverse(buffer);
 80a4c86:	4620      	mov	r0, r4
            a = result.quot;
	}
        while (ptr < buffer+pad)
            *ptr++ = '0';

	*ptr = '\0';
 80a4c88:	700b      	strb	r3, [r1, #0]
	str_reverse(buffer);
 80a4c8a:	f7ff ffcb 	bl	80a4c24 <_Z11str_reversePc>
	return buffer;
 80a4c8e:	4620      	mov	r0, r4
 80a4c90:	bd70      	pop	{r4, r5, r6, pc}
}

//convert unsigned long to string
__attribute__((weak)) char* ultoa(unsigned long a, char* buffer, int radix, char pad){
	if(radix<2 || radix>36){
		return NULL;
 80a4c92:	2000      	movs	r0, #0
            *ptr++ = '0';

	*ptr = '\0';
	str_reverse(buffer);
	return buffer;
}
 80a4c94:	bd70      	pop	{r4, r5, r6, pc}

080a4c96 <itoa>:

__attribute__((weak)) char* itoa(int a, char* buffer, int radix){
 80a4c96:	b538      	push	{r3, r4, r5, lr}
	if(a<0){
 80a4c98:	1e03      	subs	r3, r0, #0
	*ptr = '\0';
	str_reverse(buffer);
	return buffer;
}

__attribute__((weak)) char* itoa(int a, char* buffer, int radix){
 80a4c9a:	460c      	mov	r4, r1
 80a4c9c:	4615      	mov	r5, r2
	if(a<0){
 80a4c9e:	da0b      	bge.n	80a4cb8 <itoa+0x22>
		*buffer = '-';
		unsigned v = a==INT_MIN ? ((unsigned)INT_MAX+1) : -a;
 80a4ca0:	f1b3 4f00 	cmp.w	r3, #2147483648	; 0x80000000
	return buffer;
}

__attribute__((weak)) char* itoa(int a, char* buffer, int radix){
	if(a<0){
		*buffer = '-';
 80a4ca4:	f04f 022d 	mov.w	r2, #45	; 0x2d
		unsigned v = a==INT_MIN ? ((unsigned)INT_MAX+1) : -a;
 80a4ca8:	bf14      	ite	ne
 80a4caa:	4258      	negne	r0, r3
 80a4cac:	4618      	moveq	r0, r3
		ultoa((unsigned)v, buffer + 1, radix);
 80a4cae:	2301      	movs	r3, #1
	return buffer;
}

__attribute__((weak)) char* itoa(int a, char* buffer, int radix){
	if(a<0){
		*buffer = '-';
 80a4cb0:	700a      	strb	r2, [r1, #0]
		unsigned v = a==INT_MIN ? ((unsigned)INT_MAX+1) : -a;
		ultoa((unsigned)v, buffer + 1, radix);
 80a4cb2:	462a      	mov	r2, r5
 80a4cb4:	4419      	add	r1, r3
 80a4cb6:	e000      	b.n	80a4cba <itoa+0x24>
	}else{
		ultoa(a, buffer, radix);
 80a4cb8:	2301      	movs	r3, #1
 80a4cba:	f7ff ffc4 	bl	80a4c46 <ultoa>
	}
	return buffer;
}
 80a4cbe:	4620      	mov	r0, r4
 80a4cc0:	bd38      	pop	{r3, r4, r5, pc}

080a4cc2 <_ZN11SystemClass5resetEm>:
    reset(0);
}

void SystemClass::reset(uint32_t data)
{
    HAL_Core_System_Reset_Ex(RESET_REASON_USER, data, nullptr);
 80a4cc2:	4601      	mov	r1, r0
 80a4cc4:	2200      	movs	r2, #0
 80a4cc6:	208c      	movs	r0, #140	; 0x8c
 80a4cc8:	f7fe bdda 	b.w	80a3880 <HAL_Core_System_Reset_Ex>

080a4ccc <_ZN11SystemClass5resetEv>:
    HAL_Core_Enter_Bootloader(persist);
}

void SystemClass::reset(void)
{
    reset(0);
 80a4ccc:	2000      	movs	r0, #0
 80a4cce:	f7ff bff8 	b.w	80a4cc2 <_ZN11SystemClass5resetEm>
	...

080a4cd4 <_GLOBAL__sub_I_System>:
    WAKEUP_REASON_RTC = 2,
    WAKEUP_REASON_PIN_OR_RTC = 3
};

struct SleepResult {
    SleepResult() {}
 80a4cd4:	f64f 739c 	movw	r3, #65436	; 0xff9c
    return wokenUpByRtc();
}

system_error_t SleepResult::error() const {
    return err_;
}
 80a4cd8:	b537      	push	{r0, r1, r2, r4, r5, lr}
 80a4cda:	4c0d      	ldr	r4, [pc, #52]	; (80a4d10 <_GLOBAL__sub_I_System+0x3c>)
 80a4cdc:	2500      	movs	r5, #0
 80a4cde:	8063      	strh	r3, [r4, #2]
 80a4ce0:	f64f 73ff 	movw	r3, #65535	; 0xffff

class SystemClass {
public:

    SystemClass(System_Mode_TypeDef mode = DEFAULT) {
        set_system_mode(mode);
 80a4ce4:	4628      	mov	r0, r5
    WAKEUP_REASON_RTC = 2,
    WAKEUP_REASON_PIN_OR_RTC = 3
};

struct SleepResult {
    SleepResult() {}
 80a4ce6:	80a3      	strh	r3, [r4, #4]
 80a4ce8:	7025      	strb	r5, [r4, #0]

class SystemClass {
public:

    SystemClass(System_Mode_TypeDef mode = DEFAULT) {
        set_system_mode(mode);
 80a4cea:	f7fe fe91 	bl	80a3a10 <set_system_mode>
        return get_flag(flag) != 0;
    }

    inline int resetReason() const
    {
        int reason = RESET_REASON_NONE;
 80a4cee:	a802      	add	r0, sp, #8
 80a4cf0:	f840 5d04 	str.w	r5, [r0, #-4]!
        HAL_Core_Get_Last_Reset_Info(&reason, nullptr, nullptr);
 80a4cf4:	462a      	mov	r2, r5
 80a4cf6:	4629      	mov	r1, r5
 80a4cf8:	f7fe fdca 	bl	80a3890 <HAL_Core_Get_Last_Reset_Info>
        return reason;
 80a4cfc:	9b01      	ldr	r3, [sp, #4]
class SystemClass {
public:

    SystemClass(System_Mode_TypeDef mode = DEFAULT) {
        set_system_mode(mode);
        if (resetReason() == RESET_REASON_POWER_MANAGEMENT) {
 80a4cfe:	2b1e      	cmp	r3, #30
 80a4d00:	d104      	bne.n	80a4d0c <_GLOBAL__sub_I_System+0x38>
            // Woken up from standby mode
            sleepResult_ = SleepResult(WAKEUP_REASON_PIN_OR_RTC, SYSTEM_ERROR_NONE, WKP);
 80a4d02:	2303      	movs	r3, #3
 80a4d04:	7023      	strb	r3, [r4, #0]
 80a4d06:	2311      	movs	r3, #17
 80a4d08:	8065      	strh	r5, [r4, #2]
 80a4d0a:	80a3      	strh	r3, [r4, #4]
 80a4d0c:	b003      	add	sp, #12
 80a4d0e:	bd30      	pop	{r4, r5, pc}
 80a4d10:	20000d8c 	.word	0x20000d8c

080a4d14 <_ZN8SPIClassD1Ev>:
  Mutex mutex_;
#endif

public:
  SPIClass(HAL_SPI_Interface spi);
  virtual ~SPIClass() {};
 80a4d14:	4770      	bx	lr

080a4d16 <_ZN8SPIClassD0Ev>:
 80a4d16:	b510      	push	{r4, lr}
 80a4d18:	4604      	mov	r4, r0
 80a4d1a:	f7fb f9c2 	bl	80a00a2 <_ZdlPv>
 80a4d1e:	4620      	mov	r0, r4
 80a4d20:	bd10      	pop	{r4, pc}
	...

080a4d24 <_ZN8SPIClassC1E17HAL_SPI_Interface>:
  if (!info->enabled || info->default_settings)
    return particle::__SPISettings();
  return particle::__SPISettings(info->clock, info->bit_order, info->data_mode);
}

SPIClass::SPIClass(HAL_SPI_Interface spi)
 80a4d24:	b570      	push	{r4, r5, r6, lr}
 80a4d26:	4604      	mov	r4, r0
 80a4d28:	460e      	mov	r6, r1
 80a4d2a:	4b07      	ldr	r3, [pc, #28]	; (80a4d48 <_ZN8SPIClassC1E17HAL_SPI_Interface+0x24>)
    Mutex(os_mutex_t handle) : handle_(handle) {}

    /**
     * Creates a new mutex.
     */
    Mutex() : handle_(nullptr)
 80a4d2c:	2500      	movs	r5, #0
 80a4d2e:	6003      	str	r3, [r0, #0]
 80a4d30:	f840 5f0c 	str.w	r5, [r0, #12]!
    {
        os_mutex_create(&handle_);
 80a4d34:	f7fe fd94 	bl	80a3860 <os_mutex_create>
{
  _spi = spi;
  HAL_SPI_Init(_spi);
 80a4d38:	4630      	mov	r0, r6
  return particle::__SPISettings(info->clock, info->bit_order, info->data_mode);
}

SPIClass::SPIClass(HAL_SPI_Interface spi)
{
  _spi = spi;
 80a4d3a:	7126      	strb	r6, [r4, #4]
  HAL_SPI_Init(_spi);
 80a4d3c:	f7fe fe00 	bl	80a3940 <HAL_SPI_Init>
  dividerReference = SPI_CLK_SYSTEM;     // 0 indicates the system clock
 80a4d40:	60a5      	str	r5, [r4, #8]
}
 80a4d42:	4620      	mov	r0, r4
 80a4d44:	bd70      	pop	{r4, r5, r6, pc}
 80a4d46:	bf00      	nop
 80a4d48:	080a6bd0 	.word	0x080a6bd0

080a4d4c <_ZN8SPIClass9isEnabledEv>:
  //To Do
}

bool SPIClass::isEnabled()
{
  return HAL_SPI_Is_Enabled(_spi);
 80a4d4c:	7900      	ldrb	r0, [r0, #4]
 80a4d4e:	f7fe bdff 	b.w	80a3950 <HAL_SPI_Is_Enabled>

080a4d52 <_ZN6StringD1Ev>:
	init();
	char buf[33];
	dtoa(value, decimalPlaces, buf);
        *this = buf;
}
String::~String()
 80a4d52:	b510      	push	{r4, lr}
 80a4d54:	4604      	mov	r4, r0
{
	free(buffer);
 80a4d56:	6800      	ldr	r0, [r0, #0]
 80a4d58:	f7fe fe9e 	bl	80a3a98 <free>
}
 80a4d5c:	4620      	mov	r0, r4
 80a4d5e:	bd10      	pop	{r4, pc}

080a4d60 <_ZN6String10invalidateEv>:
	len = 0;
	flags = 0;
}

void String::invalidate(void)
{
 80a4d60:	b510      	push	{r4, lr}
 80a4d62:	4604      	mov	r4, r0
	if (buffer) free(buffer);
 80a4d64:	6800      	ldr	r0, [r0, #0]
 80a4d66:	b108      	cbz	r0, 80a4d6c <_ZN6String10invalidateEv+0xc>
 80a4d68:	f7fe fe96 	bl	80a3a98 <free>
	buffer = NULL;
 80a4d6c:	2300      	movs	r3, #0
 80a4d6e:	6023      	str	r3, [r4, #0]
	capacity = len = 0;
 80a4d70:	60a3      	str	r3, [r4, #8]
 80a4d72:	6063      	str	r3, [r4, #4]
 80a4d74:	bd10      	pop	{r4, pc}

080a4d76 <_ZN6String12changeBufferEj>:
	}
	return 0;
}

unsigned char String::changeBuffer(unsigned int maxStrLen)
{
 80a4d76:	b538      	push	{r3, r4, r5, lr}
 80a4d78:	4604      	mov	r4, r0
 80a4d7a:	460d      	mov	r5, r1
	char *newbuffer = (char *)realloc(buffer, maxStrLen + 1);
 80a4d7c:	6800      	ldr	r0, [r0, #0]
 80a4d7e:	3101      	adds	r1, #1
 80a4d80:	f7fe fe92 	bl	80a3aa8 <realloc>
	if (newbuffer) {
 80a4d84:	b110      	cbz	r0, 80a4d8c <_ZN6String12changeBufferEj+0x16>
		buffer = newbuffer;
		capacity = maxStrLen;
 80a4d86:	e884 0021 	stmia.w	r4, {r0, r5}
		return 1;
 80a4d8a:	2001      	movs	r0, #1
	}
	return 0;
}
 80a4d8c:	bd38      	pop	{r3, r4, r5, pc}

080a4d8e <_ZN6String7reserveEj>:
	buffer = NULL;
	capacity = len = 0;
}

unsigned char String::reserve(unsigned int size)
{
 80a4d8e:	b510      	push	{r4, lr}
	if (buffer && capacity >= size) return 1;
 80a4d90:	6803      	ldr	r3, [r0, #0]
	buffer = NULL;
	capacity = len = 0;
}

unsigned char String::reserve(unsigned int size)
{
 80a4d92:	4604      	mov	r4, r0
	if (buffer && capacity >= size) return 1;
 80a4d94:	b113      	cbz	r3, 80a4d9c <_ZN6String7reserveEj+0xe>
 80a4d96:	6843      	ldr	r3, [r0, #4]
 80a4d98:	428b      	cmp	r3, r1
 80a4d9a:	d207      	bcs.n	80a4dac <_ZN6String7reserveEj+0x1e>
	if (changeBuffer(size)) {
 80a4d9c:	4620      	mov	r0, r4
 80a4d9e:	f7ff ffea 	bl	80a4d76 <_ZN6String12changeBufferEj>
 80a4da2:	b120      	cbz	r0, 80a4dae <_ZN6String7reserveEj+0x20>
		if (len == 0) buffer[0] = 0;
 80a4da4:	68a3      	ldr	r3, [r4, #8]
 80a4da6:	b90b      	cbnz	r3, 80a4dac <_ZN6String7reserveEj+0x1e>
 80a4da8:	6822      	ldr	r2, [r4, #0]
 80a4daa:	7013      	strb	r3, [r2, #0]
 80a4dac:	2001      	movs	r0, #1
		return 1;
	}
	return 0;
}
 80a4dae:	bd10      	pop	{r4, pc}

080a4db0 <_ZN6String4copyEPKcj>:
/*********************************************/
/*  Copy and Move                            */
/*********************************************/

String & String::copy(const char *cstr, unsigned int length)
{
 80a4db0:	b570      	push	{r4, r5, r6, lr}
 80a4db2:	460e      	mov	r6, r1
	if (!reserve(length)) {
 80a4db4:	4611      	mov	r1, r2
/*********************************************/
/*  Copy and Move                            */
/*********************************************/

String & String::copy(const char *cstr, unsigned int length)
{
 80a4db6:	4604      	mov	r4, r0
 80a4db8:	4615      	mov	r5, r2
	if (!reserve(length)) {
 80a4dba:	f7ff ffe8 	bl	80a4d8e <_ZN6String7reserveEj>
 80a4dbe:	b918      	cbnz	r0, 80a4dc8 <_ZN6String4copyEPKcj+0x18>
		invalidate();
 80a4dc0:	4620      	mov	r0, r4
 80a4dc2:	f7ff ffcd 	bl	80a4d60 <_ZN6String10invalidateEv>
		return *this;
 80a4dc6:	e009      	b.n	80a4ddc <_ZN6String4copyEPKcj+0x2c>
	}
	len = length;
	memcpy(buffer, cstr, length);
 80a4dc8:	462a      	mov	r2, r5
 80a4dca:	4631      	mov	r1, r6
{
	if (!reserve(length)) {
		invalidate();
		return *this;
	}
	len = length;
 80a4dcc:	60a5      	str	r5, [r4, #8]
	memcpy(buffer, cstr, length);
 80a4dce:	6820      	ldr	r0, [r4, #0]
 80a4dd0:	f001 f9dc 	bl	80a618c <memcpy>
	buffer[len] = 0;
 80a4dd4:	6822      	ldr	r2, [r4, #0]
 80a4dd6:	68a3      	ldr	r3, [r4, #8]
 80a4dd8:	2100      	movs	r1, #0
 80a4dda:	54d1      	strb	r1, [r2, r3]
	return *this;
}
 80a4ddc:	4620      	mov	r0, r4
 80a4dde:	bd70      	pop	{r4, r5, r6, pc}

080a4de0 <_ZN6StringC1EPK19__FlashStringHelper>:
{
	init();
	*this = value;
}

String::String(const __FlashStringHelper *pstr)
 80a4de0:	b538      	push	{r3, r4, r5, lr}
/*  Memory Management                        */
/*********************************************/

inline void String::init(void)
{
	buffer = NULL;
 80a4de2:	2300      	movs	r3, #0
{
	init();
	*this = value;
}

String::String(const __FlashStringHelper *pstr)
 80a4de4:	4604      	mov	r4, r0
/*  Memory Management                        */
/*********************************************/

inline void String::init(void)
{
	buffer = NULL;
 80a4de6:	6003      	str	r3, [r0, #0]
	capacity = 0;
 80a4de8:	6043      	str	r3, [r0, #4]
	len = 0;
 80a4dea:	6083      	str	r3, [r0, #8]
	flags = 0;
 80a4dec:	7303      	strb	r3, [r0, #12]

String::String(const __FlashStringHelper *pstr)
{
	init();
	const char* cstr = reinterpret_cast<const char*>(pstr);
	if (cstr) copy(cstr, strlen(cstr));
 80a4dee:	460d      	mov	r5, r1
 80a4df0:	b139      	cbz	r1, 80a4e02 <_ZN6StringC1EPK19__FlashStringHelper+0x22>
 80a4df2:	4608      	mov	r0, r1
 80a4df4:	f001 fa6d 	bl	80a62d2 <strlen>
 80a4df8:	4629      	mov	r1, r5
 80a4dfa:	4602      	mov	r2, r0
 80a4dfc:	4620      	mov	r0, r4
 80a4dfe:	f7ff ffd7 	bl	80a4db0 <_ZN6String4copyEPKcj>
}
 80a4e02:	4620      	mov	r0, r4
 80a4e04:	bd38      	pop	{r3, r4, r5, pc}

080a4e06 <_ZN6StringaSEPKc>:
	return *this;
}
#endif

String & String::operator = (const char *cstr)
{
 80a4e06:	b538      	push	{r3, r4, r5, lr}
 80a4e08:	4605      	mov	r5, r0
	if (cstr) copy(cstr, strlen(cstr));
 80a4e0a:	460c      	mov	r4, r1
 80a4e0c:	b141      	cbz	r1, 80a4e20 <_ZN6StringaSEPKc+0x1a>
 80a4e0e:	4608      	mov	r0, r1
 80a4e10:	f001 fa5f 	bl	80a62d2 <strlen>
 80a4e14:	4621      	mov	r1, r4
 80a4e16:	4602      	mov	r2, r0
 80a4e18:	4628      	mov	r0, r5
 80a4e1a:	f7ff ffc9 	bl	80a4db0 <_ZN6String4copyEPKcj>
 80a4e1e:	e001      	b.n	80a4e24 <_ZN6StringaSEPKc+0x1e>
	else invalidate();
 80a4e20:	f7ff ff9e 	bl	80a4d60 <_ZN6String10invalidateEv>

	return *this;
}
 80a4e24:	4628      	mov	r0, r5
 80a4e26:	bd38      	pop	{r3, r4, r5, pc}

080a4e28 <_ZN6StringC1Eih>:
	char buf[9];
	utoa(value, buf, base);
	*this = buf;
}

String::String(int value, unsigned char base)
 80a4e28:	b510      	push	{r4, lr}
 80a4e2a:	4604      	mov	r4, r0
/*  Memory Management                        */
/*********************************************/

inline void String::init(void)
{
	buffer = NULL;
 80a4e2c:	2300      	movs	r3, #0
	char buf[9];
	utoa(value, buf, base);
	*this = buf;
}

String::String(int value, unsigned char base)
 80a4e2e:	b08a      	sub	sp, #40	; 0x28
/*  Memory Management                        */
/*********************************************/

inline void String::init(void)
{
	buffer = NULL;
 80a4e30:	6023      	str	r3, [r4, #0]
	capacity = 0;
 80a4e32:	6063      	str	r3, [r4, #4]
	len = 0;
 80a4e34:	60a3      	str	r3, [r4, #8]
	flags = 0;
 80a4e36:	7323      	strb	r3, [r4, #12]
	char buf[9];
	utoa(value, buf, base);
	*this = buf;
}

String::String(int value, unsigned char base)
 80a4e38:	4608      	mov	r0, r1
{
	init();
	char buf[34];
	itoa(value, buf, base);
 80a4e3a:	a901      	add	r1, sp, #4
 80a4e3c:	f7ff ff2b 	bl	80a4c96 <itoa>
	*this = buf;
 80a4e40:	a901      	add	r1, sp, #4
 80a4e42:	4620      	mov	r0, r4
 80a4e44:	f7ff ffdf 	bl	80a4e06 <_ZN6StringaSEPKc>
}
 80a4e48:	4620      	mov	r0, r4
 80a4e4a:	b00a      	add	sp, #40	; 0x28
 80a4e4c:	bd10      	pop	{r4, pc}

080a4e4e <_ZN6String6concatEPKcj>:
{
	return concat(s.buffer, s.len);
}

unsigned char String::concat(const char *cstr, unsigned int length)
{
 80a4e4e:	b570      	push	{r4, r5, r6, lr}
 80a4e50:	4604      	mov	r4, r0
	unsigned int newlen = len + length;
	if (!cstr) return 0;
 80a4e52:	460e      	mov	r6, r1
 80a4e54:	b909      	cbnz	r1, 80a4e5a <_ZN6String6concatEPKcj+0xc>
 80a4e56:	2000      	movs	r0, #0
 80a4e58:	bd70      	pop	{r4, r5, r6, pc}
	if (length == 0) return 1;
 80a4e5a:	b16a      	cbz	r2, 80a4e78 <_ZN6String6concatEPKcj+0x2a>
	return concat(s.buffer, s.len);
}

unsigned char String::concat(const char *cstr, unsigned int length)
{
	unsigned int newlen = len + length;
 80a4e5c:	6883      	ldr	r3, [r0, #8]
 80a4e5e:	18d5      	adds	r5, r2, r3
	if (!cstr) return 0;
	if (length == 0) return 1;
	if (!reserve(newlen)) return 0;
 80a4e60:	4629      	mov	r1, r5
 80a4e62:	f7ff ff94 	bl	80a4d8e <_ZN6String7reserveEj>
 80a4e66:	2800      	cmp	r0, #0
 80a4e68:	d0f5      	beq.n	80a4e56 <_ZN6String6concatEPKcj+0x8>
	strcpy(buffer + len, cstr);
 80a4e6a:	6820      	ldr	r0, [r4, #0]
 80a4e6c:	68a3      	ldr	r3, [r4, #8]
 80a4e6e:	4631      	mov	r1, r6
 80a4e70:	4418      	add	r0, r3
 80a4e72:	f001 fa0b 	bl	80a628c <strcpy>
	len = newlen;
 80a4e76:	60a5      	str	r5, [r4, #8]

unsigned char String::concat(const char *cstr, unsigned int length)
{
	unsigned int newlen = len + length;
	if (!cstr) return 0;
	if (length == 0) return 1;
 80a4e78:	2001      	movs	r0, #1
	if (!reserve(newlen)) return 0;
	strcpy(buffer + len, cstr);
	len = newlen;
	return 1;
}
 80a4e7a:	bd70      	pop	{r4, r5, r6, pc}

080a4e7c <_ZplRK15StringSumHelperRK6String>:
/*********************************************/
/*  Concatenate                              */
/*********************************************/

StringSumHelper & operator + (const StringSumHelper &lhs, const String &rhs)
{
 80a4e7c:	b510      	push	{r4, lr}
	StringSumHelper &a = const_cast<StringSumHelper&>(lhs);
	if (!a.concat(rhs.buffer, rhs.len)) a.invalidate();
 80a4e7e:	688a      	ldr	r2, [r1, #8]
 80a4e80:	6809      	ldr	r1, [r1, #0]
/*********************************************/
/*  Concatenate                              */
/*********************************************/

StringSumHelper & operator + (const StringSumHelper &lhs, const String &rhs)
{
 80a4e82:	4604      	mov	r4, r0
	StringSumHelper &a = const_cast<StringSumHelper&>(lhs);
	if (!a.concat(rhs.buffer, rhs.len)) a.invalidate();
 80a4e84:	f7ff ffe3 	bl	80a4e4e <_ZN6String6concatEPKcj>
 80a4e88:	b910      	cbnz	r0, 80a4e90 <_ZplRK15StringSumHelperRK6String+0x14>
 80a4e8a:	4620      	mov	r0, r4
 80a4e8c:	f7ff ff68 	bl	80a4d60 <_ZN6String10invalidateEv>
	return a;
}
 80a4e90:	4620      	mov	r0, r4
 80a4e92:	bd10      	pop	{r4, pc}

080a4e94 <_ZplRK15StringSumHelperPKc>:

StringSumHelper & operator + (const StringSumHelper &lhs, const char *cstr)
{
 80a4e94:	b538      	push	{r3, r4, r5, lr}
 80a4e96:	4604      	mov	r4, r0
	StringSumHelper &a = const_cast<StringSumHelper&>(lhs);
	if (!cstr || !a.concat(cstr, strlen(cstr))) a.invalidate();
 80a4e98:	460d      	mov	r5, r1
 80a4e9a:	b141      	cbz	r1, 80a4eae <_ZplRK15StringSumHelperPKc+0x1a>
 80a4e9c:	4608      	mov	r0, r1
 80a4e9e:	f001 fa18 	bl	80a62d2 <strlen>
 80a4ea2:	4629      	mov	r1, r5
 80a4ea4:	4602      	mov	r2, r0
 80a4ea6:	4620      	mov	r0, r4
 80a4ea8:	f7ff ffd1 	bl	80a4e4e <_ZN6String6concatEPKcj>
 80a4eac:	b910      	cbnz	r0, 80a4eb4 <_ZplRK15StringSumHelperPKc+0x20>
 80a4eae:	4620      	mov	r0, r4
 80a4eb0:	f7ff ff56 	bl	80a4d60 <_ZN6String10invalidateEv>
	return a;
}
 80a4eb4:	4620      	mov	r0, r4
 80a4eb6:	bd38      	pop	{r3, r4, r5, pc}

080a4eb8 <_ZNK6String9compareToERKS_>:
/*********************************************/
/*  Comparison                               */
/*********************************************/

int String::compareTo(const String &s) const
{
 80a4eb8:	4602      	mov	r2, r0
	if (!buffer || !s.buffer) {
 80a4eba:	6800      	ldr	r0, [r0, #0]
 80a4ebc:	680b      	ldr	r3, [r1, #0]
 80a4ebe:	b108      	cbz	r0, 80a4ec4 <_ZNK6String9compareToERKS_+0xc>
 80a4ec0:	b95b      	cbnz	r3, 80a4eda <_ZNK6String9compareToERKS_+0x22>
 80a4ec2:	e005      	b.n	80a4ed0 <_ZNK6String9compareToERKS_+0x18>
		if (s.buffer && s.len > 0) return 0 - *(unsigned char *)s.buffer;
 80a4ec4:	b123      	cbz	r3, 80a4ed0 <_ZNK6String9compareToERKS_+0x18>
 80a4ec6:	6889      	ldr	r1, [r1, #8]
 80a4ec8:	b111      	cbz	r1, 80a4ed0 <_ZNK6String9compareToERKS_+0x18>
 80a4eca:	7818      	ldrb	r0, [r3, #0]
 80a4ecc:	4240      	negs	r0, r0
 80a4ece:	4770      	bx	lr
		if (buffer && len > 0) return *(unsigned char *)buffer;
 80a4ed0:	b138      	cbz	r0, 80a4ee2 <_ZNK6String9compareToERKS_+0x2a>
 80a4ed2:	6893      	ldr	r3, [r2, #8]
 80a4ed4:	b123      	cbz	r3, 80a4ee0 <_ZNK6String9compareToERKS_+0x28>
 80a4ed6:	7800      	ldrb	r0, [r0, #0]
 80a4ed8:	4770      	bx	lr
		return 0;
	}
	return strcmp(buffer, s.buffer);
 80a4eda:	4619      	mov	r1, r3
 80a4edc:	f001 b9cc 	b.w	80a6278 <strcmp>
int String::compareTo(const String &s) const
{
	if (!buffer || !s.buffer) {
		if (s.buffer && s.len > 0) return 0 - *(unsigned char *)s.buffer;
		if (buffer && len > 0) return *(unsigned char *)buffer;
		return 0;
 80a4ee0:	4618      	mov	r0, r3
	}
	return strcmp(buffer, s.buffer);
}
 80a4ee2:	4770      	bx	lr

080a4ee4 <_ZNK6String6equalsERKS_>:

unsigned char String::equals(const String &s2) const
{
 80a4ee4:	b508      	push	{r3, lr}
	return (len == s2.len && compareTo(s2) == 0);
 80a4ee6:	6882      	ldr	r2, [r0, #8]
 80a4ee8:	688b      	ldr	r3, [r1, #8]
 80a4eea:	429a      	cmp	r2, r3
 80a4eec:	d105      	bne.n	80a4efa <_ZNK6String6equalsERKS_+0x16>
 80a4eee:	f7ff ffe3 	bl	80a4eb8 <_ZNK6String9compareToERKS_>
 80a4ef2:	fab0 f080 	clz	r0, r0
 80a4ef6:	0940      	lsrs	r0, r0, #5
 80a4ef8:	bd08      	pop	{r3, pc}
 80a4efa:	2000      	movs	r0, #0
}
 80a4efc:	bd08      	pop	{r3, pc}

080a4efe <_ZNK6String6equalsEPKc>:

unsigned char String::equals(const char *cstr) const
{
 80a4efe:	b508      	push	{r3, lr}
	if (len == 0) return (cstr == NULL || *cstr == 0);
 80a4f00:	6882      	ldr	r2, [r0, #8]
{
	return (len == s2.len && compareTo(s2) == 0);
}

unsigned char String::equals(const char *cstr) const
{
 80a4f02:	460b      	mov	r3, r1
	if (len == 0) return (cstr == NULL || *cstr == 0);
 80a4f04:	b912      	cbnz	r2, 80a4f0c <_ZNK6String6equalsEPKc+0xe>
 80a4f06:	b919      	cbnz	r1, 80a4f10 <_ZNK6String6equalsEPKc+0x12>
 80a4f08:	2001      	movs	r0, #1
 80a4f0a:	bd08      	pop	{r3, pc}
	if (cstr == NULL) return buffer[0] == 0;
 80a4f0c:	b911      	cbnz	r1, 80a4f14 <_ZNK6String6equalsEPKc+0x16>
 80a4f0e:	6803      	ldr	r3, [r0, #0]
 80a4f10:	7818      	ldrb	r0, [r3, #0]
 80a4f12:	e002      	b.n	80a4f1a <_ZNK6String6equalsEPKc+0x1c>
	return strcmp(buffer, cstr) == 0;
 80a4f14:	6800      	ldr	r0, [r0, #0]
 80a4f16:	f001 f9af 	bl	80a6278 <strcmp>
 80a4f1a:	fab0 f080 	clz	r0, r0
 80a4f1e:	0940      	lsrs	r0, r0, #5
}
 80a4f20:	bd08      	pop	{r3, pc}

080a4f22 <_ZN6String11toLowerCaseEv>:
	buffer[len] = 0;
        return *this;
}

String& String::toLowerCase(void)
{
 80a4f22:	b538      	push	{r3, r4, r5, lr}
	if (buffer) {
 80a4f24:	6804      	ldr	r4, [r0, #0]
	buffer[len] = 0;
        return *this;
}

String& String::toLowerCase(void)
{
 80a4f26:	4605      	mov	r5, r0
	if (buffer) {
 80a4f28:	b134      	cbz	r4, 80a4f38 <_ZN6String11toLowerCaseEv+0x16>
            for (char *p = buffer; *p; p++) {
 80a4f2a:	7820      	ldrb	r0, [r4, #0]
 80a4f2c:	b120      	cbz	r0, 80a4f38 <_ZN6String11toLowerCaseEv+0x16>
                    *p = tolower(*p);
 80a4f2e:	f001 fa99 	bl	80a6464 <tolower>
 80a4f32:	f804 0b01 	strb.w	r0, [r4], #1
}

String& String::toLowerCase(void)
{
	if (buffer) {
            for (char *p = buffer; *p; p++) {
 80a4f36:	e7f8      	b.n	80a4f2a <_ZN6String11toLowerCaseEv+0x8>
                    *p = tolower(*p);
            }
        }
        return *this;
}
 80a4f38:	4628      	mov	r0, r5
 80a4f3a:	bd38      	pop	{r3, r4, r5, pc}

080a4f3c <_ZN6String6formatEPKcz>:
    StringPrintableHelper help(*this);
    printable.printTo(help);
}

String String::format(const char* fmt, ...)
{
 80a4f3c:	b40e      	push	{r1, r2, r3}
 80a4f3e:	b5ff      	push	{r0, r1, r2, r3, r4, r5, r6, r7, lr}
 80a4f40:	ac09      	add	r4, sp, #36	; 0x24
 80a4f42:	f854 7b04 	ldr.w	r7, [r4], #4
 80a4f46:	4605      	mov	r5, r0
    va_list marker;
    va_start(marker, fmt);
    const int bufsize = 5;
    char test[bufsize];
    size_t n = vsnprintf(test, bufsize, fmt, marker);
 80a4f48:	4623      	mov	r3, r4
 80a4f4a:	463a      	mov	r2, r7
 80a4f4c:	2105      	movs	r1, #5
 80a4f4e:	a802      	add	r0, sp, #8
}

String String::format(const char* fmt, ...)
{
    va_list marker;
    va_start(marker, fmt);
 80a4f50:	9401      	str	r4, [sp, #4]
    const int bufsize = 5;
    char test[bufsize];
    size_t n = vsnprintf(test, bufsize, fmt, marker);
 80a4f52:	f7fe fdb1 	bl	80a3ab8 <vsnprintf>
 80a4f56:	4606      	mov	r6, r0
    va_end(marker);

    String result;
 80a4f58:	490b      	ldr	r1, [pc, #44]	; (80a4f88 <_ZN6String6formatEPKcz+0x4c>)
 80a4f5a:	4628      	mov	r0, r5
 80a4f5c:	f7ff ff40 	bl	80a4de0 <_ZN6StringC1EPK19__FlashStringHelper>
    result.reserve(n);  // internally adds +1 for null terminator
 80a4f60:	4631      	mov	r1, r6
 80a4f62:	4628      	mov	r0, r5
 80a4f64:	f7ff ff13 	bl	80a4d8e <_ZN6String7reserveEj>
    if (result.buffer) {
 80a4f68:	6828      	ldr	r0, [r5, #0]
 80a4f6a:	b130      	cbz	r0, 80a4f7a <_ZN6String6formatEPKcz+0x3e>
        va_start(marker, fmt);
        n = vsnprintf(result.buffer, n+1, fmt, marker);
 80a4f6c:	4623      	mov	r3, r4
 80a4f6e:	463a      	mov	r2, r7
 80a4f70:	1c71      	adds	r1, r6, #1
    va_end(marker);

    String result;
    result.reserve(n);  // internally adds +1 for null terminator
    if (result.buffer) {
        va_start(marker, fmt);
 80a4f72:	9401      	str	r4, [sp, #4]
        n = vsnprintf(result.buffer, n+1, fmt, marker);
 80a4f74:	f7fe fda0 	bl	80a3ab8 <vsnprintf>
        va_end(marker);
        result.len = n;
 80a4f78:	60a8      	str	r0, [r5, #8]
    }
    return result;
}
 80a4f7a:	4628      	mov	r0, r5
 80a4f7c:	b004      	add	sp, #16
 80a4f7e:	e8bd 40f0 	ldmia.w	sp!, {r4, r5, r6, r7, lr}
 80a4f82:	b003      	add	sp, #12
 80a4f84:	4770      	bx	lr
 80a4f86:	bf00      	nop
 80a4f88:	080a6a47 	.word	0x080a6a47

080a4f8c <_Z19__fetch_global_Wirev>:
#include "i2c_hal.h"

#ifndef SPARK_WIRING_NO_I2C

TwoWire& __fetch_global_Wire()
{
 80a4f8c:	b538      	push	{r3, r4, r5, lr}
	static TwoWire wire(HAL_I2C_INTERFACE1);
 80a4f8e:	4d0b      	ldr	r5, [pc, #44]	; (80a4fbc <_Z19__fetch_global_Wirev+0x30>)
 80a4f90:	6829      	ldr	r1, [r5, #0]
 80a4f92:	f011 0401 	ands.w	r4, r1, #1
 80a4f96:	d10f      	bne.n	80a4fb8 <_Z19__fetch_global_Wirev+0x2c>
 80a4f98:	4628      	mov	r0, r5
 80a4f9a:	f7fb f886 	bl	80a00aa <__cxa_guard_acquire>
 80a4f9e:	b158      	cbz	r0, 80a4fb8 <_Z19__fetch_global_Wirev+0x2c>
 80a4fa0:	4621      	mov	r1, r4
 80a4fa2:	4807      	ldr	r0, [pc, #28]	; (80a4fc0 <_Z19__fetch_global_Wirev+0x34>)
 80a4fa4:	f7fe fe28 	bl	80a3bf8 <_ZN7TwoWireC1E17HAL_I2C_Interface>
 80a4fa8:	4628      	mov	r0, r5
 80a4faa:	f7fb f883 	bl	80a00b4 <__cxa_guard_release>
 80a4fae:	4a05      	ldr	r2, [pc, #20]	; (80a4fc4 <_Z19__fetch_global_Wirev+0x38>)
 80a4fb0:	4905      	ldr	r1, [pc, #20]	; (80a4fc8 <_Z19__fetch_global_Wirev+0x3c>)
 80a4fb2:	4803      	ldr	r0, [pc, #12]	; (80a4fc0 <_Z19__fetch_global_Wirev+0x34>)
 80a4fb4:	f000 f8ea 	bl	80a518c <__aeabi_atexit>
	return wire;
}
 80a4fb8:	4801      	ldr	r0, [pc, #4]	; (80a4fc0 <_Z19__fetch_global_Wirev+0x34>)
 80a4fba:	bd38      	pop	{r3, r4, r5, pc}
 80a4fbc:	20000d94 	.word	0x20000d94
 80a4fc0:	20000d98 	.word	0x20000d98
 80a4fc4:	20000380 	.word	0x20000380
 80a4fc8:	080a3ba1 	.word	0x080a3ba1

080a4fcc <_GLOBAL__sub_I_INADDR_NONE>:
#include "spark_wiring_ipaddress.h"

const IPAddress INADDR_NONE(0, 0, 0, 0);
 80a4fcc:	b513      	push	{r0, r1, r4, lr}
 80a4fce:	4c08      	ldr	r4, [pc, #32]	; (80a4ff0 <_GLOBAL__sub_I_INADDR_NONE+0x24>)
 80a4fd0:	2300      	movs	r3, #0
 80a4fd2:	461a      	mov	r2, r3
 80a4fd4:	4619      	mov	r1, r3
 80a4fd6:	9300      	str	r3, [sp, #0]
 80a4fd8:	4620      	mov	r0, r4
 80a4fda:	f7fe ff19 	bl	80a3e10 <_ZN9IPAddressC1Ehhhh>
 80a4fde:	4620      	mov	r0, r4
 80a4fe0:	4a04      	ldr	r2, [pc, #16]	; (80a4ff4 <_GLOBAL__sub_I_INADDR_NONE+0x28>)
 80a4fe2:	4905      	ldr	r1, [pc, #20]	; (80a4ff8 <_GLOBAL__sub_I_INADDR_NONE+0x2c>)
 80a4fe4:	b002      	add	sp, #8
 80a4fe6:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
 80a4fea:	f000 b8cf 	b.w	80a518c <__aeabi_atexit>
 80a4fee:	bf00      	nop
 80a4ff0:	20000dac 	.word	0x20000dac
 80a4ff4:	20000380 	.word	0x20000380
 80a4ff8:	080a3d99 	.word	0x080a3d99

080a4ffc <_Z21__fetch_global_EEPROMv>:

// we don't use this global instance since there's no actual instance data
// Having this keeps the unoptimized build happy

EEPROMClass& __fetch_global_EEPROM()
{
 80a4ffc:	b510      	push	{r4, lr}
	static EEPROMClass eeprom;
 80a4ffe:	4c07      	ldr	r4, [pc, #28]	; (80a501c <_Z21__fetch_global_EEPROMv+0x20>)
 80a5000:	6823      	ldr	r3, [r4, #0]
 80a5002:	07db      	lsls	r3, r3, #31
 80a5004:	d408      	bmi.n	80a5018 <_Z21__fetch_global_EEPROMv+0x1c>
 80a5006:	4620      	mov	r0, r4
 80a5008:	f7fb f84f 	bl	80a00aa <__cxa_guard_acquire>
 80a500c:	b120      	cbz	r0, 80a5018 <_Z21__fetch_global_EEPROMv+0x1c>

struct EEPROMClass{

	EEPROMClass()
    {
    		HAL_EEPROM_Init();
 80a500e:	f7fe fc6f 	bl	80a38f0 <HAL_EEPROM_Init>
 80a5012:	4620      	mov	r0, r4
 80a5014:	f7fb f84e 	bl	80a00b4 <__cxa_guard_release>
	return eeprom;
}
 80a5018:	4801      	ldr	r0, [pc, #4]	; (80a5020 <_Z21__fetch_global_EEPROMv+0x24>)
 80a501a:	bd10      	pop	{r4, pc}
 80a501c:	20000dc4 	.word	0x20000dc4
 80a5020:	20000dc8 	.word	0x20000dc8

080a5024 <_ZN19ApplicationWatchdog4loopEv>:
	wd.loop();
	os_thread_cleanup(nullptr);
}

void ApplicationWatchdog::loop()
{
 80a5024:	b530      	push	{r4, r5, lr}
 80a5026:	4604      	mov	r4, r0
	bool done = false;
	system_tick_t now;
	while (!done) {
		HAL_Delay_Milliseconds(timeout);
		now = current_time();
		done = (now-last_checkin)>=timeout;
 80a5028:	4d1b      	ldr	r5, [pc, #108]	; (80a5098 <_ZN19ApplicationWatchdog4loopEv+0x74>)
	wd.loop();
	os_thread_cleanup(nullptr);
}

void ApplicationWatchdog::loop()
{
 80a502a:	b089      	sub	sp, #36	; 0x24
	bool done = false;
	system_tick_t now;
	while (!done) {
		HAL_Delay_Milliseconds(timeout);
 80a502c:	6820      	ldr	r0, [r4, #0]
 80a502e:	f7fe fc3f 	bl	80a38b0 <HAL_Delay_Milliseconds>
		return !timeout_fn;
	}

	static inline system_tick_t current_time()
	{
		return HAL_Timer_Get_Milli_Seconds();
 80a5032:	f7fe fc55 	bl	80a38e0 <HAL_Timer_Get_Milli_Seconds>
		now = current_time();
		done = (now-last_checkin)>=timeout;
 80a5036:	682b      	ldr	r3, [r5, #0]
 80a5038:	6822      	ldr	r2, [r4, #0]

void ApplicationWatchdog::loop()
{
	bool done = false;
	system_tick_t now;
	while (!done) {
 80a503a:	1ac0      	subs	r0, r0, r3
 80a503c:	4290      	cmp	r0, r2
 80a503e:	d3f5      	bcc.n	80a502c <_ZN19ApplicationWatchdog4loopEv+0x8>
		HAL_Delay_Milliseconds(timeout);
		now = current_time();
		done = (now-last_checkin)>=timeout;
	}

	if (timeout>0 && timeout_fn) {
 80a5040:	6823      	ldr	r3, [r4, #0]
 80a5042:	b333      	cbz	r3, 80a5092 <_ZN19ApplicationWatchdog4loopEv+0x6e>
 80a5044:	68e3      	ldr	r3, [r4, #12]
 80a5046:	b323      	cbz	r3, 80a5092 <_ZN19ApplicationWatchdog4loopEv+0x6e>
    function<_Res(_ArgTypes...)>::
    operator()(_ArgTypes... __args) const
    {
      if (_M_empty())
	__throw_bad_function_call();
      return _M_invoker(_M_functor, std::forward<_ArgTypes>(__args)...);
 80a5048:	1d25      	adds	r5, r4, #4
 80a504a:	6923      	ldr	r3, [r4, #16]
 80a504c:	4628      	mov	r0, r5
 80a504e:	4798      	blx	r3
	{
	  _Base::_M_init_functor(__functor, std::__addressof(__f.get()));
	}
      };

    _Function_base() : _M_manager(nullptr) { }
 80a5050:	2300      	movs	r3, #0
       *  Swap the targets of @c this function object and @a __f. This
       *  function will not throw an %exception.
       */
      void swap(function& __x)
      {
	std::swap(_M_functor, __x._M_functor);
 80a5052:	a904      	add	r1, sp, #16
 80a5054:	4668      	mov	r0, sp
	{
	  _Base::_M_init_functor(__functor, std::__addressof(__f.get()));
	}
      };

    _Function_base() : _M_manager(nullptr) { }
 80a5056:	9302      	str	r3, [sp, #8]
 80a5058:	9306      	str	r3, [sp, #24]
       *  Swap the targets of @c this function object and @a __f. This
       *  function will not throw an %exception.
       */
      void swap(function& __x)
      {
	std::swap(_M_functor, __x._M_functor);
 80a505a:	f7fe ff5d 	bl	80a3f18 <_ZSt4swapISt9_Any_dataEvRT_S2_>
#endif
    {
      // concept requirements
      __glibcxx_function_requires(_SGIAssignableConcept<_Tp>)

      _Tp __tmp = _GLIBCXX_MOVE(__a);
 80a505e:	9b02      	ldr	r3, [sp, #8]
      __a = _GLIBCXX_MOVE(__b);
 80a5060:	9a06      	ldr	r2, [sp, #24]
      __b = _GLIBCXX_MOVE(__tmp);
 80a5062:	9306      	str	r3, [sp, #24]
    {
      // concept requirements
      __glibcxx_function_requires(_SGIAssignableConcept<_Tp>)

      _Tp __tmp = _GLIBCXX_MOVE(__a);
      __a = _GLIBCXX_MOVE(__b);
 80a5064:	9202      	str	r2, [sp, #8]
#endif
    {
      // concept requirements
      __glibcxx_function_requires(_SGIAssignableConcept<_Tp>)

      _Tp __tmp = _GLIBCXX_MOVE(__a);
 80a5066:	9b03      	ldr	r3, [sp, #12]
      __a = _GLIBCXX_MOVE(__b);
 80a5068:	9a07      	ldr	r2, [sp, #28]
 80a506a:	4629      	mov	r1, r5
 80a506c:	a804      	add	r0, sp, #16
 80a506e:	9203      	str	r2, [sp, #12]
      __b = _GLIBCXX_MOVE(__tmp);
 80a5070:	9307      	str	r3, [sp, #28]
 80a5072:	f7fe ff51 	bl	80a3f18 <_ZSt4swapISt9_Any_dataEvRT_S2_>
#endif
    {
      // concept requirements
      __glibcxx_function_requires(_SGIAssignableConcept<_Tp>)

      _Tp __tmp = _GLIBCXX_MOVE(__a);
 80a5076:	9b06      	ldr	r3, [sp, #24]
      __a = _GLIBCXX_MOVE(__b);
 80a5078:	68e2      	ldr	r2, [r4, #12]
      __b = _GLIBCXX_MOVE(__tmp);
 80a507a:	60e3      	str	r3, [r4, #12]
#endif
    {
      // concept requirements
      __glibcxx_function_requires(_SGIAssignableConcept<_Tp>)

      _Tp __tmp = _GLIBCXX_MOVE(__a);
 80a507c:	9b07      	ldr	r3, [sp, #28]
      __a = _GLIBCXX_MOVE(__b);
 80a507e:	9206      	str	r2, [sp, #24]
 80a5080:	6922      	ldr	r2, [r4, #16]
   *  @ingroup functors
   *
   *  Polymorphic function wrapper.
   */
  template<typename _Res, typename... _ArgTypes>
    class function<_Res(_ArgTypes...)>
 80a5082:	a804      	add	r0, sp, #16
      __b = _GLIBCXX_MOVE(__tmp);
 80a5084:	6123      	str	r3, [r4, #16]
    {
      // concept requirements
      __glibcxx_function_requires(_SGIAssignableConcept<_Tp>)

      _Tp __tmp = _GLIBCXX_MOVE(__a);
      __a = _GLIBCXX_MOVE(__b);
 80a5086:	9207      	str	r2, [sp, #28]
 80a5088:	f7fb fa04 	bl	80a0494 <_ZNSt14_Function_baseD1Ev>
 80a508c:	4668      	mov	r0, sp
 80a508e:	f7fb fa01 	bl	80a0494 <_ZNSt14_Function_baseD1Ev>
		timeout_fn();
		timeout_fn = std::function<void(void)>();
	}
}
 80a5092:	b009      	add	sp, #36	; 0x24
 80a5094:	bd30      	pop	{r4, r5, pc}
 80a5096:	bf00      	nop
 80a5098:	20000dcc 	.word	0x20000dcc

080a509c <_ZN19ApplicationWatchdog5startEPv>:
#if PLATFORM_THREADING

volatile system_tick_t ApplicationWatchdog::last_checkin;

os_thread_return_t ApplicationWatchdog::start(void* pointer)
{
 80a509c:	b508      	push	{r3, lr}
	ApplicationWatchdog& wd = *(ApplicationWatchdog*)pointer;
	wd.loop();
 80a509e:	f7ff ffc1 	bl	80a5024 <_ZN19ApplicationWatchdog4loopEv>
	os_thread_cleanup(nullptr);
}
 80a50a2:	e8bd 4008 	ldmia.w	sp!, {r3, lr}

os_thread_return_t ApplicationWatchdog::start(void* pointer)
{
	ApplicationWatchdog& wd = *(ApplicationWatchdog*)pointer;
	wd.loop();
	os_thread_cleanup(nullptr);
 80a50a6:	2000      	movs	r0, #0
 80a50a8:	f7fe bbb2 	b.w	80a3810 <os_thread_cleanup>

080a50ac <_GLOBAL__sub_I_SPI>:
#ifndef SPARK_WIRING_NO_SPI

SPIClass SPI(HAL_SPI_INTERFACE1);

#if Wiring_SPI1
SPIClass SPI1(HAL_SPI_INTERFACE2);
 80a50ac:	b570      	push	{r4, r5, r6, lr}
#include "core_hal.h"
#include "spark_macros.h"

#ifndef SPARK_WIRING_NO_SPI

SPIClass SPI(HAL_SPI_INTERFACE1);
 80a50ae:	4c0c      	ldr	r4, [pc, #48]	; (80a50e0 <_GLOBAL__sub_I_SPI+0x34>)
 80a50b0:	4e0c      	ldr	r6, [pc, #48]	; (80a50e4 <_GLOBAL__sub_I_SPI+0x38>)
 80a50b2:	4d0d      	ldr	r5, [pc, #52]	; (80a50e8 <_GLOBAL__sub_I_SPI+0x3c>)
 80a50b4:	2100      	movs	r1, #0
 80a50b6:	4620      	mov	r0, r4
 80a50b8:	f7ff fe34 	bl	80a4d24 <_ZN8SPIClassC1E17HAL_SPI_Interface>
 80a50bc:	4620      	mov	r0, r4

#if Wiring_SPI1
SPIClass SPI1(HAL_SPI_INTERFACE2);
 80a50be:	4c0b      	ldr	r4, [pc, #44]	; (80a50ec <_GLOBAL__sub_I_SPI+0x40>)
#include "core_hal.h"
#include "spark_macros.h"

#ifndef SPARK_WIRING_NO_SPI

SPIClass SPI(HAL_SPI_INTERFACE1);
 80a50c0:	4632      	mov	r2, r6
 80a50c2:	4629      	mov	r1, r5
 80a50c4:	f000 f862 	bl	80a518c <__aeabi_atexit>

#if Wiring_SPI1
SPIClass SPI1(HAL_SPI_INTERFACE2);
 80a50c8:	2101      	movs	r1, #1
 80a50ca:	4620      	mov	r0, r4
 80a50cc:	f7ff fe2a 	bl	80a4d24 <_ZN8SPIClassC1E17HAL_SPI_Interface>
 80a50d0:	4632      	mov	r2, r6
 80a50d2:	4629      	mov	r1, r5
 80a50d4:	4620      	mov	r0, r4
 80a50d6:	e8bd 4070 	ldmia.w	sp!, {r4, r5, r6, lr}
 80a50da:	f000 b857 	b.w	80a518c <__aeabi_atexit>
 80a50de:	bf00      	nop
 80a50e0:	20000dd0 	.word	0x20000dd0
 80a50e4:	20000380 	.word	0x20000380
 80a50e8:	080a4d15 	.word	0x080a4d15
 80a50ec:	20000de0 	.word	0x20000de0

080a50f0 <pinAvailable>:

/*
 * @brief Perform safety check on desired pin to see if it's already
 * being used.  Return 0 if used, otherwise return 1 if available.
 */
bool pinAvailable(uint16_t pin) {
 80a50f0:	b510      	push	{r4, lr}
 80a50f2:	4604      	mov	r4, r0

  // SPI safety check
#ifndef SPARK_WIRING_NO_SPI
  if(SPI.isEnabled() == true && (pin == SCK || pin == MOSI || pin == MISO))
 80a50f4:	480f      	ldr	r0, [pc, #60]	; (80a5134 <pinAvailable+0x44>)
 80a50f6:	f7ff fe29 	bl	80a4d4c <_ZN8SPIClass9isEnabledEv>
 80a50fa:	b128      	cbz	r0, 80a5108 <pinAvailable+0x18>
 80a50fc:	f1a4 030d 	sub.w	r3, r4, #13
 80a5100:	2b02      	cmp	r3, #2
 80a5102:	d801      	bhi.n	80a5108 <pinAvailable+0x18>
  {
    return 0; // 'pin' is used
 80a5104:	2000      	movs	r0, #0
 80a5106:	bd10      	pop	{r4, pc}
  }
#endif
  // I2C safety check
#ifndef SPARK_WIRING_NO_I2C
  if(Wire.isEnabled() == true && (pin == SCL || pin == SDA))
 80a5108:	f7ff ff40 	bl	80a4f8c <_Z19__fetch_global_Wirev>
 80a510c:	f7fe fd86 	bl	80a3c1c <_ZN7TwoWire9isEnabledEv>
 80a5110:	b108      	cbz	r0, 80a5116 <pinAvailable+0x26>
 80a5112:	2c01      	cmp	r4, #1
 80a5114:	d9f6      	bls.n	80a5104 <pinAvailable+0x14>
    return 0; // 'pin' is used
  }
#endif
#ifndef SPARK_WIRING_NO_USART_SERIAL
  // Serial1 safety check
  if(Serial1.isEnabled() == true && (pin == RX || pin == TX))
 80a5116:	f7ff faf9 	bl	80a470c <_Z22__fetch_global_Serial1v>
 80a511a:	f7ff faf3 	bl	80a4704 <_ZN11USARTSerial9isEnabledEv>
 80a511e:	b118      	cbz	r0, 80a5128 <pinAvailable+0x38>
 80a5120:	f1a4 0312 	sub.w	r3, r4, #18
 80a5124:	2b01      	cmp	r3, #1
 80a5126:	d9ed      	bls.n	80a5104 <pinAvailable+0x14>
  {
    return 0; // 'pin' is used
  }
#endif

  if (pin >= TOTAL_PINS)
 80a5128:	2c17      	cmp	r4, #23
 80a512a:	bf8c      	ite	hi
 80a512c:	2000      	movhi	r0, #0
 80a512e:	2001      	movls	r0, #1
    return 0;
  else
    return 1; // 'pin' is available
}
 80a5130:	bd10      	pop	{r4, pc}
 80a5132:	bf00      	nop
 80a5134:	20000dd0 	.word	0x20000dd0

080a5138 <pinMode>:
 * or INPUT_PULLDOWN
 */
void pinMode(uint16_t pin, PinMode setMode)
{

  if(pin >= TOTAL_PINS || setMode == PIN_MODE_NONE )
 80a5138:	2817      	cmp	r0, #23
/*
 * @brief Set the mode of the pin to OUTPUT, INPUT, INPUT_PULLUP,
 * or INPUT_PULLDOWN
 */
void pinMode(uint16_t pin, PinMode setMode)
{
 80a513a:	b538      	push	{r3, r4, r5, lr}
 80a513c:	4604      	mov	r4, r0
 80a513e:	460d      	mov	r5, r1

  if(pin >= TOTAL_PINS || setMode == PIN_MODE_NONE )
 80a5140:	d80a      	bhi.n	80a5158 <pinMode+0x20>
 80a5142:	29ff      	cmp	r1, #255	; 0xff
 80a5144:	d008      	beq.n	80a5158 <pinMode+0x20>
  {
    return;
  }

  // Safety check
  if( !pinAvailable(pin) ) {
 80a5146:	f7ff ffd3 	bl	80a50f0 <pinAvailable>
 80a514a:	b128      	cbz	r0, 80a5158 <pinMode+0x20>
    return;
  }

  HAL_Pin_Mode(pin, setMode);
 80a514c:	4629      	mov	r1, r5
 80a514e:	4620      	mov	r0, r4
}
 80a5150:	e8bd 4038 	ldmia.w	sp!, {r3, r4, r5, lr}
  // Safety check
  if( !pinAvailable(pin) ) {
    return;
  }

  HAL_Pin_Mode(pin, setMode);
 80a5154:	f7fe bc14 	b.w	80a3980 <HAL_Pin_Mode>
 80a5158:	bd38      	pop	{r3, r4, r5, pc}

080a515a <analogRead>:
 * @brief Read the analog value of a pin.
 * Should return a 16-bit value, 0-65536 (0 = LOW, 65536 = HIGH)
 * Note: ADC is 12-bit. Currently it returns 0-4095
 */
int32_t analogRead(pin_t pin)
{
 80a515a:	b510      	push	{r4, lr}
 80a515c:	4604      	mov	r4, r0
  // Allow people to use 0-7 to define analog pins by checking to see if the values are too low.
  if(pin < FIRST_ANALOG_PIN)
 80a515e:	2809      	cmp	r0, #9
  {
    pin = pin + FIRST_ANALOG_PIN;
 80a5160:	bf9c      	itt	ls
 80a5162:	340a      	addls	r4, #10
 80a5164:	b2a4      	uxthls	r4, r4
  }

  // Safety check
  if( !pinAvailable(pin) ) {
 80a5166:	4620      	mov	r0, r4
 80a5168:	f7ff ffc2 	bl	80a50f0 <pinAvailable>
 80a516c:	b150      	cbz	r0, 80a5184 <analogRead+0x2a>
    return LOW;
  }

  if(HAL_Validate_Pin_Function(pin, PF_ADC)!=PF_ADC)
 80a516e:	2103      	movs	r1, #3
 80a5170:	4620      	mov	r0, r4
 80a5172:	f7fe fbfd 	bl	80a3970 <HAL_Validate_Pin_Function>
 80a5176:	2803      	cmp	r0, #3
 80a5178:	d104      	bne.n	80a5184 <analogRead+0x2a>
  {
    return LOW;
  }

  return HAL_ADC_Read(pin);
 80a517a:	4620      	mov	r0, r4
}
 80a517c:	e8bd 4010 	ldmia.w	sp!, {r4, lr}
  if(HAL_Validate_Pin_Function(pin, PF_ADC)!=PF_ADC)
  {
    return LOW;
  }

  return HAL_ADC_Read(pin);
 80a5180:	f7fe bc06 	b.w	80a3990 <HAL_ADC_Read>
}
 80a5184:	2000      	movs	r0, #0
 80a5186:	bd10      	pop	{r4, pc}

080a5188 <pulseIn>:
 */
uint32_t pulseIn(pin_t pin, uint16_t value) {

    // NO SAFETY CHECKS!!! WILD WILD WEST!!!

    return HAL_Pulse_In(pin, value);
 80a5188:	f7fe bc0a 	b.w	80a39a0 <HAL_Pulse_In>

080a518c <__aeabi_atexit>:
 80a518c:	460b      	mov	r3, r1
 80a518e:	4601      	mov	r1, r0
 80a5190:	4618      	mov	r0, r3
 80a5192:	f000 bfed 	b.w	80a6170 <__cxa_atexit>
	...

080a5198 <_ZSt15get_new_handlerv>:
 80a5198:	4b02      	ldr	r3, [pc, #8]	; (80a51a4 <_ZSt15get_new_handlerv+0xc>)
 80a519a:	6818      	ldr	r0, [r3, #0]
 80a519c:	f3bf 8f5f 	dmb	sy
 80a51a0:	4770      	bx	lr
 80a51a2:	bf00      	nop
 80a51a4:	20000df0 	.word	0x20000df0

080a51a8 <_ZnwjRKSt9nothrow_t>:
 80a51a8:	b510      	push	{r4, lr}
 80a51aa:	2800      	cmp	r0, #0
 80a51ac:	bf14      	ite	ne
 80a51ae:	4604      	movne	r4, r0
 80a51b0:	2401      	moveq	r4, #1
 80a51b2:	4620      	mov	r0, r4
 80a51b4:	f7fe fc68 	bl	80a3a88 <malloc>
 80a51b8:	b920      	cbnz	r0, 80a51c4 <_ZnwjRKSt9nothrow_t+0x1c>
 80a51ba:	f7ff ffed 	bl	80a5198 <_ZSt15get_new_handlerv>
 80a51be:	b108      	cbz	r0, 80a51c4 <_ZnwjRKSt9nothrow_t+0x1c>
 80a51c0:	4780      	blx	r0
 80a51c2:	e7f6      	b.n	80a51b2 <_ZnwjRKSt9nothrow_t+0xa>
 80a51c4:	bd10      	pop	{r4, pc}

080a51c6 <_ZSt25__throw_bad_function_callv>:
 80a51c6:	b508      	push	{r3, lr}
 80a51c8:	f7fe fc7e 	bl	80a3ac8 <abort>

080a51cc <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj>:
 80a51cc:	4b18      	ldr	r3, [pc, #96]	; (80a5230 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x64>)
 80a51ce:	681a      	ldr	r2, [r3, #0]
 80a51d0:	07d1      	lsls	r1, r2, #31
 80a51d2:	bf5c      	itt	pl
 80a51d4:	2201      	movpl	r2, #1
 80a51d6:	601a      	strpl	r2, [r3, #0]
 80a51d8:	4b16      	ldr	r3, [pc, #88]	; (80a5234 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x68>)
 80a51da:	681a      	ldr	r2, [r3, #0]
 80a51dc:	07d2      	lsls	r2, r2, #31
 80a51de:	bf5c      	itt	pl
 80a51e0:	2201      	movpl	r2, #1
 80a51e2:	601a      	strpl	r2, [r3, #0]
 80a51e4:	4b14      	ldr	r3, [pc, #80]	; (80a5238 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x6c>)
 80a51e6:	681a      	ldr	r2, [r3, #0]
 80a51e8:	07d0      	lsls	r0, r2, #31
 80a51ea:	bf5c      	itt	pl
 80a51ec:	2201      	movpl	r2, #1
 80a51ee:	601a      	strpl	r2, [r3, #0]
 80a51f0:	4b12      	ldr	r3, [pc, #72]	; (80a523c <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x70>)
 80a51f2:	681a      	ldr	r2, [r3, #0]
 80a51f4:	07d1      	lsls	r1, r2, #31
 80a51f6:	bf5c      	itt	pl
 80a51f8:	2201      	movpl	r2, #1
 80a51fa:	601a      	strpl	r2, [r3, #0]
 80a51fc:	4b10      	ldr	r3, [pc, #64]	; (80a5240 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x74>)
 80a51fe:	681a      	ldr	r2, [r3, #0]
 80a5200:	07d2      	lsls	r2, r2, #31
 80a5202:	bf5c      	itt	pl
 80a5204:	2201      	movpl	r2, #1
 80a5206:	601a      	strpl	r2, [r3, #0]
 80a5208:	4b0e      	ldr	r3, [pc, #56]	; (80a5244 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x78>)
 80a520a:	681a      	ldr	r2, [r3, #0]
 80a520c:	07d0      	lsls	r0, r2, #31
 80a520e:	bf5c      	itt	pl
 80a5210:	2201      	movpl	r2, #1
 80a5212:	601a      	strpl	r2, [r3, #0]
 80a5214:	4b0c      	ldr	r3, [pc, #48]	; (80a5248 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x7c>)
 80a5216:	681a      	ldr	r2, [r3, #0]
 80a5218:	07d1      	lsls	r1, r2, #31
 80a521a:	bf5c      	itt	pl
 80a521c:	2201      	movpl	r2, #1
 80a521e:	601a      	strpl	r2, [r3, #0]
 80a5220:	4b0a      	ldr	r3, [pc, #40]	; (80a524c <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x80>)
 80a5222:	681a      	ldr	r2, [r3, #0]
 80a5224:	07d2      	lsls	r2, r2, #31
 80a5226:	bf5c      	itt	pl
 80a5228:	2201      	movpl	r2, #1
 80a522a:	601a      	strpl	r2, [r3, #0]
 80a522c:	4770      	bx	lr
 80a522e:	bf00      	nop
 80a5230:	20000e10 	.word	0x20000e10
 80a5234:	20000e0c 	.word	0x20000e0c
 80a5238:	20000e08 	.word	0x20000e08
 80a523c:	20000e04 	.word	0x20000e04
 80a5240:	20000e00 	.word	0x20000e00
 80a5244:	20000dfc 	.word	0x20000dfc
 80a5248:	20000df8 	.word	0x20000df8
 80a524c:	20000df4 	.word	0x20000df4

080a5250 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj>:
 80a5250:	4b24      	ldr	r3, [pc, #144]	; (80a52e4 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj+0x94>)
 80a5252:	681a      	ldr	r2, [r3, #0]
 80a5254:	07d0      	lsls	r0, r2, #31
 80a5256:	bf5c      	itt	pl
 80a5258:	2201      	movpl	r2, #1
 80a525a:	601a      	strpl	r2, [r3, #0]
 80a525c:	4b22      	ldr	r3, [pc, #136]	; (80a52e8 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj+0x98>)
 80a525e:	681a      	ldr	r2, [r3, #0]
 80a5260:	07d1      	lsls	r1, r2, #31
 80a5262:	bf5c      	itt	pl
 80a5264:	2201      	movpl	r2, #1
 80a5266:	601a      	strpl	r2, [r3, #0]
 80a5268:	4b20      	ldr	r3, [pc, #128]	; (80a52ec <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj+0x9c>)
 80a526a:	681a      	ldr	r2, [r3, #0]
 80a526c:	07d2      	lsls	r2, r2, #31
 80a526e:	bf5c      	itt	pl
 80a5270:	2201      	movpl	r2, #1
 80a5272:	601a      	strpl	r2, [r3, #0]
 80a5274:	4b1e      	ldr	r3, [pc, #120]	; (80a52f0 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj+0xa0>)
 80a5276:	681a      	ldr	r2, [r3, #0]
 80a5278:	07d0      	lsls	r0, r2, #31
 80a527a:	bf5c      	itt	pl
 80a527c:	2201      	movpl	r2, #1
 80a527e:	601a      	strpl	r2, [r3, #0]
 80a5280:	4b1c      	ldr	r3, [pc, #112]	; (80a52f4 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj+0xa4>)
 80a5282:	681a      	ldr	r2, [r3, #0]
 80a5284:	07d1      	lsls	r1, r2, #31
 80a5286:	bf5c      	itt	pl
 80a5288:	2201      	movpl	r2, #1
 80a528a:	601a      	strpl	r2, [r3, #0]
 80a528c:	4b1a      	ldr	r3, [pc, #104]	; (80a52f8 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj+0xa8>)
 80a528e:	681a      	ldr	r2, [r3, #0]
 80a5290:	07d2      	lsls	r2, r2, #31
 80a5292:	bf5c      	itt	pl
 80a5294:	2201      	movpl	r2, #1
 80a5296:	601a      	strpl	r2, [r3, #0]
 80a5298:	4b18      	ldr	r3, [pc, #96]	; (80a52fc <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj+0xac>)
 80a529a:	681a      	ldr	r2, [r3, #0]
 80a529c:	07d0      	lsls	r0, r2, #31
 80a529e:	bf5c      	itt	pl
 80a52a0:	2201      	movpl	r2, #1
 80a52a2:	601a      	strpl	r2, [r3, #0]
 80a52a4:	4b16      	ldr	r3, [pc, #88]	; (80a5300 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj+0xb0>)
 80a52a6:	681a      	ldr	r2, [r3, #0]
 80a52a8:	07d1      	lsls	r1, r2, #31
 80a52aa:	bf5c      	itt	pl
 80a52ac:	2201      	movpl	r2, #1
 80a52ae:	601a      	strpl	r2, [r3, #0]
 80a52b0:	4b14      	ldr	r3, [pc, #80]	; (80a5304 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj+0xb4>)
 80a52b2:	681a      	ldr	r2, [r3, #0]
 80a52b4:	07d2      	lsls	r2, r2, #31
 80a52b6:	bf5c      	itt	pl
 80a52b8:	2201      	movpl	r2, #1
 80a52ba:	601a      	strpl	r2, [r3, #0]
 80a52bc:	4b12      	ldr	r3, [pc, #72]	; (80a5308 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj+0xb8>)
 80a52be:	681a      	ldr	r2, [r3, #0]
 80a52c0:	07d0      	lsls	r0, r2, #31
 80a52c2:	bf5c      	itt	pl
 80a52c4:	2201      	movpl	r2, #1
 80a52c6:	601a      	strpl	r2, [r3, #0]
 80a52c8:	4b10      	ldr	r3, [pc, #64]	; (80a530c <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj+0xbc>)
 80a52ca:	681a      	ldr	r2, [r3, #0]
 80a52cc:	07d1      	lsls	r1, r2, #31
 80a52ce:	bf5c      	itt	pl
 80a52d0:	2201      	movpl	r2, #1
 80a52d2:	601a      	strpl	r2, [r3, #0]
 80a52d4:	4b0e      	ldr	r3, [pc, #56]	; (80a5310 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKSsj+0xc0>)
 80a52d6:	681a      	ldr	r2, [r3, #0]
 80a52d8:	07d2      	lsls	r2, r2, #31
 80a52da:	bf5c      	itt	pl
 80a52dc:	2201      	movpl	r2, #1
 80a52de:	601a      	strpl	r2, [r3, #0]
 80a52e0:	4770      	bx	lr
 80a52e2:	bf00      	nop
 80a52e4:	20000e40 	.word	0x20000e40
 80a52e8:	20000e3c 	.word	0x20000e3c
 80a52ec:	20000e38 	.word	0x20000e38
 80a52f0:	20000e34 	.word	0x20000e34
 80a52f4:	20000e30 	.word	0x20000e30
 80a52f8:	20000e2c 	.word	0x20000e2c
 80a52fc:	20000e28 	.word	0x20000e28
 80a5300:	20000e24 	.word	0x20000e24
 80a5304:	20000e20 	.word	0x20000e20
 80a5308:	20000e1c 	.word	0x20000e1c
 80a530c:	20000e18 	.word	0x20000e18
 80a5310:	20000e14 	.word	0x20000e14

080a5314 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj>:
 80a5314:	4b24      	ldr	r3, [pc, #144]	; (80a53a8 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj+0x94>)
 80a5316:	681a      	ldr	r2, [r3, #0]
 80a5318:	07d0      	lsls	r0, r2, #31
 80a531a:	bf5c      	itt	pl
 80a531c:	2201      	movpl	r2, #1
 80a531e:	601a      	strpl	r2, [r3, #0]
 80a5320:	4b22      	ldr	r3, [pc, #136]	; (80a53ac <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj+0x98>)
 80a5322:	681a      	ldr	r2, [r3, #0]
 80a5324:	07d1      	lsls	r1, r2, #31
 80a5326:	bf5c      	itt	pl
 80a5328:	2201      	movpl	r2, #1
 80a532a:	601a      	strpl	r2, [r3, #0]
 80a532c:	4b20      	ldr	r3, [pc, #128]	; (80a53b0 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj+0x9c>)
 80a532e:	681a      	ldr	r2, [r3, #0]
 80a5330:	07d2      	lsls	r2, r2, #31
 80a5332:	bf5c      	itt	pl
 80a5334:	2201      	movpl	r2, #1
 80a5336:	601a      	strpl	r2, [r3, #0]
 80a5338:	4b1e      	ldr	r3, [pc, #120]	; (80a53b4 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj+0xa0>)
 80a533a:	681a      	ldr	r2, [r3, #0]
 80a533c:	07d0      	lsls	r0, r2, #31
 80a533e:	bf5c      	itt	pl
 80a5340:	2201      	movpl	r2, #1
 80a5342:	601a      	strpl	r2, [r3, #0]
 80a5344:	4b1c      	ldr	r3, [pc, #112]	; (80a53b8 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj+0xa4>)
 80a5346:	681a      	ldr	r2, [r3, #0]
 80a5348:	07d1      	lsls	r1, r2, #31
 80a534a:	bf5c      	itt	pl
 80a534c:	2201      	movpl	r2, #1
 80a534e:	601a      	strpl	r2, [r3, #0]
 80a5350:	4b1a      	ldr	r3, [pc, #104]	; (80a53bc <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj+0xa8>)
 80a5352:	681a      	ldr	r2, [r3, #0]
 80a5354:	07d2      	lsls	r2, r2, #31
 80a5356:	bf5c      	itt	pl
 80a5358:	2201      	movpl	r2, #1
 80a535a:	601a      	strpl	r2, [r3, #0]
 80a535c:	4b18      	ldr	r3, [pc, #96]	; (80a53c0 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj+0xac>)
 80a535e:	681a      	ldr	r2, [r3, #0]
 80a5360:	07d0      	lsls	r0, r2, #31
 80a5362:	bf5c      	itt	pl
 80a5364:	2201      	movpl	r2, #1
 80a5366:	601a      	strpl	r2, [r3, #0]
 80a5368:	4b16      	ldr	r3, [pc, #88]	; (80a53c4 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj+0xb0>)
 80a536a:	681a      	ldr	r2, [r3, #0]
 80a536c:	07d1      	lsls	r1, r2, #31
 80a536e:	bf5c      	itt	pl
 80a5370:	2201      	movpl	r2, #1
 80a5372:	601a      	strpl	r2, [r3, #0]
 80a5374:	4b14      	ldr	r3, [pc, #80]	; (80a53c8 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj+0xb4>)
 80a5376:	681a      	ldr	r2, [r3, #0]
 80a5378:	07d2      	lsls	r2, r2, #31
 80a537a:	bf5c      	itt	pl
 80a537c:	2201      	movpl	r2, #1
 80a537e:	601a      	strpl	r2, [r3, #0]
 80a5380:	4b12      	ldr	r3, [pc, #72]	; (80a53cc <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj+0xb8>)
 80a5382:	681a      	ldr	r2, [r3, #0]
 80a5384:	07d0      	lsls	r0, r2, #31
 80a5386:	bf5c      	itt	pl
 80a5388:	2201      	movpl	r2, #1
 80a538a:	601a      	strpl	r2, [r3, #0]
 80a538c:	4b10      	ldr	r3, [pc, #64]	; (80a53d0 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj+0xbc>)
 80a538e:	681a      	ldr	r2, [r3, #0]
 80a5390:	07d1      	lsls	r1, r2, #31
 80a5392:	bf5c      	itt	pl
 80a5394:	2201      	movpl	r2, #1
 80a5396:	601a      	strpl	r2, [r3, #0]
 80a5398:	4b0e      	ldr	r3, [pc, #56]	; (80a53d4 <_GLOBAL__sub_I__ZNSt12ctype_bynameIcEC2ERKSsj+0xc0>)
 80a539a:	681a      	ldr	r2, [r3, #0]
 80a539c:	07d2      	lsls	r2, r2, #31
 80a539e:	bf5c      	itt	pl
 80a53a0:	2201      	movpl	r2, #1
 80a53a2:	601a      	strpl	r2, [r3, #0]
 80a53a4:	4770      	bx	lr
 80a53a6:	bf00      	nop
 80a53a8:	20000e70 	.word	0x20000e70
 80a53ac:	20000e6c 	.word	0x20000e6c
 80a53b0:	20000e68 	.word	0x20000e68
 80a53b4:	20000e64 	.word	0x20000e64
 80a53b8:	20000e60 	.word	0x20000e60
 80a53bc:	20000e5c 	.word	0x20000e5c
 80a53c0:	20000e58 	.word	0x20000e58
 80a53c4:	20000e54 	.word	0x20000e54
 80a53c8:	20000e50 	.word	0x20000e50
 80a53cc:	20000e4c 	.word	0x20000e4c
 80a53d0:	20000e48 	.word	0x20000e48
 80a53d4:	20000e44 	.word	0x20000e44

080a53d8 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj>:
 80a53d8:	4b18      	ldr	r3, [pc, #96]	; (80a543c <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x64>)
 80a53da:	681a      	ldr	r2, [r3, #0]
 80a53dc:	07d1      	lsls	r1, r2, #31
 80a53de:	bf5c      	itt	pl
 80a53e0:	2201      	movpl	r2, #1
 80a53e2:	601a      	strpl	r2, [r3, #0]
 80a53e4:	4b16      	ldr	r3, [pc, #88]	; (80a5440 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x68>)
 80a53e6:	681a      	ldr	r2, [r3, #0]
 80a53e8:	07d2      	lsls	r2, r2, #31
 80a53ea:	bf5c      	itt	pl
 80a53ec:	2201      	movpl	r2, #1
 80a53ee:	601a      	strpl	r2, [r3, #0]
 80a53f0:	4b14      	ldr	r3, [pc, #80]	; (80a5444 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x6c>)
 80a53f2:	681a      	ldr	r2, [r3, #0]
 80a53f4:	07d0      	lsls	r0, r2, #31
 80a53f6:	bf5c      	itt	pl
 80a53f8:	2201      	movpl	r2, #1
 80a53fa:	601a      	strpl	r2, [r3, #0]
 80a53fc:	4b12      	ldr	r3, [pc, #72]	; (80a5448 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x70>)
 80a53fe:	681a      	ldr	r2, [r3, #0]
 80a5400:	07d1      	lsls	r1, r2, #31
 80a5402:	bf5c      	itt	pl
 80a5404:	2201      	movpl	r2, #1
 80a5406:	601a      	strpl	r2, [r3, #0]
 80a5408:	4b10      	ldr	r3, [pc, #64]	; (80a544c <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x74>)
 80a540a:	681a      	ldr	r2, [r3, #0]
 80a540c:	07d2      	lsls	r2, r2, #31
 80a540e:	bf5c      	itt	pl
 80a5410:	2201      	movpl	r2, #1
 80a5412:	601a      	strpl	r2, [r3, #0]
 80a5414:	4b0e      	ldr	r3, [pc, #56]	; (80a5450 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x78>)
 80a5416:	681a      	ldr	r2, [r3, #0]
 80a5418:	07d0      	lsls	r0, r2, #31
 80a541a:	bf5c      	itt	pl
 80a541c:	2201      	movpl	r2, #1
 80a541e:	601a      	strpl	r2, [r3, #0]
 80a5420:	4b0c      	ldr	r3, [pc, #48]	; (80a5454 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x7c>)
 80a5422:	681a      	ldr	r2, [r3, #0]
 80a5424:	07d1      	lsls	r1, r2, #31
 80a5426:	bf5c      	itt	pl
 80a5428:	2201      	movpl	r2, #1
 80a542a:	601a      	strpl	r2, [r3, #0]
 80a542c:	4b0a      	ldr	r3, [pc, #40]	; (80a5458 <_GLOBAL__sub_I__ZNSt12ctype_bynameIwEC2ERKNSt7__cxx1112basic_stringIcSt11char_traitsIcESaIcEEEj+0x80>)
 80a542e:	681a      	ldr	r2, [r3, #0]
 80a5430:	07d2      	lsls	r2, r2, #31
 80a5432:	bf5c      	itt	pl
 80a5434:	2201      	movpl	r2, #1
 80a5436:	601a      	strpl	r2, [r3, #0]
 80a5438:	4770      	bx	lr
 80a543a:	bf00      	nop
 80a543c:	20000e90 	.word	0x20000e90
 80a5440:	20000e8c 	.word	0x20000e8c
 80a5444:	20000e88 	.word	0x20000e88
 80a5448:	20000e84 	.word	0x20000e84
 80a544c:	20000e80 	.word	0x20000e80
 80a5450:	20000e7c 	.word	0x20000e7c
 80a5454:	20000e78 	.word	0x20000e78
 80a5458:	20000e74 	.word	0x20000e74

080a545c <__aeabi_drsub>:
 80a545c:	f081 4100 	eor.w	r1, r1, #2147483648	; 0x80000000
 80a5460:	e002      	b.n	80a5468 <__adddf3>
 80a5462:	bf00      	nop

080a5464 <__aeabi_dsub>:
 80a5464:	f083 4300 	eor.w	r3, r3, #2147483648	; 0x80000000

080a5468 <__adddf3>:
 80a5468:	b530      	push	{r4, r5, lr}
 80a546a:	ea4f 0441 	mov.w	r4, r1, lsl #1
 80a546e:	ea4f 0543 	mov.w	r5, r3, lsl #1
 80a5472:	ea94 0f05 	teq	r4, r5
 80a5476:	bf08      	it	eq
 80a5478:	ea90 0f02 	teqeq	r0, r2
 80a547c:	bf1f      	itttt	ne
 80a547e:	ea54 0c00 	orrsne.w	ip, r4, r0
 80a5482:	ea55 0c02 	orrsne.w	ip, r5, r2
 80a5486:	ea7f 5c64 	mvnsne.w	ip, r4, asr #21
 80a548a:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 80a548e:	f000 80e2 	beq.w	80a5656 <__adddf3+0x1ee>
 80a5492:	ea4f 5454 	mov.w	r4, r4, lsr #21
 80a5496:	ebd4 5555 	rsbs	r5, r4, r5, lsr #21
 80a549a:	bfb8      	it	lt
 80a549c:	426d      	neglt	r5, r5
 80a549e:	dd0c      	ble.n	80a54ba <__adddf3+0x52>
 80a54a0:	442c      	add	r4, r5
 80a54a2:	ea80 0202 	eor.w	r2, r0, r2
 80a54a6:	ea81 0303 	eor.w	r3, r1, r3
 80a54aa:	ea82 0000 	eor.w	r0, r2, r0
 80a54ae:	ea83 0101 	eor.w	r1, r3, r1
 80a54b2:	ea80 0202 	eor.w	r2, r0, r2
 80a54b6:	ea81 0303 	eor.w	r3, r1, r3
 80a54ba:	2d36      	cmp	r5, #54	; 0x36
 80a54bc:	bf88      	it	hi
 80a54be:	bd30      	pophi	{r4, r5, pc}
 80a54c0:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 80a54c4:	ea4f 3101 	mov.w	r1, r1, lsl #12
 80a54c8:	f44f 1c80 	mov.w	ip, #1048576	; 0x100000
 80a54cc:	ea4c 3111 	orr.w	r1, ip, r1, lsr #12
 80a54d0:	d002      	beq.n	80a54d8 <__adddf3+0x70>
 80a54d2:	4240      	negs	r0, r0
 80a54d4:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 80a54d8:	f013 4f00 	tst.w	r3, #2147483648	; 0x80000000
 80a54dc:	ea4f 3303 	mov.w	r3, r3, lsl #12
 80a54e0:	ea4c 3313 	orr.w	r3, ip, r3, lsr #12
 80a54e4:	d002      	beq.n	80a54ec <__adddf3+0x84>
 80a54e6:	4252      	negs	r2, r2
 80a54e8:	eb63 0343 	sbc.w	r3, r3, r3, lsl #1
 80a54ec:	ea94 0f05 	teq	r4, r5
 80a54f0:	f000 80a7 	beq.w	80a5642 <__adddf3+0x1da>
 80a54f4:	f1a4 0401 	sub.w	r4, r4, #1
 80a54f8:	f1d5 0e20 	rsbs	lr, r5, #32
 80a54fc:	db0d      	blt.n	80a551a <__adddf3+0xb2>
 80a54fe:	fa02 fc0e 	lsl.w	ip, r2, lr
 80a5502:	fa22 f205 	lsr.w	r2, r2, r5
 80a5506:	1880      	adds	r0, r0, r2
 80a5508:	f141 0100 	adc.w	r1, r1, #0
 80a550c:	fa03 f20e 	lsl.w	r2, r3, lr
 80a5510:	1880      	adds	r0, r0, r2
 80a5512:	fa43 f305 	asr.w	r3, r3, r5
 80a5516:	4159      	adcs	r1, r3
 80a5518:	e00e      	b.n	80a5538 <__adddf3+0xd0>
 80a551a:	f1a5 0520 	sub.w	r5, r5, #32
 80a551e:	f10e 0e20 	add.w	lr, lr, #32
 80a5522:	2a01      	cmp	r2, #1
 80a5524:	fa03 fc0e 	lsl.w	ip, r3, lr
 80a5528:	bf28      	it	cs
 80a552a:	f04c 0c02 	orrcs.w	ip, ip, #2
 80a552e:	fa43 f305 	asr.w	r3, r3, r5
 80a5532:	18c0      	adds	r0, r0, r3
 80a5534:	eb51 71e3 	adcs.w	r1, r1, r3, asr #31
 80a5538:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 80a553c:	d507      	bpl.n	80a554e <__adddf3+0xe6>
 80a553e:	f04f 0e00 	mov.w	lr, #0
 80a5542:	f1dc 0c00 	rsbs	ip, ip, #0
 80a5546:	eb7e 0000 	sbcs.w	r0, lr, r0
 80a554a:	eb6e 0101 	sbc.w	r1, lr, r1
 80a554e:	f5b1 1f80 	cmp.w	r1, #1048576	; 0x100000
 80a5552:	d31b      	bcc.n	80a558c <__adddf3+0x124>
 80a5554:	f5b1 1f00 	cmp.w	r1, #2097152	; 0x200000
 80a5558:	d30c      	bcc.n	80a5574 <__adddf3+0x10c>
 80a555a:	0849      	lsrs	r1, r1, #1
 80a555c:	ea5f 0030 	movs.w	r0, r0, rrx
 80a5560:	ea4f 0c3c 	mov.w	ip, ip, rrx
 80a5564:	f104 0401 	add.w	r4, r4, #1
 80a5568:	ea4f 5244 	mov.w	r2, r4, lsl #21
 80a556c:	f512 0f80 	cmn.w	r2, #4194304	; 0x400000
 80a5570:	f080 809a 	bcs.w	80a56a8 <__adddf3+0x240>
 80a5574:	f1bc 4f00 	cmp.w	ip, #2147483648	; 0x80000000
 80a5578:	bf08      	it	eq
 80a557a:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 80a557e:	f150 0000 	adcs.w	r0, r0, #0
 80a5582:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 80a5586:	ea41 0105 	orr.w	r1, r1, r5
 80a558a:	bd30      	pop	{r4, r5, pc}
 80a558c:	ea5f 0c4c 	movs.w	ip, ip, lsl #1
 80a5590:	4140      	adcs	r0, r0
 80a5592:	eb41 0101 	adc.w	r1, r1, r1
 80a5596:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 80a559a:	f1a4 0401 	sub.w	r4, r4, #1
 80a559e:	d1e9      	bne.n	80a5574 <__adddf3+0x10c>
 80a55a0:	f091 0f00 	teq	r1, #0
 80a55a4:	bf04      	itt	eq
 80a55a6:	4601      	moveq	r1, r0
 80a55a8:	2000      	moveq	r0, #0
 80a55aa:	fab1 f381 	clz	r3, r1
 80a55ae:	bf08      	it	eq
 80a55b0:	3320      	addeq	r3, #32
 80a55b2:	f1a3 030b 	sub.w	r3, r3, #11
 80a55b6:	f1b3 0220 	subs.w	r2, r3, #32
 80a55ba:	da0c      	bge.n	80a55d6 <__adddf3+0x16e>
 80a55bc:	320c      	adds	r2, #12
 80a55be:	dd08      	ble.n	80a55d2 <__adddf3+0x16a>
 80a55c0:	f102 0c14 	add.w	ip, r2, #20
 80a55c4:	f1c2 020c 	rsb	r2, r2, #12
 80a55c8:	fa01 f00c 	lsl.w	r0, r1, ip
 80a55cc:	fa21 f102 	lsr.w	r1, r1, r2
 80a55d0:	e00c      	b.n	80a55ec <__adddf3+0x184>
 80a55d2:	f102 0214 	add.w	r2, r2, #20
 80a55d6:	bfd8      	it	le
 80a55d8:	f1c2 0c20 	rsble	ip, r2, #32
 80a55dc:	fa01 f102 	lsl.w	r1, r1, r2
 80a55e0:	fa20 fc0c 	lsr.w	ip, r0, ip
 80a55e4:	bfdc      	itt	le
 80a55e6:	ea41 010c 	orrle.w	r1, r1, ip
 80a55ea:	4090      	lslle	r0, r2
 80a55ec:	1ae4      	subs	r4, r4, r3
 80a55ee:	bfa2      	ittt	ge
 80a55f0:	eb01 5104 	addge.w	r1, r1, r4, lsl #20
 80a55f4:	4329      	orrge	r1, r5
 80a55f6:	bd30      	popge	{r4, r5, pc}
 80a55f8:	ea6f 0404 	mvn.w	r4, r4
 80a55fc:	3c1f      	subs	r4, #31
 80a55fe:	da1c      	bge.n	80a563a <__adddf3+0x1d2>
 80a5600:	340c      	adds	r4, #12
 80a5602:	dc0e      	bgt.n	80a5622 <__adddf3+0x1ba>
 80a5604:	f104 0414 	add.w	r4, r4, #20
 80a5608:	f1c4 0220 	rsb	r2, r4, #32
 80a560c:	fa20 f004 	lsr.w	r0, r0, r4
 80a5610:	fa01 f302 	lsl.w	r3, r1, r2
 80a5614:	ea40 0003 	orr.w	r0, r0, r3
 80a5618:	fa21 f304 	lsr.w	r3, r1, r4
 80a561c:	ea45 0103 	orr.w	r1, r5, r3
 80a5620:	bd30      	pop	{r4, r5, pc}
 80a5622:	f1c4 040c 	rsb	r4, r4, #12
 80a5626:	f1c4 0220 	rsb	r2, r4, #32
 80a562a:	fa20 f002 	lsr.w	r0, r0, r2
 80a562e:	fa01 f304 	lsl.w	r3, r1, r4
 80a5632:	ea40 0003 	orr.w	r0, r0, r3
 80a5636:	4629      	mov	r1, r5
 80a5638:	bd30      	pop	{r4, r5, pc}
 80a563a:	fa21 f004 	lsr.w	r0, r1, r4
 80a563e:	4629      	mov	r1, r5
 80a5640:	bd30      	pop	{r4, r5, pc}
 80a5642:	f094 0f00 	teq	r4, #0
 80a5646:	f483 1380 	eor.w	r3, r3, #1048576	; 0x100000
 80a564a:	bf06      	itte	eq
 80a564c:	f481 1180 	eoreq.w	r1, r1, #1048576	; 0x100000
 80a5650:	3401      	addeq	r4, #1
 80a5652:	3d01      	subne	r5, #1
 80a5654:	e74e      	b.n	80a54f4 <__adddf3+0x8c>
 80a5656:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 80a565a:	bf18      	it	ne
 80a565c:	ea7f 5c65 	mvnsne.w	ip, r5, asr #21
 80a5660:	d029      	beq.n	80a56b6 <__adddf3+0x24e>
 80a5662:	ea94 0f05 	teq	r4, r5
 80a5666:	bf08      	it	eq
 80a5668:	ea90 0f02 	teqeq	r0, r2
 80a566c:	d005      	beq.n	80a567a <__adddf3+0x212>
 80a566e:	ea54 0c00 	orrs.w	ip, r4, r0
 80a5672:	bf04      	itt	eq
 80a5674:	4619      	moveq	r1, r3
 80a5676:	4610      	moveq	r0, r2
 80a5678:	bd30      	pop	{r4, r5, pc}
 80a567a:	ea91 0f03 	teq	r1, r3
 80a567e:	bf1e      	ittt	ne
 80a5680:	2100      	movne	r1, #0
 80a5682:	2000      	movne	r0, #0
 80a5684:	bd30      	popne	{r4, r5, pc}
 80a5686:	ea5f 5c54 	movs.w	ip, r4, lsr #21
 80a568a:	d105      	bne.n	80a5698 <__adddf3+0x230>
 80a568c:	0040      	lsls	r0, r0, #1
 80a568e:	4149      	adcs	r1, r1
 80a5690:	bf28      	it	cs
 80a5692:	f041 4100 	orrcs.w	r1, r1, #2147483648	; 0x80000000
 80a5696:	bd30      	pop	{r4, r5, pc}
 80a5698:	f514 0480 	adds.w	r4, r4, #4194304	; 0x400000
 80a569c:	bf3c      	itt	cc
 80a569e:	f501 1180 	addcc.w	r1, r1, #1048576	; 0x100000
 80a56a2:	bd30      	popcc	{r4, r5, pc}
 80a56a4:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 80a56a8:	f045 41fe 	orr.w	r1, r5, #2130706432	; 0x7f000000
 80a56ac:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 80a56b0:	f04f 0000 	mov.w	r0, #0
 80a56b4:	bd30      	pop	{r4, r5, pc}
 80a56b6:	ea7f 5c64 	mvns.w	ip, r4, asr #21
 80a56ba:	bf1a      	itte	ne
 80a56bc:	4619      	movne	r1, r3
 80a56be:	4610      	movne	r0, r2
 80a56c0:	ea7f 5c65 	mvnseq.w	ip, r5, asr #21
 80a56c4:	bf1c      	itt	ne
 80a56c6:	460b      	movne	r3, r1
 80a56c8:	4602      	movne	r2, r0
 80a56ca:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 80a56ce:	bf06      	itte	eq
 80a56d0:	ea52 3503 	orrseq.w	r5, r2, r3, lsl #12
 80a56d4:	ea91 0f03 	teqeq	r1, r3
 80a56d8:	f441 2100 	orrne.w	r1, r1, #524288	; 0x80000
 80a56dc:	bd30      	pop	{r4, r5, pc}
 80a56de:	bf00      	nop

080a56e0 <__aeabi_ui2d>:
 80a56e0:	f090 0f00 	teq	r0, #0
 80a56e4:	bf04      	itt	eq
 80a56e6:	2100      	moveq	r1, #0
 80a56e8:	4770      	bxeq	lr
 80a56ea:	b530      	push	{r4, r5, lr}
 80a56ec:	f44f 6480 	mov.w	r4, #1024	; 0x400
 80a56f0:	f104 0432 	add.w	r4, r4, #50	; 0x32
 80a56f4:	f04f 0500 	mov.w	r5, #0
 80a56f8:	f04f 0100 	mov.w	r1, #0
 80a56fc:	e750      	b.n	80a55a0 <__adddf3+0x138>
 80a56fe:	bf00      	nop

080a5700 <__aeabi_i2d>:
 80a5700:	f090 0f00 	teq	r0, #0
 80a5704:	bf04      	itt	eq
 80a5706:	2100      	moveq	r1, #0
 80a5708:	4770      	bxeq	lr
 80a570a:	b530      	push	{r4, r5, lr}
 80a570c:	f44f 6480 	mov.w	r4, #1024	; 0x400
 80a5710:	f104 0432 	add.w	r4, r4, #50	; 0x32
 80a5714:	f010 4500 	ands.w	r5, r0, #2147483648	; 0x80000000
 80a5718:	bf48      	it	mi
 80a571a:	4240      	negmi	r0, r0
 80a571c:	f04f 0100 	mov.w	r1, #0
 80a5720:	e73e      	b.n	80a55a0 <__adddf3+0x138>
 80a5722:	bf00      	nop

080a5724 <__aeabi_f2d>:
 80a5724:	0042      	lsls	r2, r0, #1
 80a5726:	ea4f 01e2 	mov.w	r1, r2, asr #3
 80a572a:	ea4f 0131 	mov.w	r1, r1, rrx
 80a572e:	ea4f 7002 	mov.w	r0, r2, lsl #28
 80a5732:	bf1f      	itttt	ne
 80a5734:	f012 437f 	andsne.w	r3, r2, #4278190080	; 0xff000000
 80a5738:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
 80a573c:	f081 5160 	eorne.w	r1, r1, #939524096	; 0x38000000
 80a5740:	4770      	bxne	lr
 80a5742:	f092 0f00 	teq	r2, #0
 80a5746:	bf14      	ite	ne
 80a5748:	f093 4f7f 	teqne	r3, #4278190080	; 0xff000000
 80a574c:	4770      	bxeq	lr
 80a574e:	b530      	push	{r4, r5, lr}
 80a5750:	f44f 7460 	mov.w	r4, #896	; 0x380
 80a5754:	f001 4500 	and.w	r5, r1, #2147483648	; 0x80000000
 80a5758:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 80a575c:	e720      	b.n	80a55a0 <__adddf3+0x138>
 80a575e:	bf00      	nop

080a5760 <__aeabi_ul2d>:
 80a5760:	ea50 0201 	orrs.w	r2, r0, r1
 80a5764:	bf08      	it	eq
 80a5766:	4770      	bxeq	lr
 80a5768:	b530      	push	{r4, r5, lr}
 80a576a:	f04f 0500 	mov.w	r5, #0
 80a576e:	e00a      	b.n	80a5786 <__aeabi_l2d+0x16>

080a5770 <__aeabi_l2d>:
 80a5770:	ea50 0201 	orrs.w	r2, r0, r1
 80a5774:	bf08      	it	eq
 80a5776:	4770      	bxeq	lr
 80a5778:	b530      	push	{r4, r5, lr}
 80a577a:	f011 4500 	ands.w	r5, r1, #2147483648	; 0x80000000
 80a577e:	d502      	bpl.n	80a5786 <__aeabi_l2d+0x16>
 80a5780:	4240      	negs	r0, r0
 80a5782:	eb61 0141 	sbc.w	r1, r1, r1, lsl #1
 80a5786:	f44f 6480 	mov.w	r4, #1024	; 0x400
 80a578a:	f104 0432 	add.w	r4, r4, #50	; 0x32
 80a578e:	ea5f 5c91 	movs.w	ip, r1, lsr #22
 80a5792:	f43f aedc 	beq.w	80a554e <__adddf3+0xe6>
 80a5796:	f04f 0203 	mov.w	r2, #3
 80a579a:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 80a579e:	bf18      	it	ne
 80a57a0:	3203      	addne	r2, #3
 80a57a2:	ea5f 0cdc 	movs.w	ip, ip, lsr #3
 80a57a6:	bf18      	it	ne
 80a57a8:	3203      	addne	r2, #3
 80a57aa:	eb02 02dc 	add.w	r2, r2, ip, lsr #3
 80a57ae:	f1c2 0320 	rsb	r3, r2, #32
 80a57b2:	fa00 fc03 	lsl.w	ip, r0, r3
 80a57b6:	fa20 f002 	lsr.w	r0, r0, r2
 80a57ba:	fa01 fe03 	lsl.w	lr, r1, r3
 80a57be:	ea40 000e 	orr.w	r0, r0, lr
 80a57c2:	fa21 f102 	lsr.w	r1, r1, r2
 80a57c6:	4414      	add	r4, r2
 80a57c8:	e6c1      	b.n	80a554e <__adddf3+0xe6>
 80a57ca:	bf00      	nop

080a57cc <__aeabi_dmul>:
 80a57cc:	b570      	push	{r4, r5, r6, lr}
 80a57ce:	f04f 0cff 	mov.w	ip, #255	; 0xff
 80a57d2:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
 80a57d6:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 80a57da:	bf1d      	ittte	ne
 80a57dc:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 80a57e0:	ea94 0f0c 	teqne	r4, ip
 80a57e4:	ea95 0f0c 	teqne	r5, ip
 80a57e8:	f000 f8de 	bleq	80a59a8 <__aeabi_dmul+0x1dc>
 80a57ec:	442c      	add	r4, r5
 80a57ee:	ea81 0603 	eor.w	r6, r1, r3
 80a57f2:	ea21 514c 	bic.w	r1, r1, ip, lsl #21
 80a57f6:	ea23 534c 	bic.w	r3, r3, ip, lsl #21
 80a57fa:	ea50 3501 	orrs.w	r5, r0, r1, lsl #12
 80a57fe:	bf18      	it	ne
 80a5800:	ea52 3503 	orrsne.w	r5, r2, r3, lsl #12
 80a5804:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 80a5808:	f443 1380 	orr.w	r3, r3, #1048576	; 0x100000
 80a580c:	d038      	beq.n	80a5880 <__aeabi_dmul+0xb4>
 80a580e:	fba0 ce02 	umull	ip, lr, r0, r2
 80a5812:	f04f 0500 	mov.w	r5, #0
 80a5816:	fbe1 e502 	umlal	lr, r5, r1, r2
 80a581a:	f006 4200 	and.w	r2, r6, #2147483648	; 0x80000000
 80a581e:	fbe0 e503 	umlal	lr, r5, r0, r3
 80a5822:	f04f 0600 	mov.w	r6, #0
 80a5826:	fbe1 5603 	umlal	r5, r6, r1, r3
 80a582a:	f09c 0f00 	teq	ip, #0
 80a582e:	bf18      	it	ne
 80a5830:	f04e 0e01 	orrne.w	lr, lr, #1
 80a5834:	f1a4 04ff 	sub.w	r4, r4, #255	; 0xff
 80a5838:	f5b6 7f00 	cmp.w	r6, #512	; 0x200
 80a583c:	f564 7440 	sbc.w	r4, r4, #768	; 0x300
 80a5840:	d204      	bcs.n	80a584c <__aeabi_dmul+0x80>
 80a5842:	ea5f 0e4e 	movs.w	lr, lr, lsl #1
 80a5846:	416d      	adcs	r5, r5
 80a5848:	eb46 0606 	adc.w	r6, r6, r6
 80a584c:	ea42 21c6 	orr.w	r1, r2, r6, lsl #11
 80a5850:	ea41 5155 	orr.w	r1, r1, r5, lsr #21
 80a5854:	ea4f 20c5 	mov.w	r0, r5, lsl #11
 80a5858:	ea40 505e 	orr.w	r0, r0, lr, lsr #21
 80a585c:	ea4f 2ece 	mov.w	lr, lr, lsl #11
 80a5860:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
 80a5864:	bf88      	it	hi
 80a5866:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
 80a586a:	d81e      	bhi.n	80a58aa <__aeabi_dmul+0xde>
 80a586c:	f1be 4f00 	cmp.w	lr, #2147483648	; 0x80000000
 80a5870:	bf08      	it	eq
 80a5872:	ea5f 0e50 	movseq.w	lr, r0, lsr #1
 80a5876:	f150 0000 	adcs.w	r0, r0, #0
 80a587a:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 80a587e:	bd70      	pop	{r4, r5, r6, pc}
 80a5880:	f006 4600 	and.w	r6, r6, #2147483648	; 0x80000000
 80a5884:	ea46 0101 	orr.w	r1, r6, r1
 80a5888:	ea40 0002 	orr.w	r0, r0, r2
 80a588c:	ea81 0103 	eor.w	r1, r1, r3
 80a5890:	ebb4 045c 	subs.w	r4, r4, ip, lsr #1
 80a5894:	bfc2      	ittt	gt
 80a5896:	ebd4 050c 	rsbsgt	r5, r4, ip
 80a589a:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 80a589e:	bd70      	popgt	{r4, r5, r6, pc}
 80a58a0:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 80a58a4:	f04f 0e00 	mov.w	lr, #0
 80a58a8:	3c01      	subs	r4, #1
 80a58aa:	f300 80ab 	bgt.w	80a5a04 <__aeabi_dmul+0x238>
 80a58ae:	f114 0f36 	cmn.w	r4, #54	; 0x36
 80a58b2:	bfde      	ittt	le
 80a58b4:	2000      	movle	r0, #0
 80a58b6:	f001 4100 	andle.w	r1, r1, #2147483648	; 0x80000000
 80a58ba:	bd70      	pople	{r4, r5, r6, pc}
 80a58bc:	f1c4 0400 	rsb	r4, r4, #0
 80a58c0:	3c20      	subs	r4, #32
 80a58c2:	da35      	bge.n	80a5930 <__aeabi_dmul+0x164>
 80a58c4:	340c      	adds	r4, #12
 80a58c6:	dc1b      	bgt.n	80a5900 <__aeabi_dmul+0x134>
 80a58c8:	f104 0414 	add.w	r4, r4, #20
 80a58cc:	f1c4 0520 	rsb	r5, r4, #32
 80a58d0:	fa00 f305 	lsl.w	r3, r0, r5
 80a58d4:	fa20 f004 	lsr.w	r0, r0, r4
 80a58d8:	fa01 f205 	lsl.w	r2, r1, r5
 80a58dc:	ea40 0002 	orr.w	r0, r0, r2
 80a58e0:	f001 4200 	and.w	r2, r1, #2147483648	; 0x80000000
 80a58e4:	f021 4100 	bic.w	r1, r1, #2147483648	; 0x80000000
 80a58e8:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 80a58ec:	fa21 f604 	lsr.w	r6, r1, r4
 80a58f0:	eb42 0106 	adc.w	r1, r2, r6
 80a58f4:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 80a58f8:	bf08      	it	eq
 80a58fa:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 80a58fe:	bd70      	pop	{r4, r5, r6, pc}
 80a5900:	f1c4 040c 	rsb	r4, r4, #12
 80a5904:	f1c4 0520 	rsb	r5, r4, #32
 80a5908:	fa00 f304 	lsl.w	r3, r0, r4
 80a590c:	fa20 f005 	lsr.w	r0, r0, r5
 80a5910:	fa01 f204 	lsl.w	r2, r1, r4
 80a5914:	ea40 0002 	orr.w	r0, r0, r2
 80a5918:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 80a591c:	eb10 70d3 	adds.w	r0, r0, r3, lsr #31
 80a5920:	f141 0100 	adc.w	r1, r1, #0
 80a5924:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 80a5928:	bf08      	it	eq
 80a592a:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 80a592e:	bd70      	pop	{r4, r5, r6, pc}
 80a5930:	f1c4 0520 	rsb	r5, r4, #32
 80a5934:	fa00 f205 	lsl.w	r2, r0, r5
 80a5938:	ea4e 0e02 	orr.w	lr, lr, r2
 80a593c:	fa20 f304 	lsr.w	r3, r0, r4
 80a5940:	fa01 f205 	lsl.w	r2, r1, r5
 80a5944:	ea43 0302 	orr.w	r3, r3, r2
 80a5948:	fa21 f004 	lsr.w	r0, r1, r4
 80a594c:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 80a5950:	fa21 f204 	lsr.w	r2, r1, r4
 80a5954:	ea20 0002 	bic.w	r0, r0, r2
 80a5958:	eb00 70d3 	add.w	r0, r0, r3, lsr #31
 80a595c:	ea5e 0e43 	orrs.w	lr, lr, r3, lsl #1
 80a5960:	bf08      	it	eq
 80a5962:	ea20 70d3 	biceq.w	r0, r0, r3, lsr #31
 80a5966:	bd70      	pop	{r4, r5, r6, pc}
 80a5968:	f094 0f00 	teq	r4, #0
 80a596c:	d10f      	bne.n	80a598e <__aeabi_dmul+0x1c2>
 80a596e:	f001 4600 	and.w	r6, r1, #2147483648	; 0x80000000
 80a5972:	0040      	lsls	r0, r0, #1
 80a5974:	eb41 0101 	adc.w	r1, r1, r1
 80a5978:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 80a597c:	bf08      	it	eq
 80a597e:	3c01      	subeq	r4, #1
 80a5980:	d0f7      	beq.n	80a5972 <__aeabi_dmul+0x1a6>
 80a5982:	ea41 0106 	orr.w	r1, r1, r6
 80a5986:	f095 0f00 	teq	r5, #0
 80a598a:	bf18      	it	ne
 80a598c:	4770      	bxne	lr
 80a598e:	f003 4600 	and.w	r6, r3, #2147483648	; 0x80000000
 80a5992:	0052      	lsls	r2, r2, #1
 80a5994:	eb43 0303 	adc.w	r3, r3, r3
 80a5998:	f413 1f80 	tst.w	r3, #1048576	; 0x100000
 80a599c:	bf08      	it	eq
 80a599e:	3d01      	subeq	r5, #1
 80a59a0:	d0f7      	beq.n	80a5992 <__aeabi_dmul+0x1c6>
 80a59a2:	ea43 0306 	orr.w	r3, r3, r6
 80a59a6:	4770      	bx	lr
 80a59a8:	ea94 0f0c 	teq	r4, ip
 80a59ac:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 80a59b0:	bf18      	it	ne
 80a59b2:	ea95 0f0c 	teqne	r5, ip
 80a59b6:	d00c      	beq.n	80a59d2 <__aeabi_dmul+0x206>
 80a59b8:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 80a59bc:	bf18      	it	ne
 80a59be:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 80a59c2:	d1d1      	bne.n	80a5968 <__aeabi_dmul+0x19c>
 80a59c4:	ea81 0103 	eor.w	r1, r1, r3
 80a59c8:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 80a59cc:	f04f 0000 	mov.w	r0, #0
 80a59d0:	bd70      	pop	{r4, r5, r6, pc}
 80a59d2:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 80a59d6:	bf06      	itte	eq
 80a59d8:	4610      	moveq	r0, r2
 80a59da:	4619      	moveq	r1, r3
 80a59dc:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 80a59e0:	d019      	beq.n	80a5a16 <__aeabi_dmul+0x24a>
 80a59e2:	ea94 0f0c 	teq	r4, ip
 80a59e6:	d102      	bne.n	80a59ee <__aeabi_dmul+0x222>
 80a59e8:	ea50 3601 	orrs.w	r6, r0, r1, lsl #12
 80a59ec:	d113      	bne.n	80a5a16 <__aeabi_dmul+0x24a>
 80a59ee:	ea95 0f0c 	teq	r5, ip
 80a59f2:	d105      	bne.n	80a5a00 <__aeabi_dmul+0x234>
 80a59f4:	ea52 3603 	orrs.w	r6, r2, r3, lsl #12
 80a59f8:	bf1c      	itt	ne
 80a59fa:	4610      	movne	r0, r2
 80a59fc:	4619      	movne	r1, r3
 80a59fe:	d10a      	bne.n	80a5a16 <__aeabi_dmul+0x24a>
 80a5a00:	ea81 0103 	eor.w	r1, r1, r3
 80a5a04:	f001 4100 	and.w	r1, r1, #2147483648	; 0x80000000
 80a5a08:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
 80a5a0c:	f441 0170 	orr.w	r1, r1, #15728640	; 0xf00000
 80a5a10:	f04f 0000 	mov.w	r0, #0
 80a5a14:	bd70      	pop	{r4, r5, r6, pc}
 80a5a16:	f041 41fe 	orr.w	r1, r1, #2130706432	; 0x7f000000
 80a5a1a:	f441 0178 	orr.w	r1, r1, #16252928	; 0xf80000
 80a5a1e:	bd70      	pop	{r4, r5, r6, pc}

080a5a20 <__aeabi_ddiv>:
 80a5a20:	b570      	push	{r4, r5, r6, lr}
 80a5a22:	f04f 0cff 	mov.w	ip, #255	; 0xff
 80a5a26:	f44c 6ce0 	orr.w	ip, ip, #1792	; 0x700
 80a5a2a:	ea1c 5411 	ands.w	r4, ip, r1, lsr #20
 80a5a2e:	bf1d      	ittte	ne
 80a5a30:	ea1c 5513 	andsne.w	r5, ip, r3, lsr #20
 80a5a34:	ea94 0f0c 	teqne	r4, ip
 80a5a38:	ea95 0f0c 	teqne	r5, ip
 80a5a3c:	f000 f8a7 	bleq	80a5b8e <__aeabi_ddiv+0x16e>
 80a5a40:	eba4 0405 	sub.w	r4, r4, r5
 80a5a44:	ea81 0e03 	eor.w	lr, r1, r3
 80a5a48:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 80a5a4c:	ea4f 3101 	mov.w	r1, r1, lsl #12
 80a5a50:	f000 8088 	beq.w	80a5b64 <__aeabi_ddiv+0x144>
 80a5a54:	ea4f 3303 	mov.w	r3, r3, lsl #12
 80a5a58:	f04f 5580 	mov.w	r5, #268435456	; 0x10000000
 80a5a5c:	ea45 1313 	orr.w	r3, r5, r3, lsr #4
 80a5a60:	ea43 6312 	orr.w	r3, r3, r2, lsr #24
 80a5a64:	ea4f 2202 	mov.w	r2, r2, lsl #8
 80a5a68:	ea45 1511 	orr.w	r5, r5, r1, lsr #4
 80a5a6c:	ea45 6510 	orr.w	r5, r5, r0, lsr #24
 80a5a70:	ea4f 2600 	mov.w	r6, r0, lsl #8
 80a5a74:	f00e 4100 	and.w	r1, lr, #2147483648	; 0x80000000
 80a5a78:	429d      	cmp	r5, r3
 80a5a7a:	bf08      	it	eq
 80a5a7c:	4296      	cmpeq	r6, r2
 80a5a7e:	f144 04fd 	adc.w	r4, r4, #253	; 0xfd
 80a5a82:	f504 7440 	add.w	r4, r4, #768	; 0x300
 80a5a86:	d202      	bcs.n	80a5a8e <__aeabi_ddiv+0x6e>
 80a5a88:	085b      	lsrs	r3, r3, #1
 80a5a8a:	ea4f 0232 	mov.w	r2, r2, rrx
 80a5a8e:	1ab6      	subs	r6, r6, r2
 80a5a90:	eb65 0503 	sbc.w	r5, r5, r3
 80a5a94:	085b      	lsrs	r3, r3, #1
 80a5a96:	ea4f 0232 	mov.w	r2, r2, rrx
 80a5a9a:	f44f 1080 	mov.w	r0, #1048576	; 0x100000
 80a5a9e:	f44f 2c00 	mov.w	ip, #524288	; 0x80000
 80a5aa2:	ebb6 0e02 	subs.w	lr, r6, r2
 80a5aa6:	eb75 0e03 	sbcs.w	lr, r5, r3
 80a5aaa:	bf22      	ittt	cs
 80a5aac:	1ab6      	subcs	r6, r6, r2
 80a5aae:	4675      	movcs	r5, lr
 80a5ab0:	ea40 000c 	orrcs.w	r0, r0, ip
 80a5ab4:	085b      	lsrs	r3, r3, #1
 80a5ab6:	ea4f 0232 	mov.w	r2, r2, rrx
 80a5aba:	ebb6 0e02 	subs.w	lr, r6, r2
 80a5abe:	eb75 0e03 	sbcs.w	lr, r5, r3
 80a5ac2:	bf22      	ittt	cs
 80a5ac4:	1ab6      	subcs	r6, r6, r2
 80a5ac6:	4675      	movcs	r5, lr
 80a5ac8:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
 80a5acc:	085b      	lsrs	r3, r3, #1
 80a5ace:	ea4f 0232 	mov.w	r2, r2, rrx
 80a5ad2:	ebb6 0e02 	subs.w	lr, r6, r2
 80a5ad6:	eb75 0e03 	sbcs.w	lr, r5, r3
 80a5ada:	bf22      	ittt	cs
 80a5adc:	1ab6      	subcs	r6, r6, r2
 80a5ade:	4675      	movcs	r5, lr
 80a5ae0:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
 80a5ae4:	085b      	lsrs	r3, r3, #1
 80a5ae6:	ea4f 0232 	mov.w	r2, r2, rrx
 80a5aea:	ebb6 0e02 	subs.w	lr, r6, r2
 80a5aee:	eb75 0e03 	sbcs.w	lr, r5, r3
 80a5af2:	bf22      	ittt	cs
 80a5af4:	1ab6      	subcs	r6, r6, r2
 80a5af6:	4675      	movcs	r5, lr
 80a5af8:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
 80a5afc:	ea55 0e06 	orrs.w	lr, r5, r6
 80a5b00:	d018      	beq.n	80a5b34 <__aeabi_ddiv+0x114>
 80a5b02:	ea4f 1505 	mov.w	r5, r5, lsl #4
 80a5b06:	ea45 7516 	orr.w	r5, r5, r6, lsr #28
 80a5b0a:	ea4f 1606 	mov.w	r6, r6, lsl #4
 80a5b0e:	ea4f 03c3 	mov.w	r3, r3, lsl #3
 80a5b12:	ea43 7352 	orr.w	r3, r3, r2, lsr #29
 80a5b16:	ea4f 02c2 	mov.w	r2, r2, lsl #3
 80a5b1a:	ea5f 1c1c 	movs.w	ip, ip, lsr #4
 80a5b1e:	d1c0      	bne.n	80a5aa2 <__aeabi_ddiv+0x82>
 80a5b20:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 80a5b24:	d10b      	bne.n	80a5b3e <__aeabi_ddiv+0x11e>
 80a5b26:	ea41 0100 	orr.w	r1, r1, r0
 80a5b2a:	f04f 0000 	mov.w	r0, #0
 80a5b2e:	f04f 4c00 	mov.w	ip, #2147483648	; 0x80000000
 80a5b32:	e7b6      	b.n	80a5aa2 <__aeabi_ddiv+0x82>
 80a5b34:	f411 1f80 	tst.w	r1, #1048576	; 0x100000
 80a5b38:	bf04      	itt	eq
 80a5b3a:	4301      	orreq	r1, r0
 80a5b3c:	2000      	moveq	r0, #0
 80a5b3e:	f1b4 0cfd 	subs.w	ip, r4, #253	; 0xfd
 80a5b42:	bf88      	it	hi
 80a5b44:	f5bc 6fe0 	cmphi.w	ip, #1792	; 0x700
 80a5b48:	f63f aeaf 	bhi.w	80a58aa <__aeabi_dmul+0xde>
 80a5b4c:	ebb5 0c03 	subs.w	ip, r5, r3
 80a5b50:	bf04      	itt	eq
 80a5b52:	ebb6 0c02 	subseq.w	ip, r6, r2
 80a5b56:	ea5f 0c50 	movseq.w	ip, r0, lsr #1
 80a5b5a:	f150 0000 	adcs.w	r0, r0, #0
 80a5b5e:	eb41 5104 	adc.w	r1, r1, r4, lsl #20
 80a5b62:	bd70      	pop	{r4, r5, r6, pc}
 80a5b64:	f00e 4e00 	and.w	lr, lr, #2147483648	; 0x80000000
 80a5b68:	ea4e 3111 	orr.w	r1, lr, r1, lsr #12
 80a5b6c:	eb14 045c 	adds.w	r4, r4, ip, lsr #1
 80a5b70:	bfc2      	ittt	gt
 80a5b72:	ebd4 050c 	rsbsgt	r5, r4, ip
 80a5b76:	ea41 5104 	orrgt.w	r1, r1, r4, lsl #20
 80a5b7a:	bd70      	popgt	{r4, r5, r6, pc}
 80a5b7c:	f441 1180 	orr.w	r1, r1, #1048576	; 0x100000
 80a5b80:	f04f 0e00 	mov.w	lr, #0
 80a5b84:	3c01      	subs	r4, #1
 80a5b86:	e690      	b.n	80a58aa <__aeabi_dmul+0xde>
 80a5b88:	ea45 0e06 	orr.w	lr, r5, r6
 80a5b8c:	e68d      	b.n	80a58aa <__aeabi_dmul+0xde>
 80a5b8e:	ea0c 5513 	and.w	r5, ip, r3, lsr #20
 80a5b92:	ea94 0f0c 	teq	r4, ip
 80a5b96:	bf08      	it	eq
 80a5b98:	ea95 0f0c 	teqeq	r5, ip
 80a5b9c:	f43f af3b 	beq.w	80a5a16 <__aeabi_dmul+0x24a>
 80a5ba0:	ea94 0f0c 	teq	r4, ip
 80a5ba4:	d10a      	bne.n	80a5bbc <__aeabi_ddiv+0x19c>
 80a5ba6:	ea50 3401 	orrs.w	r4, r0, r1, lsl #12
 80a5baa:	f47f af34 	bne.w	80a5a16 <__aeabi_dmul+0x24a>
 80a5bae:	ea95 0f0c 	teq	r5, ip
 80a5bb2:	f47f af25 	bne.w	80a5a00 <__aeabi_dmul+0x234>
 80a5bb6:	4610      	mov	r0, r2
 80a5bb8:	4619      	mov	r1, r3
 80a5bba:	e72c      	b.n	80a5a16 <__aeabi_dmul+0x24a>
 80a5bbc:	ea95 0f0c 	teq	r5, ip
 80a5bc0:	d106      	bne.n	80a5bd0 <__aeabi_ddiv+0x1b0>
 80a5bc2:	ea52 3503 	orrs.w	r5, r2, r3, lsl #12
 80a5bc6:	f43f aefd 	beq.w	80a59c4 <__aeabi_dmul+0x1f8>
 80a5bca:	4610      	mov	r0, r2
 80a5bcc:	4619      	mov	r1, r3
 80a5bce:	e722      	b.n	80a5a16 <__aeabi_dmul+0x24a>
 80a5bd0:	ea50 0641 	orrs.w	r6, r0, r1, lsl #1
 80a5bd4:	bf18      	it	ne
 80a5bd6:	ea52 0643 	orrsne.w	r6, r2, r3, lsl #1
 80a5bda:	f47f aec5 	bne.w	80a5968 <__aeabi_dmul+0x19c>
 80a5bde:	ea50 0441 	orrs.w	r4, r0, r1, lsl #1
 80a5be2:	f47f af0d 	bne.w	80a5a00 <__aeabi_dmul+0x234>
 80a5be6:	ea52 0543 	orrs.w	r5, r2, r3, lsl #1
 80a5bea:	f47f aeeb 	bne.w	80a59c4 <__aeabi_dmul+0x1f8>
 80a5bee:	e712      	b.n	80a5a16 <__aeabi_dmul+0x24a>

080a5bf0 <__gedf2>:
 80a5bf0:	f04f 3cff 	mov.w	ip, #4294967295
 80a5bf4:	e006      	b.n	80a5c04 <__cmpdf2+0x4>
 80a5bf6:	bf00      	nop

080a5bf8 <__ledf2>:
 80a5bf8:	f04f 0c01 	mov.w	ip, #1
 80a5bfc:	e002      	b.n	80a5c04 <__cmpdf2+0x4>
 80a5bfe:	bf00      	nop

080a5c00 <__cmpdf2>:
 80a5c00:	f04f 0c01 	mov.w	ip, #1
 80a5c04:	f84d cd04 	str.w	ip, [sp, #-4]!
 80a5c08:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 80a5c0c:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 80a5c10:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 80a5c14:	bf18      	it	ne
 80a5c16:	ea7f 5c6c 	mvnsne.w	ip, ip, asr #21
 80a5c1a:	d01b      	beq.n	80a5c54 <__cmpdf2+0x54>
 80a5c1c:	b001      	add	sp, #4
 80a5c1e:	ea50 0c41 	orrs.w	ip, r0, r1, lsl #1
 80a5c22:	bf0c      	ite	eq
 80a5c24:	ea52 0c43 	orrseq.w	ip, r2, r3, lsl #1
 80a5c28:	ea91 0f03 	teqne	r1, r3
 80a5c2c:	bf02      	ittt	eq
 80a5c2e:	ea90 0f02 	teqeq	r0, r2
 80a5c32:	2000      	moveq	r0, #0
 80a5c34:	4770      	bxeq	lr
 80a5c36:	f110 0f00 	cmn.w	r0, #0
 80a5c3a:	ea91 0f03 	teq	r1, r3
 80a5c3e:	bf58      	it	pl
 80a5c40:	4299      	cmppl	r1, r3
 80a5c42:	bf08      	it	eq
 80a5c44:	4290      	cmpeq	r0, r2
 80a5c46:	bf2c      	ite	cs
 80a5c48:	17d8      	asrcs	r0, r3, #31
 80a5c4a:	ea6f 70e3 	mvncc.w	r0, r3, asr #31
 80a5c4e:	f040 0001 	orr.w	r0, r0, #1
 80a5c52:	4770      	bx	lr
 80a5c54:	ea4f 0c41 	mov.w	ip, r1, lsl #1
 80a5c58:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 80a5c5c:	d102      	bne.n	80a5c64 <__cmpdf2+0x64>
 80a5c5e:	ea50 3c01 	orrs.w	ip, r0, r1, lsl #12
 80a5c62:	d107      	bne.n	80a5c74 <__cmpdf2+0x74>
 80a5c64:	ea4f 0c43 	mov.w	ip, r3, lsl #1
 80a5c68:	ea7f 5c6c 	mvns.w	ip, ip, asr #21
 80a5c6c:	d1d6      	bne.n	80a5c1c <__cmpdf2+0x1c>
 80a5c6e:	ea52 3c03 	orrs.w	ip, r2, r3, lsl #12
 80a5c72:	d0d3      	beq.n	80a5c1c <__cmpdf2+0x1c>
 80a5c74:	f85d 0b04 	ldr.w	r0, [sp], #4
 80a5c78:	4770      	bx	lr
 80a5c7a:	bf00      	nop

080a5c7c <__aeabi_cdrcmple>:
 80a5c7c:	4684      	mov	ip, r0
 80a5c7e:	4610      	mov	r0, r2
 80a5c80:	4662      	mov	r2, ip
 80a5c82:	468c      	mov	ip, r1
 80a5c84:	4619      	mov	r1, r3
 80a5c86:	4663      	mov	r3, ip
 80a5c88:	e000      	b.n	80a5c8c <__aeabi_cdcmpeq>
 80a5c8a:	bf00      	nop

080a5c8c <__aeabi_cdcmpeq>:
 80a5c8c:	b501      	push	{r0, lr}
 80a5c8e:	f7ff ffb7 	bl	80a5c00 <__cmpdf2>
 80a5c92:	2800      	cmp	r0, #0
 80a5c94:	bf48      	it	mi
 80a5c96:	f110 0f00 	cmnmi.w	r0, #0
 80a5c9a:	bd01      	pop	{r0, pc}

080a5c9c <__aeabi_dcmpeq>:
 80a5c9c:	f84d ed08 	str.w	lr, [sp, #-8]!
 80a5ca0:	f7ff fff4 	bl	80a5c8c <__aeabi_cdcmpeq>
 80a5ca4:	bf0c      	ite	eq
 80a5ca6:	2001      	moveq	r0, #1
 80a5ca8:	2000      	movne	r0, #0
 80a5caa:	f85d fb08 	ldr.w	pc, [sp], #8
 80a5cae:	bf00      	nop

080a5cb0 <__aeabi_dcmplt>:
 80a5cb0:	f84d ed08 	str.w	lr, [sp, #-8]!
 80a5cb4:	f7ff ffea 	bl	80a5c8c <__aeabi_cdcmpeq>
 80a5cb8:	bf34      	ite	cc
 80a5cba:	2001      	movcc	r0, #1
 80a5cbc:	2000      	movcs	r0, #0
 80a5cbe:	f85d fb08 	ldr.w	pc, [sp], #8
 80a5cc2:	bf00      	nop

080a5cc4 <__aeabi_dcmple>:
 80a5cc4:	f84d ed08 	str.w	lr, [sp, #-8]!
 80a5cc8:	f7ff ffe0 	bl	80a5c8c <__aeabi_cdcmpeq>
 80a5ccc:	bf94      	ite	ls
 80a5cce:	2001      	movls	r0, #1
 80a5cd0:	2000      	movhi	r0, #0
 80a5cd2:	f85d fb08 	ldr.w	pc, [sp], #8
 80a5cd6:	bf00      	nop

080a5cd8 <__aeabi_dcmpge>:
 80a5cd8:	f84d ed08 	str.w	lr, [sp, #-8]!
 80a5cdc:	f7ff ffce 	bl	80a5c7c <__aeabi_cdrcmple>
 80a5ce0:	bf94      	ite	ls
 80a5ce2:	2001      	movls	r0, #1
 80a5ce4:	2000      	movhi	r0, #0
 80a5ce6:	f85d fb08 	ldr.w	pc, [sp], #8
 80a5cea:	bf00      	nop

080a5cec <__aeabi_dcmpgt>:
 80a5cec:	f84d ed08 	str.w	lr, [sp, #-8]!
 80a5cf0:	f7ff ffc4 	bl	80a5c7c <__aeabi_cdrcmple>
 80a5cf4:	bf34      	ite	cc
 80a5cf6:	2001      	movcc	r0, #1
 80a5cf8:	2000      	movcs	r0, #0
 80a5cfa:	f85d fb08 	ldr.w	pc, [sp], #8
 80a5cfe:	bf00      	nop

080a5d00 <__aeabi_d2iz>:
 80a5d00:	ea4f 0241 	mov.w	r2, r1, lsl #1
 80a5d04:	f512 1200 	adds.w	r2, r2, #2097152	; 0x200000
 80a5d08:	d215      	bcs.n	80a5d36 <__aeabi_d2iz+0x36>
 80a5d0a:	d511      	bpl.n	80a5d30 <__aeabi_d2iz+0x30>
 80a5d0c:	f46f 7378 	mvn.w	r3, #992	; 0x3e0
 80a5d10:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
 80a5d14:	d912      	bls.n	80a5d3c <__aeabi_d2iz+0x3c>
 80a5d16:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 80a5d1a:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 80a5d1e:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
 80a5d22:	f011 4f00 	tst.w	r1, #2147483648	; 0x80000000
 80a5d26:	fa23 f002 	lsr.w	r0, r3, r2
 80a5d2a:	bf18      	it	ne
 80a5d2c:	4240      	negne	r0, r0
 80a5d2e:	4770      	bx	lr
 80a5d30:	f04f 0000 	mov.w	r0, #0
 80a5d34:	4770      	bx	lr
 80a5d36:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
 80a5d3a:	d105      	bne.n	80a5d48 <__aeabi_d2iz+0x48>
 80a5d3c:	f011 4000 	ands.w	r0, r1, #2147483648	; 0x80000000
 80a5d40:	bf08      	it	eq
 80a5d42:	f06f 4000 	mvneq.w	r0, #2147483648	; 0x80000000
 80a5d46:	4770      	bx	lr
 80a5d48:	f04f 0000 	mov.w	r0, #0
 80a5d4c:	4770      	bx	lr
 80a5d4e:	bf00      	nop

080a5d50 <__aeabi_d2uiz>:
 80a5d50:	004a      	lsls	r2, r1, #1
 80a5d52:	d211      	bcs.n	80a5d78 <__aeabi_d2uiz+0x28>
 80a5d54:	f512 1200 	adds.w	r2, r2, #2097152	; 0x200000
 80a5d58:	d211      	bcs.n	80a5d7e <__aeabi_d2uiz+0x2e>
 80a5d5a:	d50d      	bpl.n	80a5d78 <__aeabi_d2uiz+0x28>
 80a5d5c:	f46f 7378 	mvn.w	r3, #992	; 0x3e0
 80a5d60:	ebb3 5262 	subs.w	r2, r3, r2, asr #21
 80a5d64:	d40e      	bmi.n	80a5d84 <__aeabi_d2uiz+0x34>
 80a5d66:	ea4f 23c1 	mov.w	r3, r1, lsl #11
 80a5d6a:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 80a5d6e:	ea43 5350 	orr.w	r3, r3, r0, lsr #21
 80a5d72:	fa23 f002 	lsr.w	r0, r3, r2
 80a5d76:	4770      	bx	lr
 80a5d78:	f04f 0000 	mov.w	r0, #0
 80a5d7c:	4770      	bx	lr
 80a5d7e:	ea50 3001 	orrs.w	r0, r0, r1, lsl #12
 80a5d82:	d102      	bne.n	80a5d8a <__aeabi_d2uiz+0x3a>
 80a5d84:	f04f 30ff 	mov.w	r0, #4294967295
 80a5d88:	4770      	bx	lr
 80a5d8a:	f04f 0000 	mov.w	r0, #0
 80a5d8e:	4770      	bx	lr

080a5d90 <__aeabi_fmul>:
 80a5d90:	f04f 0cff 	mov.w	ip, #255	; 0xff
 80a5d94:	ea1c 52d0 	ands.w	r2, ip, r0, lsr #23
 80a5d98:	bf1e      	ittt	ne
 80a5d9a:	ea1c 53d1 	andsne.w	r3, ip, r1, lsr #23
 80a5d9e:	ea92 0f0c 	teqne	r2, ip
 80a5da2:	ea93 0f0c 	teqne	r3, ip
 80a5da6:	d06f      	beq.n	80a5e88 <__aeabi_fmul+0xf8>
 80a5da8:	441a      	add	r2, r3
 80a5daa:	ea80 0c01 	eor.w	ip, r0, r1
 80a5dae:	0240      	lsls	r0, r0, #9
 80a5db0:	bf18      	it	ne
 80a5db2:	ea5f 2141 	movsne.w	r1, r1, lsl #9
 80a5db6:	d01e      	beq.n	80a5df6 <__aeabi_fmul+0x66>
 80a5db8:	f04f 6300 	mov.w	r3, #134217728	; 0x8000000
 80a5dbc:	ea43 1050 	orr.w	r0, r3, r0, lsr #5
 80a5dc0:	ea43 1151 	orr.w	r1, r3, r1, lsr #5
 80a5dc4:	fba0 3101 	umull	r3, r1, r0, r1
 80a5dc8:	f00c 4000 	and.w	r0, ip, #2147483648	; 0x80000000
 80a5dcc:	f5b1 0f00 	cmp.w	r1, #8388608	; 0x800000
 80a5dd0:	bf3e      	ittt	cc
 80a5dd2:	0049      	lslcc	r1, r1, #1
 80a5dd4:	ea41 71d3 	orrcc.w	r1, r1, r3, lsr #31
 80a5dd8:	005b      	lslcc	r3, r3, #1
 80a5dda:	ea40 0001 	orr.w	r0, r0, r1
 80a5dde:	f162 027f 	sbc.w	r2, r2, #127	; 0x7f
 80a5de2:	2afd      	cmp	r2, #253	; 0xfd
 80a5de4:	d81d      	bhi.n	80a5e22 <__aeabi_fmul+0x92>
 80a5de6:	f1b3 4f00 	cmp.w	r3, #2147483648	; 0x80000000
 80a5dea:	eb40 50c2 	adc.w	r0, r0, r2, lsl #23
 80a5dee:	bf08      	it	eq
 80a5df0:	f020 0001 	biceq.w	r0, r0, #1
 80a5df4:	4770      	bx	lr
 80a5df6:	f090 0f00 	teq	r0, #0
 80a5dfa:	f00c 4c00 	and.w	ip, ip, #2147483648	; 0x80000000
 80a5dfe:	bf08      	it	eq
 80a5e00:	0249      	lsleq	r1, r1, #9
 80a5e02:	ea4c 2050 	orr.w	r0, ip, r0, lsr #9
 80a5e06:	ea40 2051 	orr.w	r0, r0, r1, lsr #9
 80a5e0a:	3a7f      	subs	r2, #127	; 0x7f
 80a5e0c:	bfc2      	ittt	gt
 80a5e0e:	f1d2 03ff 	rsbsgt	r3, r2, #255	; 0xff
 80a5e12:	ea40 50c2 	orrgt.w	r0, r0, r2, lsl #23
 80a5e16:	4770      	bxgt	lr
 80a5e18:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 80a5e1c:	f04f 0300 	mov.w	r3, #0
 80a5e20:	3a01      	subs	r2, #1
 80a5e22:	dc5d      	bgt.n	80a5ee0 <__aeabi_fmul+0x150>
 80a5e24:	f112 0f19 	cmn.w	r2, #25
 80a5e28:	bfdc      	itt	le
 80a5e2a:	f000 4000 	andle.w	r0, r0, #2147483648	; 0x80000000
 80a5e2e:	4770      	bxle	lr
 80a5e30:	f1c2 0200 	rsb	r2, r2, #0
 80a5e34:	0041      	lsls	r1, r0, #1
 80a5e36:	fa21 f102 	lsr.w	r1, r1, r2
 80a5e3a:	f1c2 0220 	rsb	r2, r2, #32
 80a5e3e:	fa00 fc02 	lsl.w	ip, r0, r2
 80a5e42:	ea5f 0031 	movs.w	r0, r1, rrx
 80a5e46:	f140 0000 	adc.w	r0, r0, #0
 80a5e4a:	ea53 034c 	orrs.w	r3, r3, ip, lsl #1
 80a5e4e:	bf08      	it	eq
 80a5e50:	ea20 70dc 	biceq.w	r0, r0, ip, lsr #31
 80a5e54:	4770      	bx	lr
 80a5e56:	f092 0f00 	teq	r2, #0
 80a5e5a:	f000 4c00 	and.w	ip, r0, #2147483648	; 0x80000000
 80a5e5e:	bf02      	ittt	eq
 80a5e60:	0040      	lsleq	r0, r0, #1
 80a5e62:	f410 0f00 	tsteq.w	r0, #8388608	; 0x800000
 80a5e66:	3a01      	subeq	r2, #1
 80a5e68:	d0f9      	beq.n	80a5e5e <__aeabi_fmul+0xce>
 80a5e6a:	ea40 000c 	orr.w	r0, r0, ip
 80a5e6e:	f093 0f00 	teq	r3, #0
 80a5e72:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
 80a5e76:	bf02      	ittt	eq
 80a5e78:	0049      	lsleq	r1, r1, #1
 80a5e7a:	f411 0f00 	tsteq.w	r1, #8388608	; 0x800000
 80a5e7e:	3b01      	subeq	r3, #1
 80a5e80:	d0f9      	beq.n	80a5e76 <__aeabi_fmul+0xe6>
 80a5e82:	ea41 010c 	orr.w	r1, r1, ip
 80a5e86:	e78f      	b.n	80a5da8 <__aeabi_fmul+0x18>
 80a5e88:	ea0c 53d1 	and.w	r3, ip, r1, lsr #23
 80a5e8c:	ea92 0f0c 	teq	r2, ip
 80a5e90:	bf18      	it	ne
 80a5e92:	ea93 0f0c 	teqne	r3, ip
 80a5e96:	d00a      	beq.n	80a5eae <__aeabi_fmul+0x11e>
 80a5e98:	f030 4c00 	bics.w	ip, r0, #2147483648	; 0x80000000
 80a5e9c:	bf18      	it	ne
 80a5e9e:	f031 4c00 	bicsne.w	ip, r1, #2147483648	; 0x80000000
 80a5ea2:	d1d8      	bne.n	80a5e56 <__aeabi_fmul+0xc6>
 80a5ea4:	ea80 0001 	eor.w	r0, r0, r1
 80a5ea8:	f000 4000 	and.w	r0, r0, #2147483648	; 0x80000000
 80a5eac:	4770      	bx	lr
 80a5eae:	f090 0f00 	teq	r0, #0
 80a5eb2:	bf17      	itett	ne
 80a5eb4:	f090 4f00 	teqne	r0, #2147483648	; 0x80000000
 80a5eb8:	4608      	moveq	r0, r1
 80a5eba:	f091 0f00 	teqne	r1, #0
 80a5ebe:	f091 4f00 	teqne	r1, #2147483648	; 0x80000000
 80a5ec2:	d014      	beq.n	80a5eee <__aeabi_fmul+0x15e>
 80a5ec4:	ea92 0f0c 	teq	r2, ip
 80a5ec8:	d101      	bne.n	80a5ece <__aeabi_fmul+0x13e>
 80a5eca:	0242      	lsls	r2, r0, #9
 80a5ecc:	d10f      	bne.n	80a5eee <__aeabi_fmul+0x15e>
 80a5ece:	ea93 0f0c 	teq	r3, ip
 80a5ed2:	d103      	bne.n	80a5edc <__aeabi_fmul+0x14c>
 80a5ed4:	024b      	lsls	r3, r1, #9
 80a5ed6:	bf18      	it	ne
 80a5ed8:	4608      	movne	r0, r1
 80a5eda:	d108      	bne.n	80a5eee <__aeabi_fmul+0x15e>
 80a5edc:	ea80 0001 	eor.w	r0, r0, r1
 80a5ee0:	f000 4000 	and.w	r0, r0, #2147483648	; 0x80000000
 80a5ee4:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
 80a5ee8:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 80a5eec:	4770      	bx	lr
 80a5eee:	f040 40fe 	orr.w	r0, r0, #2130706432	; 0x7f000000
 80a5ef2:	f440 0040 	orr.w	r0, r0, #12582912	; 0xc00000
 80a5ef6:	4770      	bx	lr

080a5ef8 <__aeabi_fdiv>:
 80a5ef8:	f04f 0cff 	mov.w	ip, #255	; 0xff
 80a5efc:	ea1c 52d0 	ands.w	r2, ip, r0, lsr #23
 80a5f00:	bf1e      	ittt	ne
 80a5f02:	ea1c 53d1 	andsne.w	r3, ip, r1, lsr #23
 80a5f06:	ea92 0f0c 	teqne	r2, ip
 80a5f0a:	ea93 0f0c 	teqne	r3, ip
 80a5f0e:	d069      	beq.n	80a5fe4 <__aeabi_fdiv+0xec>
 80a5f10:	eba2 0203 	sub.w	r2, r2, r3
 80a5f14:	ea80 0c01 	eor.w	ip, r0, r1
 80a5f18:	0249      	lsls	r1, r1, #9
 80a5f1a:	ea4f 2040 	mov.w	r0, r0, lsl #9
 80a5f1e:	d037      	beq.n	80a5f90 <__aeabi_fdiv+0x98>
 80a5f20:	f04f 5380 	mov.w	r3, #268435456	; 0x10000000
 80a5f24:	ea43 1111 	orr.w	r1, r3, r1, lsr #4
 80a5f28:	ea43 1310 	orr.w	r3, r3, r0, lsr #4
 80a5f2c:	f00c 4000 	and.w	r0, ip, #2147483648	; 0x80000000
 80a5f30:	428b      	cmp	r3, r1
 80a5f32:	bf38      	it	cc
 80a5f34:	005b      	lslcc	r3, r3, #1
 80a5f36:	f142 027d 	adc.w	r2, r2, #125	; 0x7d
 80a5f3a:	f44f 0c00 	mov.w	ip, #8388608	; 0x800000
 80a5f3e:	428b      	cmp	r3, r1
 80a5f40:	bf24      	itt	cs
 80a5f42:	1a5b      	subcs	r3, r3, r1
 80a5f44:	ea40 000c 	orrcs.w	r0, r0, ip
 80a5f48:	ebb3 0f51 	cmp.w	r3, r1, lsr #1
 80a5f4c:	bf24      	itt	cs
 80a5f4e:	eba3 0351 	subcs.w	r3, r3, r1, lsr #1
 80a5f52:	ea40 005c 	orrcs.w	r0, r0, ip, lsr #1
 80a5f56:	ebb3 0f91 	cmp.w	r3, r1, lsr #2
 80a5f5a:	bf24      	itt	cs
 80a5f5c:	eba3 0391 	subcs.w	r3, r3, r1, lsr #2
 80a5f60:	ea40 009c 	orrcs.w	r0, r0, ip, lsr #2
 80a5f64:	ebb3 0fd1 	cmp.w	r3, r1, lsr #3
 80a5f68:	bf24      	itt	cs
 80a5f6a:	eba3 03d1 	subcs.w	r3, r3, r1, lsr #3
 80a5f6e:	ea40 00dc 	orrcs.w	r0, r0, ip, lsr #3
 80a5f72:	011b      	lsls	r3, r3, #4
 80a5f74:	bf18      	it	ne
 80a5f76:	ea5f 1c1c 	movsne.w	ip, ip, lsr #4
 80a5f7a:	d1e0      	bne.n	80a5f3e <__aeabi_fdiv+0x46>
 80a5f7c:	2afd      	cmp	r2, #253	; 0xfd
 80a5f7e:	f63f af50 	bhi.w	80a5e22 <__aeabi_fmul+0x92>
 80a5f82:	428b      	cmp	r3, r1
 80a5f84:	eb40 50c2 	adc.w	r0, r0, r2, lsl #23
 80a5f88:	bf08      	it	eq
 80a5f8a:	f020 0001 	biceq.w	r0, r0, #1
 80a5f8e:	4770      	bx	lr
 80a5f90:	f00c 4c00 	and.w	ip, ip, #2147483648	; 0x80000000
 80a5f94:	ea4c 2050 	orr.w	r0, ip, r0, lsr #9
 80a5f98:	327f      	adds	r2, #127	; 0x7f
 80a5f9a:	bfc2      	ittt	gt
 80a5f9c:	f1d2 03ff 	rsbsgt	r3, r2, #255	; 0xff
 80a5fa0:	ea40 50c2 	orrgt.w	r0, r0, r2, lsl #23
 80a5fa4:	4770      	bxgt	lr
 80a5fa6:	f440 0000 	orr.w	r0, r0, #8388608	; 0x800000
 80a5faa:	f04f 0300 	mov.w	r3, #0
 80a5fae:	3a01      	subs	r2, #1
 80a5fb0:	e737      	b.n	80a5e22 <__aeabi_fmul+0x92>
 80a5fb2:	f092 0f00 	teq	r2, #0
 80a5fb6:	f000 4c00 	and.w	ip, r0, #2147483648	; 0x80000000
 80a5fba:	bf02      	ittt	eq
 80a5fbc:	0040      	lsleq	r0, r0, #1
 80a5fbe:	f410 0f00 	tsteq.w	r0, #8388608	; 0x800000
 80a5fc2:	3a01      	subeq	r2, #1
 80a5fc4:	d0f9      	beq.n	80a5fba <__aeabi_fdiv+0xc2>
 80a5fc6:	ea40 000c 	orr.w	r0, r0, ip
 80a5fca:	f093 0f00 	teq	r3, #0
 80a5fce:	f001 4c00 	and.w	ip, r1, #2147483648	; 0x80000000
 80a5fd2:	bf02      	ittt	eq
 80a5fd4:	0049      	lsleq	r1, r1, #1
 80a5fd6:	f411 0f00 	tsteq.w	r1, #8388608	; 0x800000
 80a5fda:	3b01      	subeq	r3, #1
 80a5fdc:	d0f9      	beq.n	80a5fd2 <__aeabi_fdiv+0xda>
 80a5fde:	ea41 010c 	orr.w	r1, r1, ip
 80a5fe2:	e795      	b.n	80a5f10 <__aeabi_fdiv+0x18>
 80a5fe4:	ea0c 53d1 	and.w	r3, ip, r1, lsr #23
 80a5fe8:	ea92 0f0c 	teq	r2, ip
 80a5fec:	d108      	bne.n	80a6000 <__aeabi_fdiv+0x108>
 80a5fee:	0242      	lsls	r2, r0, #9
 80a5ff0:	f47f af7d 	bne.w	80a5eee <__aeabi_fmul+0x15e>
 80a5ff4:	ea93 0f0c 	teq	r3, ip
 80a5ff8:	f47f af70 	bne.w	80a5edc <__aeabi_fmul+0x14c>
 80a5ffc:	4608      	mov	r0, r1
 80a5ffe:	e776      	b.n	80a5eee <__aeabi_fmul+0x15e>
 80a6000:	ea93 0f0c 	teq	r3, ip
 80a6004:	d104      	bne.n	80a6010 <__aeabi_fdiv+0x118>
 80a6006:	024b      	lsls	r3, r1, #9
 80a6008:	f43f af4c 	beq.w	80a5ea4 <__aeabi_fmul+0x114>
 80a600c:	4608      	mov	r0, r1
 80a600e:	e76e      	b.n	80a5eee <__aeabi_fmul+0x15e>
 80a6010:	f030 4c00 	bics.w	ip, r0, #2147483648	; 0x80000000
 80a6014:	bf18      	it	ne
 80a6016:	f031 4c00 	bicsne.w	ip, r1, #2147483648	; 0x80000000
 80a601a:	d1ca      	bne.n	80a5fb2 <__aeabi_fdiv+0xba>
 80a601c:	f030 4200 	bics.w	r2, r0, #2147483648	; 0x80000000
 80a6020:	f47f af5c 	bne.w	80a5edc <__aeabi_fmul+0x14c>
 80a6024:	f031 4300 	bics.w	r3, r1, #2147483648	; 0x80000000
 80a6028:	f47f af3c 	bne.w	80a5ea4 <__aeabi_fmul+0x114>
 80a602c:	e75f      	b.n	80a5eee <__aeabi_fmul+0x15e>
 80a602e:	bf00      	nop

080a6030 <__gesf2>:
 80a6030:	f04f 3cff 	mov.w	ip, #4294967295
 80a6034:	e006      	b.n	80a6044 <__cmpsf2+0x4>
 80a6036:	bf00      	nop

080a6038 <__lesf2>:
 80a6038:	f04f 0c01 	mov.w	ip, #1
 80a603c:	e002      	b.n	80a6044 <__cmpsf2+0x4>
 80a603e:	bf00      	nop

080a6040 <__cmpsf2>:
 80a6040:	f04f 0c01 	mov.w	ip, #1
 80a6044:	f84d cd04 	str.w	ip, [sp, #-4]!
 80a6048:	ea4f 0240 	mov.w	r2, r0, lsl #1
 80a604c:	ea4f 0341 	mov.w	r3, r1, lsl #1
 80a6050:	ea7f 6c22 	mvns.w	ip, r2, asr #24
 80a6054:	bf18      	it	ne
 80a6056:	ea7f 6c23 	mvnsne.w	ip, r3, asr #24
 80a605a:	d011      	beq.n	80a6080 <__cmpsf2+0x40>
 80a605c:	b001      	add	sp, #4
 80a605e:	ea52 0c53 	orrs.w	ip, r2, r3, lsr #1
 80a6062:	bf18      	it	ne
 80a6064:	ea90 0f01 	teqne	r0, r1
 80a6068:	bf58      	it	pl
 80a606a:	ebb2 0003 	subspl.w	r0, r2, r3
 80a606e:	bf88      	it	hi
 80a6070:	17c8      	asrhi	r0, r1, #31
 80a6072:	bf38      	it	cc
 80a6074:	ea6f 70e1 	mvncc.w	r0, r1, asr #31
 80a6078:	bf18      	it	ne
 80a607a:	f040 0001 	orrne.w	r0, r0, #1
 80a607e:	4770      	bx	lr
 80a6080:	ea7f 6c22 	mvns.w	ip, r2, asr #24
 80a6084:	d102      	bne.n	80a608c <__cmpsf2+0x4c>
 80a6086:	ea5f 2c40 	movs.w	ip, r0, lsl #9
 80a608a:	d105      	bne.n	80a6098 <__cmpsf2+0x58>
 80a608c:	ea7f 6c23 	mvns.w	ip, r3, asr #24
 80a6090:	d1e4      	bne.n	80a605c <__cmpsf2+0x1c>
 80a6092:	ea5f 2c41 	movs.w	ip, r1, lsl #9
 80a6096:	d0e1      	beq.n	80a605c <__cmpsf2+0x1c>
 80a6098:	f85d 0b04 	ldr.w	r0, [sp], #4
 80a609c:	4770      	bx	lr
 80a609e:	bf00      	nop

080a60a0 <__aeabi_cfrcmple>:
 80a60a0:	4684      	mov	ip, r0
 80a60a2:	4608      	mov	r0, r1
 80a60a4:	4661      	mov	r1, ip
 80a60a6:	e7ff      	b.n	80a60a8 <__aeabi_cfcmpeq>

080a60a8 <__aeabi_cfcmpeq>:
 80a60a8:	b50f      	push	{r0, r1, r2, r3, lr}
 80a60aa:	f7ff ffc9 	bl	80a6040 <__cmpsf2>
 80a60ae:	2800      	cmp	r0, #0
 80a60b0:	bf48      	it	mi
 80a60b2:	f110 0f00 	cmnmi.w	r0, #0
 80a60b6:	bd0f      	pop	{r0, r1, r2, r3, pc}

080a60b8 <__aeabi_fcmpeq>:
 80a60b8:	f84d ed08 	str.w	lr, [sp, #-8]!
 80a60bc:	f7ff fff4 	bl	80a60a8 <__aeabi_cfcmpeq>
 80a60c0:	bf0c      	ite	eq
 80a60c2:	2001      	moveq	r0, #1
 80a60c4:	2000      	movne	r0, #0
 80a60c6:	f85d fb08 	ldr.w	pc, [sp], #8
 80a60ca:	bf00      	nop

080a60cc <__aeabi_fcmplt>:
 80a60cc:	f84d ed08 	str.w	lr, [sp, #-8]!
 80a60d0:	f7ff ffea 	bl	80a60a8 <__aeabi_cfcmpeq>
 80a60d4:	bf34      	ite	cc
 80a60d6:	2001      	movcc	r0, #1
 80a60d8:	2000      	movcs	r0, #0
 80a60da:	f85d fb08 	ldr.w	pc, [sp], #8
 80a60de:	bf00      	nop

080a60e0 <__aeabi_fcmple>:
 80a60e0:	f84d ed08 	str.w	lr, [sp, #-8]!
 80a60e4:	f7ff ffe0 	bl	80a60a8 <__aeabi_cfcmpeq>
 80a60e8:	bf94      	ite	ls
 80a60ea:	2001      	movls	r0, #1
 80a60ec:	2000      	movhi	r0, #0
 80a60ee:	f85d fb08 	ldr.w	pc, [sp], #8
 80a60f2:	bf00      	nop

080a60f4 <__aeabi_fcmpge>:
 80a60f4:	f84d ed08 	str.w	lr, [sp, #-8]!
 80a60f8:	f7ff ffd2 	bl	80a60a0 <__aeabi_cfrcmple>
 80a60fc:	bf94      	ite	ls
 80a60fe:	2001      	movls	r0, #1
 80a6100:	2000      	movhi	r0, #0
 80a6102:	f85d fb08 	ldr.w	pc, [sp], #8
 80a6106:	bf00      	nop

080a6108 <__aeabi_fcmpgt>:
 80a6108:	f84d ed08 	str.w	lr, [sp, #-8]!
 80a610c:	f7ff ffc8 	bl	80a60a0 <__aeabi_cfrcmple>
 80a6110:	bf34      	ite	cc
 80a6112:	2001      	movcc	r0, #1
 80a6114:	2000      	movcs	r0, #0
 80a6116:	f85d fb08 	ldr.w	pc, [sp], #8
 80a611a:	bf00      	nop

080a611c <__aeabi_f2iz>:
 80a611c:	ea4f 0240 	mov.w	r2, r0, lsl #1
 80a6120:	f1b2 4ffe 	cmp.w	r2, #2130706432	; 0x7f000000
 80a6124:	d30f      	bcc.n	80a6146 <__aeabi_f2iz+0x2a>
 80a6126:	f04f 039e 	mov.w	r3, #158	; 0x9e
 80a612a:	ebb3 6212 	subs.w	r2, r3, r2, lsr #24
 80a612e:	d90d      	bls.n	80a614c <__aeabi_f2iz+0x30>
 80a6130:	ea4f 2300 	mov.w	r3, r0, lsl #8
 80a6134:	f043 4300 	orr.w	r3, r3, #2147483648	; 0x80000000
 80a6138:	f010 4f00 	tst.w	r0, #2147483648	; 0x80000000
 80a613c:	fa23 f002 	lsr.w	r0, r3, r2
 80a6140:	bf18      	it	ne
 80a6142:	4240      	negne	r0, r0
 80a6144:	4770      	bx	lr
 80a6146:	f04f 0000 	mov.w	r0, #0
 80a614a:	4770      	bx	lr
 80a614c:	f112 0f61 	cmn.w	r2, #97	; 0x61
 80a6150:	d101      	bne.n	80a6156 <__aeabi_f2iz+0x3a>
 80a6152:	0242      	lsls	r2, r0, #9
 80a6154:	d105      	bne.n	80a6162 <__aeabi_f2iz+0x46>
 80a6156:	f010 4000 	ands.w	r0, r0, #2147483648	; 0x80000000
 80a615a:	bf08      	it	eq
 80a615c:	f06f 4000 	mvneq.w	r0, #2147483648	; 0x80000000
 80a6160:	4770      	bx	lr
 80a6162:	f04f 0000 	mov.w	r0, #0
 80a6166:	4770      	bx	lr

080a6168 <atoi>:
 80a6168:	220a      	movs	r2, #10
 80a616a:	2100      	movs	r1, #0
 80a616c:	f000 b970 	b.w	80a6450 <strtol>

080a6170 <__cxa_atexit>:
 80a6170:	b510      	push	{r4, lr}
 80a6172:	4c05      	ldr	r4, [pc, #20]	; (80a6188 <__cxa_atexit+0x18>)
 80a6174:	4613      	mov	r3, r2
 80a6176:	b12c      	cbz	r4, 80a6184 <__cxa_atexit+0x14>
 80a6178:	460a      	mov	r2, r1
 80a617a:	4601      	mov	r1, r0
 80a617c:	2002      	movs	r0, #2
 80a617e:	f3af 8000 	nop.w
 80a6182:	bd10      	pop	{r4, pc}
 80a6184:	4620      	mov	r0, r4
 80a6186:	bd10      	pop	{r4, pc}
 80a6188:	00000000 	.word	0x00000000

080a618c <memcpy>:
 80a618c:	b510      	push	{r4, lr}
 80a618e:	1e43      	subs	r3, r0, #1
 80a6190:	440a      	add	r2, r1
 80a6192:	4291      	cmp	r1, r2
 80a6194:	d004      	beq.n	80a61a0 <memcpy+0x14>
 80a6196:	f811 4b01 	ldrb.w	r4, [r1], #1
 80a619a:	f803 4f01 	strb.w	r4, [r3, #1]!
 80a619e:	e7f8      	b.n	80a6192 <memcpy+0x6>
 80a61a0:	bd10      	pop	{r4, pc}

080a61a2 <memset>:
 80a61a2:	4603      	mov	r3, r0
 80a61a4:	4402      	add	r2, r0
 80a61a6:	4293      	cmp	r3, r2
 80a61a8:	d002      	beq.n	80a61b0 <memset+0xe>
 80a61aa:	f803 1b01 	strb.w	r1, [r3], #1
 80a61ae:	e7fa      	b.n	80a61a6 <memset+0x4>
 80a61b0:	4770      	bx	lr
	...

080a61b4 <srand>:
 80a61b4:	b538      	push	{r3, r4, r5, lr}
 80a61b6:	4b12      	ldr	r3, [pc, #72]	; (80a6200 <srand+0x4c>)
 80a61b8:	4605      	mov	r5, r0
 80a61ba:	681c      	ldr	r4, [r3, #0]
 80a61bc:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 80a61be:	b9d3      	cbnz	r3, 80a61f6 <srand+0x42>
 80a61c0:	2018      	movs	r0, #24
 80a61c2:	f7fd fc61 	bl	80a3a88 <malloc>
 80a61c6:	f243 330e 	movw	r3, #13070	; 0x330e
 80a61ca:	63a0      	str	r0, [r4, #56]	; 0x38
 80a61cc:	8003      	strh	r3, [r0, #0]
 80a61ce:	f64a 33cd 	movw	r3, #43981	; 0xabcd
 80a61d2:	8043      	strh	r3, [r0, #2]
 80a61d4:	f241 2334 	movw	r3, #4660	; 0x1234
 80a61d8:	8083      	strh	r3, [r0, #4]
 80a61da:	f24e 636d 	movw	r3, #58989	; 0xe66d
 80a61de:	80c3      	strh	r3, [r0, #6]
 80a61e0:	f64d 63ec 	movw	r3, #57068	; 0xdeec
 80a61e4:	8103      	strh	r3, [r0, #8]
 80a61e6:	2305      	movs	r3, #5
 80a61e8:	8143      	strh	r3, [r0, #10]
 80a61ea:	230b      	movs	r3, #11
 80a61ec:	8183      	strh	r3, [r0, #12]
 80a61ee:	2201      	movs	r2, #1
 80a61f0:	2300      	movs	r3, #0
 80a61f2:	e9c0 2304 	strd	r2, r3, [r0, #16]
 80a61f6:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 80a61f8:	2200      	movs	r2, #0
 80a61fa:	611d      	str	r5, [r3, #16]
 80a61fc:	615a      	str	r2, [r3, #20]
 80a61fe:	bd38      	pop	{r3, r4, r5, pc}
 80a6200:	2000037c 	.word	0x2000037c

080a6204 <rand>:
 80a6204:	4b19      	ldr	r3, [pc, #100]	; (80a626c <rand+0x68>)
 80a6206:	b510      	push	{r4, lr}
 80a6208:	681c      	ldr	r4, [r3, #0]
 80a620a:	6ba3      	ldr	r3, [r4, #56]	; 0x38
 80a620c:	b9d3      	cbnz	r3, 80a6244 <rand+0x40>
 80a620e:	2018      	movs	r0, #24
 80a6210:	f7fd fc3a 	bl	80a3a88 <malloc>
 80a6214:	f243 330e 	movw	r3, #13070	; 0x330e
 80a6218:	63a0      	str	r0, [r4, #56]	; 0x38
 80a621a:	8003      	strh	r3, [r0, #0]
 80a621c:	f64a 33cd 	movw	r3, #43981	; 0xabcd
 80a6220:	8043      	strh	r3, [r0, #2]
 80a6222:	f241 2334 	movw	r3, #4660	; 0x1234
 80a6226:	8083      	strh	r3, [r0, #4]
 80a6228:	f24e 636d 	movw	r3, #58989	; 0xe66d
 80a622c:	80c3      	strh	r3, [r0, #6]
 80a622e:	f64d 63ec 	movw	r3, #57068	; 0xdeec
 80a6232:	8103      	strh	r3, [r0, #8]
 80a6234:	2305      	movs	r3, #5
 80a6236:	8143      	strh	r3, [r0, #10]
 80a6238:	230b      	movs	r3, #11
 80a623a:	8183      	strh	r3, [r0, #12]
 80a623c:	2201      	movs	r2, #1
 80a623e:	2300      	movs	r3, #0
 80a6240:	e9c0 2304 	strd	r2, r3, [r0, #16]
 80a6244:	6ba1      	ldr	r1, [r4, #56]	; 0x38
 80a6246:	4c0a      	ldr	r4, [pc, #40]	; (80a6270 <rand+0x6c>)
 80a6248:	690b      	ldr	r3, [r1, #16]
 80a624a:	6948      	ldr	r0, [r1, #20]
 80a624c:	435c      	muls	r4, r3
 80a624e:	4a09      	ldr	r2, [pc, #36]	; (80a6274 <rand+0x70>)
 80a6250:	fb02 4000 	mla	r0, r2, r0, r4
 80a6254:	fba3 2302 	umull	r2, r3, r3, r2
 80a6258:	3201      	adds	r2, #1
 80a625a:	4403      	add	r3, r0
 80a625c:	f143 0300 	adc.w	r3, r3, #0
 80a6260:	e9c1 2304 	strd	r2, r3, [r1, #16]
 80a6264:	f023 4000 	bic.w	r0, r3, #2147483648	; 0x80000000
 80a6268:	bd10      	pop	{r4, pc}
 80a626a:	bf00      	nop
 80a626c:	2000037c 	.word	0x2000037c
 80a6270:	5851f42d 	.word	0x5851f42d
 80a6274:	4c957f2d 	.word	0x4c957f2d

080a6278 <strcmp>:
 80a6278:	f810 2b01 	ldrb.w	r2, [r0], #1
 80a627c:	f811 3b01 	ldrb.w	r3, [r1], #1
 80a6280:	2a01      	cmp	r2, #1
 80a6282:	bf28      	it	cs
 80a6284:	429a      	cmpcs	r2, r3
 80a6286:	d0f7      	beq.n	80a6278 <strcmp>
 80a6288:	1ad0      	subs	r0, r2, r3
 80a628a:	4770      	bx	lr

080a628c <strcpy>:
 80a628c:	4603      	mov	r3, r0
 80a628e:	f811 2b01 	ldrb.w	r2, [r1], #1
 80a6292:	f803 2b01 	strb.w	r2, [r3], #1
 80a6296:	2a00      	cmp	r2, #0
 80a6298:	d1f9      	bne.n	80a628e <strcpy+0x2>
 80a629a:	4770      	bx	lr

080a629c <strdup>:
 80a629c:	4b02      	ldr	r3, [pc, #8]	; (80a62a8 <strdup+0xc>)
 80a629e:	4601      	mov	r1, r0
 80a62a0:	6818      	ldr	r0, [r3, #0]
 80a62a2:	f000 b803 	b.w	80a62ac <_strdup_r>
 80a62a6:	bf00      	nop
 80a62a8:	2000037c 	.word	0x2000037c

080a62ac <_strdup_r>:
 80a62ac:	b570      	push	{r4, r5, r6, lr}
 80a62ae:	4606      	mov	r6, r0
 80a62b0:	4608      	mov	r0, r1
 80a62b2:	460c      	mov	r4, r1
 80a62b4:	f000 f80d 	bl	80a62d2 <strlen>
 80a62b8:	1c45      	adds	r5, r0, #1
 80a62ba:	4629      	mov	r1, r5
 80a62bc:	4630      	mov	r0, r6
 80a62be:	f7fd fc0b 	bl	80a3ad8 <_malloc_r>
 80a62c2:	4606      	mov	r6, r0
 80a62c4:	b118      	cbz	r0, 80a62ce <_strdup_r+0x22>
 80a62c6:	462a      	mov	r2, r5
 80a62c8:	4621      	mov	r1, r4
 80a62ca:	f7ff ff5f 	bl	80a618c <memcpy>
 80a62ce:	4630      	mov	r0, r6
 80a62d0:	bd70      	pop	{r4, r5, r6, pc}

080a62d2 <strlen>:
 80a62d2:	4603      	mov	r3, r0
 80a62d4:	f813 2b01 	ldrb.w	r2, [r3], #1
 80a62d8:	2a00      	cmp	r2, #0
 80a62da:	d1fb      	bne.n	80a62d4 <strlen+0x2>
 80a62dc:	1a18      	subs	r0, r3, r0
 80a62de:	3801      	subs	r0, #1
 80a62e0:	4770      	bx	lr

080a62e2 <strsep>:
 80a62e2:	4602      	mov	r2, r0
 80a62e4:	2300      	movs	r3, #0
 80a62e6:	6800      	ldr	r0, [r0, #0]
 80a62e8:	f000 b800 	b.w	80a62ec <__strtok_r>

080a62ec <__strtok_r>:
 80a62ec:	b5f0      	push	{r4, r5, r6, r7, lr}
 80a62ee:	b948      	cbnz	r0, 80a6304 <__strtok_r+0x18>
 80a62f0:	6810      	ldr	r0, [r2, #0]
 80a62f2:	b938      	cbnz	r0, 80a6304 <__strtok_r+0x18>
 80a62f4:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80a62f6:	f817 6b01 	ldrb.w	r6, [r7], #1
 80a62fa:	b15e      	cbz	r6, 80a6314 <__strtok_r+0x28>
 80a62fc:	42b5      	cmp	r5, r6
 80a62fe:	d1fa      	bne.n	80a62f6 <__strtok_r+0xa>
 80a6300:	b12b      	cbz	r3, 80a630e <__strtok_r+0x22>
 80a6302:	4620      	mov	r0, r4
 80a6304:	4604      	mov	r4, r0
 80a6306:	460f      	mov	r7, r1
 80a6308:	f814 5b01 	ldrb.w	r5, [r4], #1
 80a630c:	e7f3      	b.n	80a62f6 <__strtok_r+0xa>
 80a630e:	6014      	str	r4, [r2, #0]
 80a6310:	7003      	strb	r3, [r0, #0]
 80a6312:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80a6314:	b94d      	cbnz	r5, 80a632a <__strtok_r+0x3e>
 80a6316:	6015      	str	r5, [r2, #0]
 80a6318:	4628      	mov	r0, r5
 80a631a:	bdf0      	pop	{r4, r5, r6, r7, pc}
 80a631c:	f817 6b01 	ldrb.w	r6, [r7], #1
 80a6320:	42b5      	cmp	r5, r6
 80a6322:	d007      	beq.n	80a6334 <__strtok_r+0x48>
 80a6324:	2e00      	cmp	r6, #0
 80a6326:	d1f9      	bne.n	80a631c <__strtok_r+0x30>
 80a6328:	461c      	mov	r4, r3
 80a632a:	4623      	mov	r3, r4
 80a632c:	460f      	mov	r7, r1
 80a632e:	f813 5b01 	ldrb.w	r5, [r3], #1
 80a6332:	e7f3      	b.n	80a631c <__strtok_r+0x30>
 80a6334:	b115      	cbz	r5, 80a633c <__strtok_r+0x50>
 80a6336:	2100      	movs	r1, #0
 80a6338:	7021      	strb	r1, [r4, #0]
 80a633a:	e000      	b.n	80a633e <__strtok_r+0x52>
 80a633c:	462b      	mov	r3, r5
 80a633e:	6013      	str	r3, [r2, #0]
 80a6340:	bdf0      	pop	{r4, r5, r6, r7, pc}
	...

080a6344 <_strtol_r>:
 80a6344:	e92d 47f0 	stmdb	sp!, {r4, r5, r6, r7, r8, r9, sl, lr}
 80a6348:	460f      	mov	r7, r1
 80a634a:	4680      	mov	r8, r0
 80a634c:	483f      	ldr	r0, [pc, #252]	; (80a644c <_strtol_r+0x108>)
 80a634e:	f8d0 9000 	ldr.w	r9, [r0]
 80a6352:	463d      	mov	r5, r7
 80a6354:	f815 4b01 	ldrb.w	r4, [r5], #1
 80a6358:	eb09 0004 	add.w	r0, r9, r4
 80a635c:	7840      	ldrb	r0, [r0, #1]
 80a635e:	f000 0008 	and.w	r0, r0, #8
 80a6362:	f000 06ff 	and.w	r6, r0, #255	; 0xff
 80a6366:	b108      	cbz	r0, 80a636c <_strtol_r+0x28>
 80a6368:	462f      	mov	r7, r5
 80a636a:	e7f2      	b.n	80a6352 <_strtol_r+0xe>
 80a636c:	2c2d      	cmp	r4, #45	; 0x2d
 80a636e:	d103      	bne.n	80a6378 <_strtol_r+0x34>
 80a6370:	1cbd      	adds	r5, r7, #2
 80a6372:	787c      	ldrb	r4, [r7, #1]
 80a6374:	2601      	movs	r6, #1
 80a6376:	e003      	b.n	80a6380 <_strtol_r+0x3c>
 80a6378:	2c2b      	cmp	r4, #43	; 0x2b
 80a637a:	bf04      	itt	eq
 80a637c:	787c      	ldrbeq	r4, [r7, #1]
 80a637e:	1cbd      	addeq	r5, r7, #2
 80a6380:	b113      	cbz	r3, 80a6388 <_strtol_r+0x44>
 80a6382:	2b10      	cmp	r3, #16
 80a6384:	d10a      	bne.n	80a639c <_strtol_r+0x58>
 80a6386:	e05b      	b.n	80a6440 <_strtol_r+0xfc>
 80a6388:	2c30      	cmp	r4, #48	; 0x30
 80a638a:	d157      	bne.n	80a643c <_strtol_r+0xf8>
 80a638c:	7828      	ldrb	r0, [r5, #0]
 80a638e:	f000 00df 	and.w	r0, r0, #223	; 0xdf
 80a6392:	2858      	cmp	r0, #88	; 0x58
 80a6394:	d14d      	bne.n	80a6432 <_strtol_r+0xee>
 80a6396:	786c      	ldrb	r4, [r5, #1]
 80a6398:	2310      	movs	r3, #16
 80a639a:	3502      	adds	r5, #2
 80a639c:	2e00      	cmp	r6, #0
 80a639e:	bf14      	ite	ne
 80a63a0:	f04f 4c00 	movne.w	ip, #2147483648	; 0x80000000
 80a63a4:	f06f 4c00 	mvneq.w	ip, #2147483648	; 0x80000000
 80a63a8:	fbbc faf3 	udiv	sl, ip, r3
 80a63ac:	2700      	movs	r7, #0
 80a63ae:	4638      	mov	r0, r7
 80a63b0:	fb03 cc1a 	mls	ip, r3, sl, ip
 80a63b4:	eb09 0e04 	add.w	lr, r9, r4
 80a63b8:	f89e e001 	ldrb.w	lr, [lr, #1]
 80a63bc:	f01e 0f04 	tst.w	lr, #4
 80a63c0:	d001      	beq.n	80a63c6 <_strtol_r+0x82>
 80a63c2:	3c30      	subs	r4, #48	; 0x30
 80a63c4:	e00b      	b.n	80a63de <_strtol_r+0x9a>
 80a63c6:	f01e 0e03 	ands.w	lr, lr, #3
 80a63ca:	d01b      	beq.n	80a6404 <_strtol_r+0xc0>
 80a63cc:	f1be 0f01 	cmp.w	lr, #1
 80a63d0:	bf0c      	ite	eq
 80a63d2:	f04f 0e37 	moveq.w	lr, #55	; 0x37
 80a63d6:	f04f 0e57 	movne.w	lr, #87	; 0x57
 80a63da:	ebce 0404 	rsb	r4, lr, r4
 80a63de:	42a3      	cmp	r3, r4
 80a63e0:	dd10      	ble.n	80a6404 <_strtol_r+0xc0>
 80a63e2:	f1b7 3fff 	cmp.w	r7, #4294967295
 80a63e6:	d00a      	beq.n	80a63fe <_strtol_r+0xba>
 80a63e8:	4550      	cmp	r0, sl
 80a63ea:	d806      	bhi.n	80a63fa <_strtol_r+0xb6>
 80a63ec:	d101      	bne.n	80a63f2 <_strtol_r+0xae>
 80a63ee:	4564      	cmp	r4, ip
 80a63f0:	dc03      	bgt.n	80a63fa <_strtol_r+0xb6>
 80a63f2:	fb03 4000 	mla	r0, r3, r0, r4
 80a63f6:	2701      	movs	r7, #1
 80a63f8:	e001      	b.n	80a63fe <_strtol_r+0xba>
 80a63fa:	f04f 37ff 	mov.w	r7, #4294967295
 80a63fe:	f815 4b01 	ldrb.w	r4, [r5], #1
 80a6402:	e7d7      	b.n	80a63b4 <_strtol_r+0x70>
 80a6404:	1c7b      	adds	r3, r7, #1
 80a6406:	d10c      	bne.n	80a6422 <_strtol_r+0xde>
 80a6408:	2e00      	cmp	r6, #0
 80a640a:	f04f 0322 	mov.w	r3, #34	; 0x22
 80a640e:	bf14      	ite	ne
 80a6410:	f04f 4000 	movne.w	r0, #2147483648	; 0x80000000
 80a6414:	f06f 4000 	mvneq.w	r0, #2147483648	; 0x80000000
 80a6418:	f8c8 3000 	str.w	r3, [r8]
 80a641c:	b92a      	cbnz	r2, 80a642a <_strtol_r+0xe6>
 80a641e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80a6422:	b106      	cbz	r6, 80a6426 <_strtol_r+0xe2>
 80a6424:	4240      	negs	r0, r0
 80a6426:	b172      	cbz	r2, 80a6446 <_strtol_r+0x102>
 80a6428:	b107      	cbz	r7, 80a642c <_strtol_r+0xe8>
 80a642a:	1e69      	subs	r1, r5, #1
 80a642c:	6011      	str	r1, [r2, #0]
 80a642e:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80a6432:	2430      	movs	r4, #48	; 0x30
 80a6434:	2b00      	cmp	r3, #0
 80a6436:	d1b1      	bne.n	80a639c <_strtol_r+0x58>
 80a6438:	2308      	movs	r3, #8
 80a643a:	e7af      	b.n	80a639c <_strtol_r+0x58>
 80a643c:	230a      	movs	r3, #10
 80a643e:	e7ad      	b.n	80a639c <_strtol_r+0x58>
 80a6440:	2c30      	cmp	r4, #48	; 0x30
 80a6442:	d0a3      	beq.n	80a638c <_strtol_r+0x48>
 80a6444:	e7aa      	b.n	80a639c <_strtol_r+0x58>
 80a6446:	e8bd 87f0 	ldmia.w	sp!, {r4, r5, r6, r7, r8, r9, sl, pc}
 80a644a:	bf00      	nop
 80a644c:	20000318 	.word	0x20000318

080a6450 <strtol>:
 80a6450:	4613      	mov	r3, r2
 80a6452:	460a      	mov	r2, r1
 80a6454:	4601      	mov	r1, r0
 80a6456:	4802      	ldr	r0, [pc, #8]	; (80a6460 <strtol+0x10>)
 80a6458:	6800      	ldr	r0, [r0, #0]
 80a645a:	f7ff bf73 	b.w	80a6344 <_strtol_r>
 80a645e:	bf00      	nop
 80a6460:	2000037c 	.word	0x2000037c

080a6464 <tolower>:
 80a6464:	4b04      	ldr	r3, [pc, #16]	; (80a6478 <tolower+0x14>)
 80a6466:	681b      	ldr	r3, [r3, #0]
 80a6468:	4403      	add	r3, r0
 80a646a:	785b      	ldrb	r3, [r3, #1]
 80a646c:	f003 0303 	and.w	r3, r3, #3
 80a6470:	2b01      	cmp	r3, #1
 80a6472:	bf08      	it	eq
 80a6474:	3020      	addeq	r0, #32
 80a6476:	4770      	bx	lr
 80a6478:	20000318 	.word	0x20000318

080a647c <dynalib_user>:
 80a647c:	080a001d 080a005d 080a0089 080a008d     ....]...........
 80a648c:	00000000                                ....

080a6490 <_ZTV5Timer>:
	...
 80a6498:	080a066d 080a06ad 080a1213              m...........

080a64a4 <_ZTVN9NSFastLED7WS2812BILh4ELNS_6EOrderE66EEE>:
	...
 80a64ac:	080a156b 080a1509 080a0451 080a0425     k.......Q...%...
 80a64bc:	77707061 25007464 64332e30 2e30252c     appwdt.%0.3d,%0.
 80a64cc:	252c6433 64332e30 75727400 61660065     3d,%0.3d.true.fa
 80a64dc:	0065736c 44394132 70484151 78717777     lse.2A9DQAHpwwqx
 80a64ec:	7132366b 746b5854 6b6c4b47 64326f49     k62qTXktGKlkIo2d
 80a64fc:	5a6b7037 564f504e 54596f50 67697a00     7pkZNPOVPoYT.zig
 80a650c:	65727261 2f002f00 74617473 69442f65     arre././state/Di
 80a651c:	616c7073 646f4d79 732f0065 65746174     splayMode./state
 80a652c:	6972422f 6e746867 00737365 6174732f     /Brightness./sta
 80a653c:	462f6574 7267726f 646e756f 6f6c6f43     te/ForgroundColo
 80a654c:	732f0072 65746174 6361422f 6f72676b     r./state/Backgro
 80a655c:	43646e75 726f6c6f 74732f00 2f657461     undColor./state/
 80a656c:	4478614d 61747369 0065636e 6174732f     MaxDistance./sta
 80a657c:	4c2f6574 44747361 61747369 0065636e     te/LastDistance.
 80a658c:	6174732f 432f6574 65727275 6944746e     /state/CurrentDi
 80a659c:	6e617473 2f006563 74617473 69462f65     stance./state/Fi
 80a65ac:	61776d72 65566572 6f697372 732f006e     rmwareVersion./s
 80a65bc:	65746174 7369442f 79616c70 62616e45     tate/DisplayEnab
 80a65cc:	0064656c 66746e45 756e7265 203a676e     led.Entfernung: 
 80a65dc:	20643625 45006d63 6566746e 6e756e72     %6d cm.Entfernun
 80a65ec:	002c0067 6174732f 4c2f6574 50747361     g.,./state/LastP
 80a65fc:	6f6c7961 4c006461 20747361 6c796150     ayload.Last Payl
 80a660c:	3a64616f 732f0020 442f7465 6c707369     oad: ./set/Displ
 80a661c:	6f4d7961 2f006564 2f746573 67697242     ayMode./set/Brig
 80a662c:	656e7468 2f007373 2f746573 67726f46     htness./set/Forg
 80a663c:	6e756f72 6c6f4364 2f00726f 2f746573     roundColor./set/
 80a664c:	6b636142 756f7267 6f43646e 00726f6c     BackgroundColor.
 80a665c:	7465732f 616e452f 44656c62 6c707369     /set/EnableDispl
 80a666c:	2f007961 2f746573 716d002b 732e7474     ay./set/+.mqtt.s
 80a667c:	70706f74 726f2e65 59580067 6425203a     toppe.org.XY: %d
 80a668c:	3a58202c 2c642520 203a5920 00006425     , X: %d, Y: %d..

080a669c <_ZN9NSFastLED12LavaColors_pE>:
 80a669c:	00000000 00800000 00000000 00800000     ................
 80a66ac:	008b0000 00800000 008b0000 008b0000     ................
 80a66bc:	008b0000 00ff0000 00ffa500 00ffffff     ................
 80a66cc:	00ffa500 00ff0000 008b0000 00000000     ................

080a66dc <_ZN9NSFastLED15RainbowColors_pE>:
 80a66dc:	00ff0000 00d52a00 00ab5500 00ab7f00     .....*...U......
 80a66ec:	00abab00 0056d500 0000ff00 0000d52a     ......V.....*...
 80a66fc:	0000ab55 000056aa 000000ff 002a00d5     U....V........*.
 80a670c:	005500ab 007f0081 00ab0055 00d5002b     ..U.....U...+...

080a671c <_ZN9NSFastLED13PartyColors_pE>:
 80a671c:	005500ab 0084007c 00b5004b 00e5001b     ..U.|...K.......
 80a672c:	00e81700 00b84700 00ab7700 00abab00     .....G...w......
 80a673c:	00ab5500 00dd2200 00f2000e 00c2003e     .U..."......>...
 80a674c:	008f0071 005f00a1 002f00d0 000007f9     q....._.../.....

080a675c <_ZN9NSFastLED13CloudColors_pE>:
 80a675c:	000000ff 0000008b 0000008b 0000008b     ................
 80a676c:	0000008b 0000008b 0000008b 0000008b     ................
 80a677c:	000000ff 0000008b 0087ceeb 0087ceeb     ................
 80a678c:	00add8e6 00ffffff 00add8e6 0087ceeb     ................

080a679c <_ZN9NSFastLED14ForestColors_pE>:
 80a679c:	00006400 00006400 00556b2f 00006400     .d...d../kU..d..
 80a67ac:	00008000 00228b22 006b8e23 00008000     ....".".#.k.....
 80a67bc:	002e8b57 0066cdaa 0032cd32 009acd32     W.....f.2.2.2...
 80a67cc:	0090ee90 007cfc00 0066cdaa 00228b22     ......|...f.".".

080a67dc <_ZN9NSFastLED21RainbowStripeColors_pE>:
 80a67dc:	00ff0000 00000000 00ab5500 00000000     .........U......
 80a67ec:	00abab00 00000000 0000ff00 00000000     ................
 80a67fc:	0000ab55 00000000 000000ff 00000000     U...............
 80a680c:	005500ab 00000000 00ab0055 00000000     ..U.....U.......

080a681c <_ZN9NSFastLED13OceanColors_pE>:
 80a681c:	00191970 0000008b 00191970 00000080     p.......p.......
 80a682c:	0000008b 000000cd 002e8b57 00008080     ........W.......
 80a683c:	005f9ea0 000000ff 00008b8b 006495ed     .._...........d.
 80a684c:	007fffd4 002e8b57 0000ffff 0087cefa     ....W...........

080a685c <_ZN9NSFastLEDL1pE>:
 80a685c:	5b89a097 0d830f5a 35605fc9 e107e9c2     ...[Z...._`5....
 80a686c:	1e67248c 63088e45 0a15f025 9406be17     .$g.E..c%.......
 80a687c:	4bea78f7 3ec51a00 cbdbfc5e 200b2375     .x.K...>^...u#. 
 80a688c:	5821b139 573895ed 887d14ae af44a8ab     9.!X..8W..}...D.
 80a689c:	8647a54a a61b308b e79e924d 7ae56f53     J.G..0..M...So.z
 80a68ac:	e685d33c 295c69dc 28f52e37 368f66f4     <....i\)7..(.f.6
 80a68bc:	a13f1941 4950d801 bb844cd1 a91259d0     A.?...PI.L...Y..
 80a68cc:	8287c4c8 569fbc74 c66d64a4 4003baad     ....t..V.dm....@
 80a68dc:	fae2d934 ca057b7c 7e769326 d45552ff     4...|{..&.v~.RU.
 80a68ec:	e33bcecf 113a102f 2a1cbdb6 d5aab7df     ..;./.:....*....
 80a68fc:	0298f877 46a39a2c 9b6599dd 09ac2ba7     w...,..F..e..+..
 80a690c:	fd271681 6e6c6213 e8e0714f 6870b9b2     ..'..blnOq....ph
 80a691c:	e461f6da c1f222fb 0c90d2ee f1a2b3bf     ..a.."..........
 80a692c:	eb913351 6bef0ef9 1fd6c031 9d6ac7b5     Q3.....k1.....j.
 80a693c:	b0cc54b8 2d327973 fe96047f 5dcdec8a     .T..sy2-.......]
 80a694c:	1d4372de 8df34818 424ec380 b49c3dd7     .rC..H....NB.=..
 80a695c:	4d040097 04545451 514d0600 70647349     ...MQTT...MQIsdp
 80a696c:	00000003                                ....

080a6970 <_ZTVN5spark9WiFiClassE>:
	...
 80a6978:	080a3b23                                #;..

080a697c <_ZN5spark7NetworkE>:
 80a697c:	20000908                                ... 

080a6980 <_ZTV7TwoWire>:
	...
 80a6988:	080a3ba1 080a3beb 080a3bc3 080a3ba3     .;...;...;...;..
 80a6998:	080a3bcb 080a3bd3 080a3bdb 080a3be3     .;...;...;...;..

080a69a8 <_ZTV9USBSerial>:
	...
 80a69b0:	080a3c29 080a3c6d 080a3c47 080a454d     )<..m<..G<..ME..
 80a69c0:	080a3c41 080a3c2b 080a3c33 080a3c67     A<..+<..3<..g<..
 80a69d0:	080a3c3b 080a3c25                       ;<..%<..

080a69d8 <_ZTV9IPAddress>:
	...
 80a69e0:	080a3da7 080a3d99 080a3d9b              .=...=...=..

080a69ec <_ZTVSt15_Sp_counted_ptrIPN8particle6detail10FutureImplIbNS1_13FutureContextEEELN9__gnu_cxx12_Lock_policyE0EE>:
	...
 80a69f4:	080a3e55 080a3e5b 080a3e71 080a3e67     U>..[>..q>..g>..
 80a6a04:	080a3e57 2b25005a 3a643330 75323025     W>..Z.%+03d:%02u
 80a6a14:	2d592500 252d6d25 48255464 3a4d253a     .%Y-%m-%dT%H:%M:
 80a6a24:	7a255325 63736100 656d6974 6c006600     %S%z.asctime.f.l
 80a6a34:	6e66006e 646f6300 65640065 6c696174     n.fn.code.detail
 80a6a44:	000a0d00 30313025 5d002075 202c0020     ....%010u .] ., 
 80a6a54:	3a292800 5b200020 646f6300 203d2065     .(): . [.code = 
 80a6a64:	00692500 61746564 20736c69 6200203d     .%i.details = .b
 80a6a74:	00647561 69726553 55006c61 65534253     aud.Serial.USBSe
 80a6a84:	6c616972 79740031 70006570 6d617261     rial1.type.param
 80a6a94:	646d6300 00646900 00646e68 6d727473     .cmd.id.hnd.strm
 80a6aa4:	6c696600 766c0074 6461006c 6e614864     .filt.lvl.addHan
 80a6ab4:	72656c64 6d657200 4865766f 6c646e61     dler.removeHandl
 80a6ac4:	65007265 486d756e 6c646e61 00737265     er.enumHandlers.
 80a6ad4:	4e4f534a 65727453 6f4c6d61 6e614867     JSONStreamLogHan
 80a6ae4:	72656c64 70706100 6e6f6e00 72740065     dler.app.none.tr
 80a6af4:	00656361 6f666e69 72617700 7265006e     ace.info.warn.er
 80a6b04:	00726f72 696e6170 6c610063 0000006c     ror.panic.all...

080a6b14 <_ZTV11USARTSerial>:
	...
 80a6b1c:	080a4683 080a46a7 080a46b3 080a454d     .F...F...F..ME..
 80a6b2c:	080a468f 080a469b 080a4695 080a46a1     .F...F...F...F..
 80a6b3c:	080a4685 080a4689                       .F...F..

080a6b44 <_ZTVSt19_Sp_counted_deleterIPN9TCPClient4DataENSt12__shared_ptrIS1_LN9__gnu_cxx12_Lock_policyE0EE8_DeleterISaIS1_EEES8_LS5_0EE>:
	...
 80a6b4c:	080a479d 080a47a3 080a48c3 080a47af     .G...G...H...G..
 80a6b5c:	080a479f                                .G..

080a6b60 <_ZTV9TCPClient>:
	...
 80a6b68:	080a2d89 080a2dbd 080a4759 080a4773     .-...-..YG..sG..
 80a6b78:	080a4941 080a488f 080a4861 080a479b     AI...H..aH...G..
 80a6b88:	080a4a75 080a47b5 080a48df 080a49bd     uJ...G...H...I..
 80a6b98:	080a4bc5 080a4c17 080a4783 080a4b89     .K...L...G...K..
 80a6ba8:	080a4841 69726977 5400676e 6c435043     AH..wiring.TCPCl
 80a6bb8:	746e6569 636f7320 3d74656b 00007825     ient socket=%x..

080a6bc8 <_ZTV8SPIClass>:
	...
 80a6bd0:	080a4d15 080a4d17                       .M...M..

080a6bd8 <_ZSt7nothrow>:
	...

080a6bd9 <_ctype_>:
 80a6bd9:	20202000 20202020 28282020 20282828     .         ((((( 
 80a6be9:	20202020 20202020 20202020 20202020                     
 80a6bf9:	10108820 10101010 10101010 10101010      ...............
 80a6c09:	04040410 04040404 10040404 10101010     ................
 80a6c19:	41411010 41414141 01010101 01010101     ..AAAAAA........
 80a6c29:	01010101 01010101 01010101 10101010     ................
 80a6c39:	42421010 42424242 02020202 02020202     ..BBBBBB........
 80a6c49:	02020202 02020202 02020202 10101010     ................
 80a6c59:	00000020 00000000 00000000 00000000      ...............
	...

080a6cdc <__sf_fake_stdin>:
	...

080a6cfc <__sf_fake_stdout>:
	...

080a6d1c <__sf_fake_stderr>:
	...
 80a6d3c:	00000043                                         C.

080a6d3e <link_const_variable_data_end>:
	...

080a6d40 <link_constructors_location>:
 80a6d40:	080a0279 	.word	0x080a0279
 80a6d44:	080a02fd 	.word	0x080a02fd
 80a6d48:	080a0405 	.word	0x080a0405
 80a6d4c:	080a15cd 	.word	0x080a15cd
 80a6d50:	080a170d 	.word	0x080a170d
 80a6d54:	080a1cf9 	.word	0x080a1cf9
 80a6d58:	080a1de5 	.word	0x080a1de5
 80a6d5c:	080a2035 	.word	0x080a2035
 80a6d60:	080a2105 	.word	0x080a2105
 80a6d64:	080a21a1 	.word	0x080a21a1
 80a6d68:	080a2265 	.word	0x080a2265
 80a6d6c:	080a240d 	.word	0x080a240d
 80a6d70:	080a25a9 	.word	0x080a25a9
 80a6d74:	080a25b9 	.word	0x080a25b9
 80a6d78:	080a2741 	.word	0x080a2741
 80a6d7c:	080a283f 	.word	0x080a283f
 80a6d80:	080a2c4f 	.word	0x080a2c4f
 80a6d84:	080a2c53 	.word	0x080a2c53
 80a6d88:	080a2d65 	.word	0x080a2d65
 80a6d8c:	080a2d81 	.word	0x080a2d81
 80a6d90:	080a2d85 	.word	0x080a2d85
 80a6d94:	080a35c7 	.word	0x080a35c7
 80a6d98:	080a3b2d 	.word	0x080a3b2d
 80a6d9c:	080a44d5 	.word	0x080a44d5
 80a6da0:	080a4529 	.word	0x080a4529
 80a6da4:	080a453d 	.word	0x080a453d
 80a6da8:	080a4cd5 	.word	0x080a4cd5
 80a6dac:	080a4fcd 	.word	0x080a4fcd
 80a6db0:	080a50ad 	.word	0x080a50ad
 80a6db4:	080a51cd 	.word	0x080a51cd
 80a6db8:	080a5251 	.word	0x080a5251
 80a6dbc:	080a5315 	.word	0x080a5315
 80a6dc0:	080a53d9 	.word	0x080a53d9

080a6dc4 <link_constructors_end>:
	...
